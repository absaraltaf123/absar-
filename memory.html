
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Make responsive -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Premium Mind Map Maker (Cloud)</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        :root {
            /* Light Mode Defaults */
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --secondary: #f3f4f6;
            --background: #ffffff;
            --canvas-bg: #f9fafb; /* Light background for canvas */
            --text: #1f2937;
            --text-muted: #080808; /* Darker text-muted in light mode */
            --border: #e5e7eb;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --connector-width: 2.5px;
            --connector-default-color: #cbd5e1; /* Default grey */
            --node-bg-color: white; /* Default node background */
            --node-border-color: rgba(0, 0, 0, 0.1);
            --node-text-color: var(--text);
            --node-content-color: #000000; /* Black content text in light mode */
            --modal-bg: white;
            --input-bg: white;
            --input-border: var(--border);
            --control-bg: rgba(255, 255, 255, 0.8);
            --control-icon-color: #6b7280;
            --sidebar-bg: var(--secondary);
            --tree-hover-bg: #e5e7eb;
            --tree-selected-bg: var(--primary-light);
            --tree-selected-text: white;
            --tab-bg: var(--secondary);
            --tab-text: var(--text-muted);
            --tab-hover-bg: var(--border);
            --tab-active-bg: var(--background);
            --tab-active-text: var(--primary);
            --tab-border: var(--border);
            --danger-bg: #fee2e2;
            --danger-text: #ef4444;
            --danger-hover-bg: #fecaca;
            --danger-border: #fca5a5;


            --sidebar-width: 250px;
            --header-height: 65px; /* Approximate */
            --tabs-height: 45px; /* Approximate */
        }

        /* Dark Mode Variables */
        html.dark-mode {
            --primary: #818cf8; /* Lighter primary */
            --primary-light: #a7b2fb;
            --primary-dark: #6366f1;
            --secondary: #374151; /* Darker grey */
            --background: #111827; /* Very dark grey */
            --canvas-bg: #1f2937; /* Dark grey canvas */
            --text: #f9fafb; /* Light grey text */
            --text-muted: #9ca3af;
            --border: #4b5563; /* Medium grey border */
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
            --connector-default-color: #6b7280; /* Darker default connector */
            --node-bg-color: #374151; /* Dark node background */
            --node-border-color: rgba(255, 255, 255, 0.1);
            --node-text-color: var(--text);
            --node-content-color: #f3f4f6; /* Lighter content text */
            --modal-bg: #2a3341;
            --input-bg: #374151;
            --input-border: #4b5563;
            --control-bg: rgba(31, 41, 55, 0.8); /* Darker control bg */
            --control-icon-color: #9ca3af;
            --sidebar-bg: #1f2937;
            --tree-hover-bg: #4b5563;
            --tree-selected-bg: var(--primary); /* Use lighter primary */
            --tree-selected-text: #111827; /* Dark text on selected */
            --tab-bg: #1f2937;
            --tab-text: #9ca3af;
            --tab-hover-bg: #374151;
            --tab-active-bg: #111827;
            --tab-active-text: var(--primary-light);
            --tab-border: #4b5563;
            --danger-bg: #450a0a;
            --danger-text: #f87171;
            --danger-hover-bg: #5f1111;
            --danger-border: #7f1d1d;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            -webkit-tap-highlight-color: transparent; /* Remove blue tap highlight on mobile */
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; /* Smooth theme transitions */
        }

        html, body {
             height: 100%;
             overflow: hidden;
             overscroll-behavior: none;
        }

        body {
            background-color: var(--background);
            color: var(--text);
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.8rem 1.5rem;
            background-color: var(--background);
            border-bottom: 1px solid var(--border);
            box-shadow: var(--shadow);
            z-index: 10;
            flex-shrink: 0;
            min-height: var(--header-height);
        }

        @media (max-width: 400px) {
           .logo span { display: none; }
        }

        .logo {
            font-weight: 700;
            font-size: 1.4rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toolbar {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap; /* Allow wrapping on very small screens */
        }

        #sidebar-toggle, #theme-toggle {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 0.5rem;
            font-size: 1.1rem;
            padding: 0.6rem;
            border: 1px solid var(--border);
            background-color: var(--secondary);
            border-radius: 0.375rem;
            cursor: pointer;
            color: var(--text-muted);
            width: 38px;
            height: 38px;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }
        #sidebar-toggle:hover, #theme-toggle:hover {
             background-color: var(--border);
             border-color: var(--text-muted);
             color: var(--text);
        }
        #sidebar-toggle { display: none; }

        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: 1px solid transparent;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            white-space: nowrap;
        }
         .btn:disabled {
             opacity: 0.6;
             cursor: not-allowed;
         }
         .btn i {
             font-size: 0.9em;
             width: 1em;
             text-align: center;
         }
         .btn-primary {
            background-color: var(--primary);
            color: white;
            border-color: var(--primary);
         }
         html.dark-mode .btn-primary {
            color: var(--background);
         }
         .btn-primary:hover:not(:disabled) {
            background-color: var(--primary-dark);
            border-color: var(--primary-dark);
         }
         .btn-secondary {
            background-color: var(--secondary);
            color: var(--text);
            border-color: var(--border);
         }
         .btn-secondary:hover:not(:disabled) {
            background-color: var(--border);
            border-color: var(--text-muted);
         }
         /* Specific Danger Button Style */
         .btn-danger {
             background-color: var(--danger-bg);
             color: var(--danger-text);
             border-color: var(--danger-border);
         }
         .btn-danger:hover:not(:disabled) {
            background-color: var(--danger-hover-bg);
            border-color: color-mix(in srgb, var(--danger-border) 80%, black);
         }


        /* Map Tabs */
        #map-tabs-container {
            display: flex;
            flex-wrap: nowrap; /* Prevent wrapping, enable scroll */
            overflow-x: auto;
            padding: 0.5rem 1.5rem 0;
            background-color: var(--tab-bg);
            border-bottom: 1px solid var(--tab-border);
            min-height: var(--tabs-height);
            flex-shrink: 0;
            scrollbar-width: thin; /* Firefox */
            scrollbar-color: var(--primary-light) var(--tab-bg); /* Firefox */
        }
        #map-tabs-container::-webkit-scrollbar {
            height: 5px;
        }
        #map-tabs-container::-webkit-scrollbar-track {
            background: var(--tab-bg);
        }
        #map-tabs-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-light);
            border-radius: 10px;
            border: 1px solid var(--tab-bg);
        }

        .map-tab {
            padding: 0.5rem 1rem;
            margin-right: 0.25rem;
            border: 1px solid var(--tab-border);
            border-bottom: none;
            border-top-left-radius: 0.375rem;
            border-top-right-radius: 0.375rem;
            cursor: pointer;
            font-size: 0.85rem;
            white-space: nowrap;
            color: var(--tab-text);
            background-color: var(--tab-bg);
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
            max-width: 150px; /* Prevent tabs from getting too wide */
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .map-tab:hover {
            background-color: var(--tab-hover-bg);
            color: var(--text);
        }
        .map-tab.active {
            background-color: var(--background); /* Match body background */
            color: var(--tab-active-text);
            border-color: var(--tab-border);
            border-bottom-color: var(--background); /* Hide bottom border */
            position: relative;
            top: 1px; /* Align with border */
            font-weight: 500;
        }


        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
            /* Height calculation adjusts for header AND tabs */
            height: calc(100vh - var(--header-height) - var(--tabs-height));
        }

        .sidebar {
            width: var(--sidebar-width);
            border-right: 1px solid var(--border);
            padding: 1rem;
            background-color: var(--sidebar-bg);
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 5;
             transition: transform 0.3s ease, background-color 0.2s ease, border-color 0.2s ease;
             /* Adjusted height calculation */
             height: 100%;
        }
        .sidebar-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--canvas-bg);
            /* Adjusted height calculation */
            height: 100%;
            touch-action: none;
        }

        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
            z-index: 0;
            transform-origin: 0 0;
        }
        #connector-svg line {
            stroke-width: var(--connector-width);
            stroke-linecap: round;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
            transform-origin: 0 0;
            z-index: 1;
        }
        #canvas.grabbing { cursor: grabbing; }

        /* Node Styling (Minor adjustments for 'all' mode) */
        .node {
            position: absolute;
            min-width: 120px;
            max-width: 220px;
            padding: 0.8rem 1rem;
            border-radius: 0.6rem;
            border: 1px solid var(--node-border-color);
            cursor: pointer;
            transition: box-shadow 0.2s ease, border-color 0.2s ease, transform 0.1s linear, background-color 0.2s ease;
            user-select: none;
            -webkit-user-select: none;
            background-color: var(--node-bg-color);
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.15), var(--shadow);
            transform: translate(0,0);
            z-index: 2; /* Nodes above connectors */
        }
        html.dark-mode .node {
             box-shadow: inset 0 1px 1px rgba(255,255,255,0.05), var(--shadow);
        }
        .node.display-all-root {
            cursor: pointer; /* Explicitly pointer for roots in 'all' mode */
            transform: translate(0,0) scale(0.9); /* Slightly smaller in 'all' view */
            transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;
        }
        .node.display-all-root:hover {
             transform: translate(0,0) scale(0.95);
             box-shadow: inset 0 1px 1px rgba(255,255,255,0.15), var(--shadow-lg);
             border-color: var(--primary);
        }
         html.dark-mode .node.display-all-root:hover {
            transform: translate(0,0) scale(0.95);
             box-shadow: inset 0 1px 1px rgba(255,255,255,0.05), var(--shadow-lg);
             border-color: var(--primary);
         }


        .node:hover:not(.display-all-root) { /* Standard hover */
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.15), var(--shadow-lg);
            border-color: var(--primary-light);
        }
        html.dark-mode .node:hover:not(.display-all-root) {
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.05), var(--shadow-lg);
        }

        .node.selected:not(.display-all-root) { /* Standard selection */
            border: 2px solid var(--primary);
             box-shadow: inset 0 1px 1px rgba(255,255,255,0.15), var(--shadow-lg);
        }
         html.dark-mode .node.selected:not(.display-all-root) {
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.05), var(--shadow-lg);
         }

        /* Node Shapes */
        .node.node-shape-rectangle { border-radius: 0.3rem; }
        .node.node-shape-rounded-rectangle { border-radius: 0.6rem; }
        .node.node-shape-stadium { border-radius: 999px; }
        .node.node-shape-ellipse { border-radius: 50%; padding: 1rem; min-width: auto; text-align: center; }

        .node-title, .node-content {
             user-select: text;
             -webkit-user-select: text;
             word-wrap: break-word;
        }
        .node-title { font-weight: 600; font-size: 0.9rem; margin-bottom: 0.4rem; color: var(--node-text-color); }
        .node-content { font-size: 0.78rem; color: var(--node-content-color); line-height: 1.4; }

        /* Modal Styling (Generic, used for Node Edit and Delete Map Confirm) */
         .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 20; visibility: hidden; opacity: 0; transition: visibility 0s 0.2s, opacity 0.2s ease; }
         html.dark-mode .modal { background-color: rgba(0, 0, 0, 0.7); }
         .modal.active { visibility: visible; opacity: 1; transition: visibility 0s, opacity 0.2s ease; }
         .modal-content { background-color: var(--modal-bg); border-radius: 0.5rem; padding: 1.5rem; width: 90%; max-width: 450px; box-shadow: var(--shadow-lg); transform: scale(0.9); transition: transform 0.2s ease, background-color 0.2s ease; }
         .modal.active .modal-content { transform: scale(1); }
         .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.8rem; }
         .modal-title { font-weight: 600; font-size: 1.15rem; color: var(--text); }
         .modal-close { background: none; border: none; cursor: pointer; font-size: 1.5rem; color: var(--text-muted); line-height: 1; }
         .modal-close:hover { color: var(--text); }
         /* Styles specific to modal body content */
         .modal-body { margin-bottom: 1rem; font-size: 0.95rem; line-height: 1.5; color: var(--text-muted); }
         .modal-body strong { color: var(--text); font-weight: 600; }
         .modal-footer { display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border); }
         /* Form specific styles (only for node edit modal) */
         .form-group { margin-bottom: 1rem; }
         .form-label { display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; color: var(--text); }
         .form-input, .form-textarea, .form-select, .form-color { width: 100%; padding: 0.75rem; border-radius: 0.375rem; border: 1px solid var(--input-border); font-size: 0.95rem; transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, color 0.2s ease; background-color: var(--input-bg); color: var(--text); }
         .form-input:focus, .form-textarea:focus, .form-select:focus, .form-color:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); }
         .form-textarea { resize: vertical; min-height: 80px; line-height: 1.5; }
         .form-select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem; }
         html.dark-mode .form-select { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E"); }
         .form-color { padding: 0.25rem; height: 40px; cursor: pointer; }

        /* Context Menu (Unchanged) */
         .contextmenu { position: absolute; background-color: var(--modal-bg); border-radius: 0.375rem; box-shadow: var(--shadow-lg); border: 1px solid var(--border); z-index: 15; overflow: hidden; display: none; min-width: 200px; }
         .contextmenu-item { padding: 0.6rem 1rem; cursor: pointer; display: flex; align-items: center; gap: 0.75rem; color: var(--text); font-size: 0.875rem; transition: background-color 0.15s ease, color 0.15s ease; }
         .contextmenu-item i { width: 16px; text-align: center; color: var(--text-muted); transition: color 0.15s ease; }
         .contextmenu-item:hover { background-color: var(--secondary); color: var(--primary); }
         .contextmenu-item:hover i { color: var(--primary); }
         .contextmenu-item.danger:hover { background-color: var(--danger-bg); color: var(--danger-text); }
         html.dark-mode .contextmenu-item.danger:hover { background-color: #450a0a; color: #f87171; }
         .contextmenu-item.danger:hover i { color: var(--danger-text); }
         /* html.dark-mode .contextmenu-item.danger:hover i { color: #f87171; } */ /* Already covered */
         .contextmenu-divider { height: 1px; background-color: var(--border); margin: 0.25rem 0; }
         #change-connector-color-option { display: none; }
         #delete-map-option { display: none; } /* Initially hidden, shown only for map roots in 'all' mode */

        /* Controls (Unchanged) */
        .controls { position: absolute; bottom: 1rem; right: 1rem; display: flex; gap: 0.5rem; background-color: var(--control-bg); backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px); border-radius: 0.5rem; padding: 0.5rem; box-shadow: var(--shadow); z-index: 5; }
        .control-btn { background: none; border: none; cursor: pointer; width: 40px; height: 40px; display: flex; align-items: center; justify-content: center; border-radius: 0.375rem; color: var(--control-icon-color); transition: background-color 0.2s ease, color 0.2s ease; }
        .control-btn:hover { background-color: var(--secondary); color: var(--primary); }
        .control-btn i { font-size: 1.1rem; }

        /* Mini Tooltip (Unchanged) */
         .mini-tooltip { position: relative; }
         .mini-tooltip::after { content: attr(data-tooltip); position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%); background-color: color-mix(in srgb, var(--background) 90%, black); color: var(--text); font-size: 0.75rem; padding: 0.25rem 0.5rem; border-radius: 0.25rem; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s ease 0.1s; margin-bottom: 0.5rem; z-index: 10; box-shadow: var(--shadow); }
         .mini-tooltip:hover::after { opacity: 1; }

        /* Structure Tree Styling (Unchanged) */
         .tree-node { font-size: 0.85rem; padding: 4px 8px; cursor: pointer; border-radius: 4px; transition: background-color 0.15s ease, color 0.15s ease, font-weight 0.15s ease; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; color: var(--text-muted); }
         .tree-node:hover { background-color: var(--tree-hover-bg); color: var(--text); }
         .tree-node.selected { background-color: var(--tree-selected-bg); color: var(--tree-selected-text); font-weight: 600; }
         .tree-children { padding-left: 16px; border-left: 1px solid var(--border); margin-left: 8px; }
         /* Style for map list in sidebar during 'all' mode */
         .map-list-item { font-size: 0.9rem; padding: 6px 8px; cursor: pointer; border-radius: 4px; transition: background-color 0.15s ease, color 0.15s ease; margin-bottom: 3px; color: var(--text); }
         .map-list-item:hover { background-color: var(--tree-hover-bg); }
         .map-list-item i { margin-right: 8px; color: var(--primary); }


         /* Toast Notification (Unchanged) */
          .toast-notification { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100%); background-color: #10b981; color: white; padding: 0.75rem 1.5rem; border-radius: 0.375rem; box-shadow: var(--shadow-lg); z-index: 50; opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease; font-size: 0.9rem; }
          .toast-notification.error { background-color: #ef4444; }
          .toast-notification.show { opacity: 1; transform: translateX(-50%) translateY(0); }
          html.dark-mode .toast-notification { background-color: #059669; color: #f0fdf4; }
          html.dark-mode .toast-notification.error { background-color: #dc2626; color: #fef2f2; }

        /* Hidden Color Input (Unchanged) */
        #connector-color-picker { visibility: hidden; width: 0; height: 0; position: absolute; left: -100px; }

        /* Mobile Adjustments */
        @media (max-width: 768px) {
            :root {
                --sidebar-width: 220px;
                --header-height: auto; /* Allow header to wrap */
                --tabs-height: 40px;
            }
            .header { padding: 0.6rem 1rem; min-height: 60px; }
            .logo { font-size: 1.2rem; }
             .toolbar .btn span { display: none; }
             .toolbar .btn { padding: 0.6rem; }
             .toolbar .btn i { font-size: 1.1rem; margin: 0; }
             .toolbar { gap: 0.3rem; }
             .toolbar { justify-content: flex-end; } /* Align toolbar items right */

            #map-tabs-container { padding: 0.4rem 1rem 0; min-height: var(--tabs-height); }
            .map-tab { padding: 0.4rem 0.8rem; font-size: 0.8rem; }

            /* Adjust container height for mobile */
            .container { height: calc(100vh - var(--header-height) - var(--tabs-height)); }

            #sidebar-toggle { display: inline-flex; } /* Show toggle */
            .sidebar {
                position: absolute;
                top: 0; /* Position relative to container */
                left: 0;
                transform: translateX(-100%);
                height: 100%; /* Full height of container */
                z-index: 15;
                border-right: 1px solid var(--border);
                box-shadow: var(--shadow-lg);
            }
            .sidebar.open { transform: translateX(0); }

            .controls { bottom: 0.8rem; right: 0.8rem; padding: 0.4rem; }
             .control-btn { width: 38px; height: 38px; }
             .mini-tooltip::after { display: none; }

             .modal-content { max-width: 95%; padding: 1rem; }
             .modal-title { font-size: 1.1rem; }
             .modal-footer { margin-top: 1rem; }
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            <i class="fas fa-brain"></i>
            <span>Mind Map</span>
        </div>
        <div class="toolbar">
             <button id="sidebar-toggle" title="Toggle Sidebar"> <i class="fas fa-bars"></i> </button>
             <button id="theme-toggle" title="Toggle Theme"> <i class="fas fa-sun"></i> </button>
             <!-- Auto-Layout Button is added here dynamically by JS -->
             <button id="display-all-btn" class="btn btn-secondary" title="Show All Maps">
                 <i class="fas fa-grip-horizontal"></i>
                 <span>Display All</span>
             </button>
             <button id="new-map-btn" class="btn btn-primary" title="Add New Mind Map">
                 <i class="fas fa-plus"></i>
                 <span>New Map</span>
             </button>
             <button id="save-btn" class="btn btn-secondary" title="Save All to Cloud">
                 <i class="fas fa-cloud-arrow-up"></i>
                 <span>Save All</span>
             </button>
             <button id="load-btn" class="btn btn-secondary" title="Load All from Cloud">
                 <i class="fas fa-cloud-arrow-down"></i>
                 <span>Load All</span>
             </button>
        </div>
    </div>

    <!-- Map Tabs Container -->
    <div id="map-tabs-container">
        <!-- Tabs will be generated here by JS -->
    </div>

    <div class="container">
        <div id="sidebar" class="sidebar">
            <div id="sidebar-title" class="sidebar-title">Mind Map Structure</div>
            <div id="structure-tree">
                <!-- Tree or Map List goes here -->
            </div>
        </div>
        <div class="canvas-container">
            <svg id="connector-svg"></svg>
            <div id="canvas">
                <!-- Nodes go here -->
                 <div id="display-all-message" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: var(--text-muted); font-size: 1.1rem; text-align: center; display: none; z-index: 0;">
                     Click 'New Map' to get started<br>or 'Load All' to retrieve saved maps.
                 </div>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="zoom-in" class="control-btn mini-tooltip" data-tooltip="Zoom In"> <i class="fas fa-search-plus"></i> </button>
        <button id="zoom-out" class="control-btn mini-tooltip" data-tooltip="Zoom Out"> <i class="fas fa-search-minus"></i> </button>
        <button id="center-view" class="control-btn mini-tooltip" data-tooltip="Center View"> <i class="fas fa-compress-arrows-alt"></i> </button>
        <button id="fullscreen-toggle" class="control-btn mini-tooltip" data-tooltip="Toggle Fullscreen"> <i class="fas fa-expand"></i> </button>
    </div>

    <!-- Node Edit Modal (Existing) -->
    <div id="node-modal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Edit Node</h3>
                <button class="modal-close" title="Close">×</button>
            </div>
            <form id="node-form">
                <div class="form-group">
                    <label class="form-label" for="node-title">Title</label>
                    <input type="text" id="node-title" class="form-input" placeholder="Enter node title" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="node-content">Content (Optional)</label>
                    <textarea id="node-content" class="form-textarea" placeholder="Enter node content"></textarea>
                </div>
                <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                    <div class="form-group" style="flex: 1;">
                        <label class="form-label" for="node-color">Node Color</label>
                        <input type="color" id="node-color" class="form-color" value="#ffffff">
                    </div>
                    <div class="form-group" style="flex: 2;">
                        <label class="form-label" for="node-shape">Node Shape</label>
                        <select id="node-shape" class="form-select">
                            <option value="rectangle">Rectangle</option>
                            <option value="rounded-rectangle" selected>Rounded</option>
                            <option value="stadium">Stadium</option>
                            <option value="ellipse">Ellipse</option>
                        </select>
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" id="cancel-node" class="btn btn-secondary">Cancel</button>
                    <button type="submit" id="save-node" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Confirmation Modal (for Map Deletion - Created Dynamically) -->
    <!-- Placeholder: It will be added to the body by JS -->

    <div id="context-menu" class="contextmenu">
        <!-- Options relevant only in single map mode -->
        <div id="add-child-option" class="contextmenu-item"> <i class="fas fa-plus"></i> <span>Add Child Node</span> </div>
        <div id="edit-node-option" class="contextmenu-item"> <i class="fas fa-edit"></i> <span>Edit / Style Node</span> </div>
        <div id="change-connector-color-option" class="contextmenu-item"> <i class="fas fa-palette"></i> <span>Change Connector Color</span> </div>
        <div class="contextmenu-divider" id="single-map-divider"></div>
        <div id="delete-node-option" class="contextmenu-item danger"> <i class="fas fa-trash"></i> <span>Delete Node</span> </div>
        <!-- Options relevant only in display all mode (acting on the root node) -->
        <div id="open-map-option" class="contextmenu-item"> <i class="fas fa-folder-open"></i> <span>Open This Map</span> </div>
        <div class="contextmenu-divider" id="all-maps-divider"></div>
        <div id="delete-map-option" class="contextmenu-item danger"> <i class="fas fa-trash-alt"></i> <span>Delete Entire Map</span> </div>
    </div>

    <input type="color" id="connector-color-picker">
    <!-- Toast Notification Placeholder added dynamically -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- JSONBIN.IO CONFIGURATION ---
        const JSONBIN_API_KEY = ''; // <<< PUT YOUR KEY HERE
        const JSONBIN_BIN_ID = ''; // <<< PUT YOUR BIN ID HERE
        // --- END JSONBIN.IO CONFIGURATION ---

        // --- Theme Helper ---
        const themePrefKey = 'mindMapTheme';
        function applyTheme(theme) {
            const htmlEl = document.documentElement;
            const themeToggleBtn = document.getElementById('theme-toggle');
            const icon = themeToggleBtn?.querySelector('i');

            if (theme === 'dark') {
                htmlEl.classList.add('dark-mode');
                if (icon) icon.className = 'fas fa-moon';
                 if (themeToggleBtn) themeToggleBtn.title = 'Switch to Light Mode';
            } else {
                htmlEl.classList.remove('dark-mode');
                if (icon) icon.className = 'fas fa-sun';
                 if (themeToggleBtn) themeToggleBtn.title = 'Switch to Dark Mode';
            }
             // Ensure node styles update if default bg changes
            if (window.mindMapInstance) {
                window.mindMapInstance.applyCurrentStylesToAllNodes();
                window.mindMapInstance.updateConnections(); // Also redraw connectors
                 // Update confirmation modal style if it exists
                window.mindMapInstance.updateConfirmationModalStyle();
            }
        }
        function getInitialTheme() {
            const savedTheme = localStorage.getItem(themePrefKey);
            if (savedTheme) return savedTheme;
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) return 'dark';
            return 'light';
        }
        applyTheme(getInitialTheme());
        // --- End Theme Helper ---


        class MindMap {
            constructor() {
                // --- State ---
                this.allMapsData = { maps: {}, meta: { theme: getInitialTheme(), displayMode: 'single', activeMapId: null } };
                this.currentMapId = null; // ID of the map being edited/viewed in single mode
                this.displayMode = 'single'; // 'single' or 'all'
                this.selectedNodeId = null; // ID of the node selected within the current map
                this.editingNodeId = null; // ID of the node being edited in the node modal
                this.contextMenuNodeId = null; // Node ID context menu was opened on
                this.contextMenuMapId = null; // Map ID context menu was opened on (for 'all' mode)
                this.mapIdToDelete = null; // Temp store map ID for delete confirmation

                // Canvas Interaction State
                this.scale = 1;
                this.minScale = 0.1;
                this.maxScale = 3;
                this.offset = { x: 0, y: 0 };
                this.dragStart = { x: 0, y: 0 };
                this.isPanning = false;
                this.isMovingNode = false; // Only in 'single' mode
                this.nodeStartPos = { x: 0, y: 0 };
                this.isTouch = false;
                this.longPressTimeout = null;

                // Other State
                this.currentTheme = getInitialTheme();
                this.isFullscreen = !!document.fullscreenElement;
                this.isLoading = false;
                this.branchColors = [
                    '#fb7185', '#fdba74', '#d9f99d', '#a7f3d0', '#a5f3fc',
                    '#c7d2fe', '#fbcfe8', '#fca5a5', '#fed7aa', '#bef264',
                    '#86efac', '#67e8f9', '#a78bfa', '#f9a8d4'
                ];
                // Layout constants
                this.treeLayoutHorizontalSpacing = 220;
                this.treeLayoutVerticalSpacing = 30;
                this.nodeHeightEstimate = 80; // Used in layout calculation

                // DOM Elements
                this.htmlEl = document.documentElement;
                this.bodyEl = document.body;
                this.toolbar = document.querySelector('.toolbar'); // Target toolbar for adding buttons
                this.container = document.querySelector('.container');
                this.sidebar = document.getElementById('sidebar');
                this.sidebarTitle = document.getElementById('sidebar-title');
                this.sidebarToggle = document.getElementById('sidebar-toggle');
                this.canvasContainer = document.querySelector('.canvas-container');
                this.canvas = document.getElementById('canvas');
                this.displayAllMessage = document.getElementById('display-all-message');
                this.connectorSvg = document.getElementById('connector-svg');
                this.mapTabsContainer = document.getElementById('map-tabs-container');
                // Node Edit Modal Elements
                this.nodeModal = document.getElementById('node-modal');
                this.nodeForm = document.getElementById('node-form');
                this.nodeModalTitle = this.nodeModal.querySelector('.modal-title');
                this.nodeTitleInput = document.getElementById('node-title');
                this.nodeContentInput = document.getElementById('node-content');
                this.nodeColorInput = document.getElementById('node-color');
                this.nodeShapeSelect = document.getElementById('node-shape');
                this.saveNodeBtn = document.getElementById('save-node');
                this.cancelNodeBtn = document.getElementById('cancel-node');
                this.nodeModalCloseBtn = this.nodeModal.querySelector('.modal-close');
                // Confirmation Modal Elements (will be created dynamically)
                this.confirmModal = null;
                this.confirmModalTitle = null;
                this.confirmModalBody = null;
                this.confirmModalCancelBtn = null;
                this.confirmModalConfirmBtn = null;
                this.confirmModalCloseBtn = null;
                // Toolbar Buttons
                this.newMapBtn = document.getElementById('new-map-btn');
                this.displayAllBtn = document.getElementById('display-all-btn');
                this.saveBtn = document.getElementById('save-btn');
                this.loadBtn = document.getElementById('load-btn');
                this.themeToggleBtn = document.getElementById('theme-toggle');
                this.autoLayoutBtn = null; // Will be created dynamically
                // Context Menu
                this.contextMenu = document.getElementById('context-menu');
                this.addChildOption = document.getElementById('add-child-option');
                this.editNodeOption = document.getElementById('edit-node-option');
                this.changeConnectorColorOption = document.getElementById('change-connector-color-option');
                this.deleteNodeOption = document.getElementById('delete-node-option');
                this.openMapOption = document.getElementById('open-map-option');
                this.deleteMapOption = document.getElementById('delete-map-option');
                this.singleMapDivider = document.getElementById('single-map-divider');
                this.allMapsDivider = document.getElementById('all-maps-divider');
                // Other
                this.connectorColorPicker = document.getElementById('connector-color-picker');
                this.zoomInBtn = document.getElementById('zoom-in');
                this.zoomOutBtn = document.getElementById('zoom-out');
                this.centerViewBtn = document.getElementById('center-view');
                this.fullscreenToggleBtn = document.getElementById('fullscreen-toggle');
                this.structureTree = document.getElementById('structure-tree');

                // Temporary state derived from currentMapData (used in single mode)
                this.nodes = []; // Nodes of the current map
                this.connections = []; // Connections of the current map
                this.rootNodeMap = new Map(); // Root map for the current map
                this.nodeElementCache = new Map(); // Cache node elements for layout

                this.init();
            }

            // --- Initialization & Setup ---
            async init() {
                console.log("MindMap Initializing...");
                this.createAutoLayoutButton(); // Create and add the layout button
                this.createConfirmationModal(); // Create the confirmation modal structure
                this.setupEventListeners();
                this.updateFullscreenIcon();
                applyTheme(this.currentTheme); // Apply initial theme

                console.log("Attempting to load data from cloud...");
                const loaded = await this.loadFromCloud();

                if (!loaded || Object.keys(this.allMapsData.maps).length === 0) {
                    // Handle empty/failed load state
                     if (!loaded) console.log("No valid data from cloud or load failed.");
                     if (Object.keys(this.allMapsData.maps).length === 0) console.log("No maps found. Starting fresh or showing 'Display All' empty state.");
                     if (!this.allMapsData.maps) this.allMapsData.maps = {};
                     if (!this.allMapsData.meta) this.allMapsData.meta = { theme: getInitialTheme(), displayMode: 'all', activeMapId: null };
                     this.currentMapId = null;
                     this.displayMode = 'all';
                     this.allMapsData.meta.displayMode = 'all';
                     this.allMapsData.meta.activeMapId = null;
                } else {
                     // Restore state from loaded data
                     console.log(`Successfully loaded ${Object.keys(this.allMapsData.maps).length} maps from cloud.`);
                     this.currentTheme = this.allMapsData.meta.theme || getInitialTheme();
                     this.displayMode = this.allMapsData.meta.displayMode || 'single';
                     this.currentMapId = this.allMapsData.meta.activeMapId || null;

                     if (this.currentMapId && !this.allMapsData.maps[this.currentMapId]) {
                         console.warn(`Saved activeMapId ${this.currentMapId} not found. Resetting.`);
                         this.currentMapId = null;
                         this.displayMode = 'all';
                         this.allMapsData.meta.activeMapId = null;
                         this.allMapsData.meta.displayMode = 'all';
                     }
                     if (!this.currentMapId && Object.keys(this.allMapsData.maps).length > 0) {
                         this.displayMode = 'all';
                         this.allMapsData.meta.displayMode = 'all';
                     }
                }

                applyTheme(this.currentTheme); // Apply potentially loaded theme
                this.renderTabs(); // Render tabs based on loaded maps

                // Initial Render based on state
                if (this.displayMode === 'single' && this.currentMapId) {
                    this.renderSingleMap(this.currentMapId, true);
                } else {
                    this.renderDisplayAll();
                }

                this.updateAutoLayoutButtonState(); // Set initial state of layout button
                console.log(`Initialization complete. Mode: ${this.displayMode}, Active Map: ${this.currentMapId}`);
            }

            createAutoLayoutButton() {
                this.autoLayoutBtn = document.createElement('button');
                this.autoLayoutBtn.id = 'auto-layout-btn';
                this.autoLayoutBtn.className = 'btn btn-secondary';
                this.autoLayoutBtn.title = 'Auto-Arrange Map (Tree)';
                this.autoLayoutBtn.innerHTML = '<i class="fas fa-sitemap"></i><span>Arrange</span>';
                this.autoLayoutBtn.disabled = true; // Initially disabled

                // Insert it before the 'Display All' button
                const displayAllButton = document.getElementById('display-all-btn');
                if (this.toolbar && displayAllButton) {
                     this.toolbar.insertBefore(this.autoLayoutBtn, displayAllButton);
                 } else if (this.toolbar) {
                     this.toolbar.appendChild(this.autoLayoutBtn); // Fallback: append if ref not found
                 }
            }

            setupEventListeners() {
                // Canvas Interaction (Mouse & Touch)
                this.canvasContainer.addEventListener('mousedown', this.handleInteractionStart.bind(this), false);
                document.addEventListener('mousemove', this.handleInteractionMove.bind(this), false);
                document.addEventListener('mouseup', this.handleInteractionEnd.bind(this), false);
                document.addEventListener('mouseleave', this.handleInteractionLeave.bind(this), false);
                this.canvasContainer.addEventListener('touchstart', this.handleInteractionStart.bind(this), { passive: false });
                this.canvasContainer.addEventListener('touchmove', this.handleInteractionMove.bind(this), { passive: false });
                this.canvasContainer.addEventListener('touchend', this.handleInteractionEnd.bind(this), false);
                this.canvasContainer.addEventListener('touchcancel', this.handleInteractionEnd.bind(this), false);

                // Context Menu Trigger
                this.canvasContainer.addEventListener('contextmenu', e => {
                    e.preventDefault();
                    if (!this.isTouch) {
                        this.handleContextMenu(e);
                    }
                });

                // Node Edit Modal Form Submission
                 this.nodeForm.addEventListener('submit', (e) => {
                     e.preventDefault();
                     if (this.displayMode !== 'single' || !this.currentMapId) return;
                     const title = this.nodeTitleInput.value.trim(); if (!title) return;
                     this.saveNodeEdit(); // Use dedicated function
                 });

                // Node Edit Modal Buttons
                this.cancelNodeBtn.addEventListener('click', () => this.closeNodeModal());
                this.nodeModalCloseBtn.addEventListener('click', () => this.closeNodeModal());

                // Confirmation Modal Buttons (listeners added when shown)

                // Toolbar Buttons
                this.newMapBtn.addEventListener('click', () => this.addNewMap());
                this.displayAllBtn.addEventListener('click', () => this.renderDisplayAll());
                this.saveBtn.addEventListener('click', () => this.saveToCloud());
                this.loadBtn.addEventListener('click', async () => {
                     if (confirm("Loading will overwrite any unsaved changes. Continue?")) { // Standard confirm is okay here
                         await this.loadFromCloud();
                         // Re-render based on loaded state
                         if (this.allMapsData.meta.displayMode === 'single' && this.allMapsData.meta.activeMapId && this.allMapsData.maps[this.allMapsData.meta.activeMapId]) {
                             this.renderSingleMap(this.allMapsData.meta.activeMapId, true);
                         } else if (Object.keys(this.allMapsData.maps).length > 0) {
                              this.renderDisplayAll(true);
                         } else {
                             this.renderDisplayAll();
                         }
                          this.updateAutoLayoutButtonState(); // Update button state after load
                     }
                });
                this.sidebarToggle.addEventListener('click', () => this.toggleSidebar());
                this.themeToggleBtn.addEventListener('click', () => this.toggleTheme());
                // Add listener for the dynamically created Auto-Layout button
                this.autoLayoutBtn.addEventListener('click', () => this.applyAutoLayout());

                // Context Menu Options
                this.setupContextMenuListeners();

                // Connector Color Picker
                this.connectorColorPicker.addEventListener('change', (e) => this.handleConnectorColorChange(e.target.value));

                // Controls
                this.zoomInBtn.addEventListener('click', () => this.zoom(1.25));
                this.zoomOutBtn.addEventListener('click', () => this.zoom(0.8));
                this.centerViewBtn.addEventListener('click', () => this.centerView(true));
                this.fullscreenToggleBtn.addEventListener('click', () => this.toggleFullscreen());
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());

                // Global Click/Tap Listener
                document.addEventListener('click', (e) => {
                    if (!this.contextMenu.contains(e.target)) this.closeContextMenu();
                    if (e.target === this.nodeModal) this.closeNodeModal();
                    if (e.target === this.confirmModal) this.closeConfirmationModal(); // Close confirm modal on backdrop click
                    if (window.innerWidth <= 768 && this.sidebar.classList.contains('open') && !this.sidebar.contains(e.target) && !this.sidebarToggle.contains(e.target)) {
                        this.toggleSidebar(false);
                    }
                    // Handle clicks on tabs
                    const tab = e.target.closest('.map-tab');
                    if (tab && tab.dataset.mapId) {
                        this.switchToMap(tab.dataset.mapId);
                    }
                }, true);

                // Wheel Zoom
                this.canvasContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9;
                    const rect = this.canvasContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    this.zoomAtPoint(zoomFactor, mouseX, mouseY);
                }, { passive: false });

                // Keyboard Shortcuts
                document.addEventListener('keydown', (e) => {
                    // Ignore shortcuts if any modal is active
                    if (this.nodeModal.classList.contains('active') || this.confirmModal?.classList.contains('active')) return;

                    // Delete Node (single mode)
                    if ((e.key === 'Delete' || e.key === 'Backspace') && this.displayMode === 'single' && this.currentMapId) {
                        if (this.selectedNodeId !== null && (document.activeElement === this.bodyEl || this.canvasContainer.contains(document.activeElement))) {
                             e.preventDefault();
                             const nodeToDelete = this.getNodeById(this.selectedNodeId);
                             const mapData = this.getCurrentMapData();
                             if (nodeToDelete && mapData && nodeToDelete.id !== mapData.rootNodeId) {
                                 this.showDeleteNodeConfirmation(this.selectedNodeId); // Use confirmation for node delete too? Maybe later. For now direct.
                                 if (confirm(`Delete node "${nodeToDelete.title}" and all its children?`)) { // Standard confirm for node delete ok for now
                                     this.deleteNodeAndDescendants(this.selectedNodeId);
                                 }
                             } else if (nodeToDelete && mapData && nodeToDelete.id === mapData.rootNodeId) {
                                  this.showToast("Cannot delete the root node directly. Delete the map instead.", true);
                             }
                        }
                    }
                    // Escape
                    if (e.key === 'Escape') {
                         this.closeContextMenu();
                         this.closeNodeModal();
                         this.closeConfirmationModal();
                         this.deselectNode();
                         if (this.isFullscreen) document.exitFullscreen().catch(err => console.error("Error exiting fullscreen:", err));
                    }
                    // Ctrl+S for Cloud Save
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') { e.preventDefault(); this.saveToCloud(); }
                    // Ctrl+O for Cloud Load
                    if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                         e.preventDefault();
                         this.loadBtn.click(); // Trigger the load button's logic (including confirm)
                    }
                    // Ctrl+N for New Map
                    if ((e.ctrlKey || e.metaKey) && e.key === 'n') { e.preventDefault(); this.newMapBtn.click(); }
                });

                 window.addEventListener('resize', () => this.centerView());
                 window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                     if (!localStorage.getItem(themePrefKey)) {
                         const newTheme = e.matches ? 'dark' : 'light';
                         this.currentTheme = newTheme;
                         this.allMapsData.meta.theme = newTheme;
                         applyTheme(newTheme);
                     }
                 });
            }

            setupContextMenuListeners() {
                 // --- Single Map Node Context ---
                 this.addChildOption.addEventListener('click', () => this.handleAddChildNode());
                 this.editNodeOption.addEventListener('click', () => this.handleEditNode());
                 this.changeConnectorColorOption.addEventListener('click', () => this.handleChangeConnectorColor());
                 this.deleteNodeOption.addEventListener('click', () => this.handleDeleteNode());

                 // --- All Maps Root Node Context ---
                 this.openMapOption.addEventListener('click', () => this.handleOpenMap());
                 this.deleteMapOption.addEventListener('click', () => this.handleDeleteMap()); // This now triggers the confirmation modal
            }

            // --- Context Menu Action Handlers ---
            handleAddChildNode() {
                 if (this.displayMode !== 'single' || this.contextMenuNodeId === null) return;
                 this.editingNodeId = null; // Adding, not editing
                 this.nodeModalTitle.textContent = 'Add Child Node';
                 const parentNode = this.getNodeById(this.contextMenuNodeId);
                 const defaultColor = parentNode?.color || this.getDefaultNodeColor();
                 this.nodeColorInput.value = defaultColor;
                 this.nodeShapeSelect.value = parentNode?.shape || 'rounded-rectangle';
                 this.nodeTitleInput.value = ''; this.nodeContentInput.value = '';
                 this.openNodeModal();
                 this.closeContextMenu();
             }

            handleEditNode() {
                 if (this.displayMode !== 'single' || this.contextMenuNodeId === null) return;
                 const node = this.getNodeById(this.contextMenuNodeId);
                 if (node) {
                     this.editingNodeId = this.contextMenuNodeId;
                     this.nodeModalTitle.textContent = 'Edit / Style Node';
                     this.nodeTitleInput.value = node.title;
                     this.nodeContentInput.value = node.content;
                     this.nodeColorInput.value = node.color || this.getDefaultNodeColor();
                     this.nodeShapeSelect.value = node.shape || 'rounded-rectangle';
                     this.openNodeModal();
                 }
                 this.closeContextMenu();
             }

            handleChangeConnectorColor() {
                 if (this.displayMode !== 'single' || this.contextMenuNodeId === null) return;
                 this.connectorColorPicker.click(); // Open the native color picker
                 // The actual color change is handled by the picker's 'change' event listener
                 this.closeContextMenu(); // Close menu immediately
             }

            handleConnectorColorChange(newColor) {
                if (this.displayMode !== 'single' || this.contextMenuNodeId === null) return;
                 const mapData = this.getCurrentMapData();
                 const node = this.getNodeById(this.contextMenuNodeId);
                 if (mapData && node && node.parentId !== null) {
                     const connection = this.connections.find(c => c.from === node.parentId && c.to === node.id);
                     if (connection) {
                         connection.color = newColor;
                         this.updateConnections(); // Redraw with new color
                     } else { console.warn("Could not find connection for color change."); }
                 }
                 // No need to clear contextMenuNodeId here, it wasn't used by the picker directly
            }

            handleDeleteNode() {
                 if (this.displayMode !== 'single' || this.contextMenuNodeId === null) return;
                 const nodeToDelete = this.getNodeById(this.contextMenuNodeId);
                 const mapData = this.getCurrentMapData();
                 if (nodeToDelete && mapData) {
                     if (nodeToDelete.id === mapData.rootNodeId) {
                         this.showToast("Cannot delete the root node. Delete the entire map instead.", true);
                     } else if (confirm(`Delete node "${nodeToDelete.title}" and all its children?`)) { // Standard confirm ok for nodes
                         this.deleteNodeAndDescendants(this.contextMenuNodeId);
                     }
                 }
                 this.closeContextMenu();
             }

            handleOpenMap() {
                if (this.displayMode !== 'all' || this.contextMenuMapId === null) return;
                this.switchToMap(this.contextMenuMapId);
                this.closeContextMenu();
            }

            handleDeleteMap() {
                if (this.displayMode !== 'all' || this.contextMenuMapId === null) {
                    this.closeContextMenu();
                    return;
                }
                const mapIdToDelete = this.contextMenuMapId;
                const mapData = this.allMapsData.maps[mapIdToDelete];
                const mapNameToConfirm = mapData?.name || 'Untitled Map';

                // Show the custom confirmation modal instead of confirm()
                this.showDeleteMapConfirmation(mapIdToDelete, mapNameToConfirm);
                this.closeContextMenu();
            }

            // --- Interaction Handlers ---
            handleInteractionStart(e) {
                this.isTouch = e.type.startsWith('touch');
                if (this.isTouch) e.preventDefault();

                this.closeContextMenu();
                const interactionPos = this.getInteractionPosition(e);
                this.dragStart = { x: interactionPos.clientX, y: interactionPos.clientY };
                const targetElement = document.elementFromPoint(interactionPos.clientX, interactionPos.clientY);
                const targetNodeElement = targetElement ? targetElement.closest('.node') : null;

                // Long Press for Context Menu (Touch)
                if (this.isTouch) {
                    if(this.longPressTimeout) clearTimeout(this.longPressTimeout);
                    this.longPressTimeout = setTimeout(() => {
                        if (targetNodeElement) { // Use the element found at the start
                            this.handleContextMenu({ clientX: this.dragStart.x, clientY: this.dragStart.y }); // Pass start coords
                        }
                        this.longPressTimeout = null;
                    }, 700);
                }

                // Click/Drag Logic
                if (targetNodeElement) {
                    e.stopPropagation(); // Prevent canvas panning if node is hit

                    if (this.displayMode === 'single' && this.currentMapId) {
                        const nodeId = parseInt(targetNodeElement.dataset.id);
                        this.selectNode(nodeId);
                        this.isMovingNode = true;
                        this.isPanning = false;
                        const node = this.getNodeById(nodeId);
                        this.nodeStartPos = { x: node?.x || 0, y: node?.y || 0 };
                        this.canvas.style.cursor = 'grabbing';
                        document.body.style.cursor = 'grabbing';
                    } else if (this.displayMode === 'all') {
                        // Click on a root node in 'all' mode should switch to that map
                        const mapId = targetNodeElement.dataset.mapId;
                        if (mapId) {
                           setTimeout(() => {
                               if (!this.isPanning && !this.longPressTimeout) {
                                   this.switchToMap(mapId);
                               }
                           }, 50);
                        }
                        this.isPanning = true;
                        this.isMovingNode = false;
                        this.canvas.classList.add('grabbing');
                        document.body.style.cursor = 'grabbing';
                    }
                } else if (targetElement && (targetElement.closest('.controls') || targetElement.closest('.header') || targetElement.closest('.sidebar') || targetElement.closest('#map-tabs-container'))) {
                    this.isPanning = false;
                    this.isMovingNode = false;
                } else {
                    // Click on empty canvas: Start Panning
                    this.isPanning = true;
                    this.isMovingNode = false;
                    this.canvas.classList.add('grabbing');
                    document.body.style.cursor = 'grabbing';
                    if (this.displayMode === 'single') {
                         this.deselectNode();
                    }
                }
            }

            handleInteractionMove(e) {
                if (!this.isPanning && !this.isMovingNode) return;
                if (this.isTouch) e.preventDefault();

                const interactionPos = this.getInteractionPosition(e);
                const dx = interactionPos.clientX - this.dragStart.x;
                const dy = interactionPos.clientY - this.dragStart.y;

                if (this.longPressTimeout && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                    clearTimeout(this.longPressTimeout);
                    this.longPressTimeout = null;
                }

                if (this.isMovingNode && this.displayMode === 'single' && this.selectedNodeId !== null) {
                    const node = this.getNodeById(this.selectedNodeId);
                    if (node) {
                        const deltaX = dx / this.scale;
                        const deltaY = dy / this.scale;
                        node.x = this.nodeStartPos.x + deltaX;
                        node.y = this.nodeStartPos.y + deltaY;
                        this.updateNodeElementPosition(node);
                        this.updateConnections(); // Update connections during drag
                    }
                } else if (this.isPanning) {
                    this.offset.x += dx;
                    this.offset.y += dy;
                    this.dragStart = { x: interactionPos.clientX, y: interactionPos.clientY };
                    this.updateCanvasTransform();
                }
            }

            handleInteractionEnd(e) {
                if (this.longPressTimeout) {
                    clearTimeout(this.longPressTimeout);
                    this.longPressTimeout = null;
                }
                if (this.isMovingNode) {
                    this.isMovingNode = false;
                    this.canvas.style.cursor = 'grab';
                    document.body.style.cursor = 'default';
                    // Consider if auto-save is desired after node move
                }
                if (this.isPanning) {
                    this.isPanning = false;
                    this.canvas.classList.remove('grabbing');
                    document.body.style.cursor = 'default';
                    // Consider if auto-save is desired after panning
                }
            }

            handleInteractionLeave(e) {
                 if (!this.isTouch && (this.isMovingNode || this.isPanning)) {
                     this.handleInteractionEnd(e);
                 }
            }

            getInteractionPosition(e) {
                if (e.touches && e.touches.length > 0) return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
                if (e.changedTouches && e.changedTouches.length > 0) return { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY };
                return { clientX: e.clientX, clientY: e.clientY };
            }

            handleContextMenu(eOrPos) {
                let clientX, clientY;
                if (eOrPos instanceof Event) { clientX = eOrPos.clientX; clientY = eOrPos.clientY; }
                else if (eOrPos && typeof eOrPos.clientX === 'number') { clientX = eOrPos.clientX; clientY = eOrPos.clientY; }
                else { console.error("Invalid context menu event/position:", eOrPos); return; }

                const targetElement = document.elementFromPoint(clientX, clientY);
                const targetNodeElement = targetElement ? targetElement.closest('.node') : null;

                this.contextMenuNodeId = null; // Reset node/map context
                this.contextMenuMapId = null;

                if (targetNodeElement) {
                    if (this.displayMode === 'single' && this.currentMapId) {
                        const nodeId = parseInt(targetNodeElement.dataset.id);
                        const node = this.getNodeById(nodeId);
                        if (node) {
                             this.selectNode(nodeId);
                             this.contextMenuNodeId = nodeId;
                             this.showContextMenu(clientX, clientY, 'single');
                        }
                    } else if (this.displayMode === 'all') {
                        const mapId = targetNodeElement.dataset.mapId;
                        if (mapId && this.allMapsData.maps[mapId]) {
                            this.contextMenuMapId = mapId;
                            this.showContextMenu(clientX, clientY, 'all');
                        }
                    }
                } else {
                    this.closeContextMenu();
                    if (this.displayMode === 'single') this.deselectNode();
                }
            }

            toggleSidebar(forceState) {
                 const isOpen = this.sidebar.classList.contains('open');
                 const shouldOpen = typeof forceState === 'boolean' ? forceState : !isOpen;
                 this.sidebar.classList.toggle('open', shouldOpen);
            }

            // --- Rendering ---

            renderTabs() {
                this.mapTabsContainer.innerHTML = '';
                const mapEntries = Object.entries(this.allMapsData.maps);
                mapEntries.sort(([, mapA], [, mapB]) => (mapA.name || 'Untitled').localeCompare(mapB.name || 'Untitled'));

                mapEntries.forEach(([mapId, mapData]) => {
                    const tab = document.createElement('div');
                    tab.className = 'map-tab';
                    tab.dataset.mapId = mapId;
                    tab.textContent = mapData.name || 'Untitled Map';
                    tab.title = mapData.name || 'Untitled Map';
                    if (mapId === this.currentMapId && this.displayMode === 'single') {
                        tab.classList.add('active');
                    }
                    this.mapTabsContainer.appendChild(tab);
                });
                 const activeTab = this.mapTabsContainer.querySelector('.map-tab.active');
                 if (activeTab) {
                     activeTab.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
                 }
            }

            renderDisplayAll(center = false) {
                console.log("Rendering Display All mode...");
                this.displayMode = 'all';
                this.currentMapId = null;
                this.selectedNodeId = null;
                this.allMapsData.meta.displayMode = 'all';
                this.allMapsData.meta.activeMapId = null;

                this.clearCanvasAndSidebar();
                this.renderTabs(); // Update tab state
                this.updateAutoLayoutButtonState(); // Disable layout button

                const mapIds = Object.keys(this.allMapsData.maps);
                if (mapIds.length === 0) {
                    this.displayAllMessage.style.display = 'block';
                    this.sidebarTitle.textContent = "No Maps";
                    this.structureTree.innerHTML = '<p style="color: var(--text-muted); font-style: italic;">Create or load a mind map.</p>';
                    return;
                } else {
                    this.displayAllMessage.style.display = 'none';
                }

                this.sidebarTitle.textContent = "All Maps";
                this.renderMapListSidebar();

                // Basic Layout for Root Nodes
                const padding = 80;
                const nodeWidthEstimate = 180;
                const nodeHeightEstimate = 80;
                const containerWidth = this.canvasContainer.offsetWidth;
                const nodesPerRow = Math.max(1, Math.floor((containerWidth - padding * 2) / (nodeWidthEstimate + padding)));
                let currentX = padding; let currentY = padding; let countInRow = 0;
                const fragment = document.createDocumentFragment();

                mapIds.forEach(mapId => {
                    const mapData = this.allMapsData.maps[mapId];
                    if (!mapData || !mapData.rootNodeId || !mapData.nodes) return;
                    const rootNodeData = mapData.nodes.find(n => n.id === mapData.rootNodeId);
                    if (!rootNodeData) return;

                    const displayNodeData = { ...rootNodeData, title: mapData.name || 'Untitled Map', content: `${mapData.nodes.length} nodes`};
                    const nodeElement = this.createNodeElement(displayNodeData);
                    nodeElement.classList.add('display-all-root');
                    nodeElement.dataset.mapId = mapId;
                    nodeElement.style.transform = `translate(${currentX}px, ${currentY}px) scale(0.9)`;
                    this.applyNodeStyle(rootNodeData, nodeElement); // Apply original node style
                    fragment.appendChild(nodeElement);

                    countInRow++;
                    if (countInRow >= nodesPerRow) {
                        countInRow = 0; currentX = padding; currentY += nodeHeightEstimate + padding;
                    } else {
                        currentX += nodeWidthEstimate + padding;
                    }
                });

                this.canvas.appendChild(fragment);

                if (center) {
                     requestAnimationFrame(() => this.centerView(true));
                } else {
                    this.scale = 1; this.offset = { x: 0, y: 0 };
                    this.updateCanvasTransform();
                    requestAnimationFrame(() => this.centerView(true)); // Center initially
                }
            }

            renderSingleMap(mapId, initialLoad = false) {
                const mapData = this.allMapsData.maps[mapId];
                if (!mapData) {
                    console.error(`Map data not found for ID: ${mapId}. Switching to Display All.`);
                    this.renderDisplayAll(); return;
                }
                console.log(`Rendering Single Map mode: ${mapId} (${mapData.name || 'Untitled'})`);

                this.displayMode = 'single';
                this.currentMapId = mapId;
                this.selectedNodeId = null;
                this.allMapsData.meta.displayMode = 'single';
                this.allMapsData.meta.activeMapId = mapId;

                // Assign map data to local state FIRST
                this.nodes = mapData.nodes || [];
                this.connections = mapData.connections || [];
                mapData.nextId = mapData.nextId || (this.nodes.length > 0 ? Math.max(...this.nodes.map(n => n.id), 0) + 1 : 1);

                this.clearCanvasAndSidebar(); // Clears canvas, sidebar, node cache etc.
                this.renderTabs(); // Update tabs state

                this.sidebarTitle.textContent = `Structure: ${this.escapeHtml(mapData.name) || 'Untitled'}`;
                this.displayAllMessage.style.display = 'none';

                // Handle empty map AFTER assigning this.nodes
                if (this.nodes.length === 0) {
                    console.warn(`Map ${mapId} has no nodes. Creating a default root.`);
                    this.createInitialNodeForMap(mapId);
                    // Re-assign local state after creating the node
                    this.nodes = mapData.nodes;
                    this.connections = mapData.connections;
                }

                // Create Node DOM Elements AFTER handling potential initial node creation
                const fragment = document.createDocumentFragment();
                this.nodeElementCache.clear(); // Ensure cache is clear before populating
                this.nodes.forEach(nodeData => {
                    const nodeElement = this.createNodeElement(nodeData);
                    this.applyNodeStyle(nodeData, nodeElement);
                    this.updateNodeElementPosition(nodeData, nodeElement);
                    fragment.appendChild(nodeElement);
                    this.nodeElementCache.set(nodeData.id, nodeElement); // Cache element
                });
                this.canvas.appendChild(fragment);

                // Post-render updates
                this.buildRootNodeMap();
                this.updateConnections();
                this.updateStructureTree();

                // --- MOVED THIS CALL HERE ---
                // Update button state AFTER nodes are definitely processed and populated
                this.updateAutoLayoutButtonState();
                // --- END MOVE ---

                // Restore view or center
                if (initialLoad && mapData.lastSavedView && mapData.lastSavedView.offset) {
                    this.offset = mapData.lastSavedView.offset;
                    this.scale = mapData.lastSavedView.scale || 1;
                    this.updateCanvasTransform();
                    console.log(`Restored saved view for map ${mapId}`);
                } else {
                    // Use requestAnimationFrame to ensure layout is stable before centering
                    requestAnimationFrame(() => this.centerView(true));
                }
            }

             switchToMap(mapId) {
                 if ((this.displayMode === 'single' && this.currentMapId === mapId) || this.isLoading) {
                     return;
                 }
                 console.log(`Switching to map: ${mapId}`);
                 this.renderSingleMap(mapId);
            }

            clearCanvasAndSidebar() {
                 this.canvas.innerHTML = '';
                 this.connectorSvg.innerHTML = '';
                 this.structureTree.innerHTML = '';
                 this.selectedNodeId = null;
                 this.contextMenuNodeId = null;
                 this.contextMenuMapId = null;
                 this.nodes = [];
                 this.connections = [];
                 this.rootNodeMap.clear();
                 this.nodeElementCache.clear(); // Clear node element cache
                  this.displayAllMessage.style.display = 'none';
            }

            renderMapListSidebar() {
                this.structureTree.innerHTML = '';
                const mapEntries = Object.entries(this.allMapsData.maps);
                mapEntries.sort(([, mapA], [, mapB]) => (mapA.name || 'Untitled').localeCompare(mapB.name || 'Untitled'));

                if (mapEntries.length === 0) {
                     this.structureTree.innerHTML = '<p style="color: var(--text-muted); font-style: italic;">No maps available.</p>';
                     return;
                }

                mapEntries.forEach(([mapId, mapData]) => {
                    const item = document.createElement('div');
                    item.className = 'map-list-item';
                    item.textContent = mapData.name || 'Untitled Map';
                    item.title = `Click to open "${mapData.name || 'Untitled Map'}"`;
                    item.dataset.mapId = mapId;
                    item.innerHTML = `<i class="fas fa-project-diagram"></i> ${this.escapeHtml(item.textContent)}`; // Add icon and escape text

                    item.addEventListener('click', () => {
                        this.switchToMap(mapId);
                        if (window.innerWidth <= 768 && this.sidebar.classList.contains('open')) {
                             this.toggleSidebar(false);
                        }
                    });
                    this.structureTree.appendChild(item);
                });
            }


            // --- Map & Node Management ---

            addNewMap() {
                 if (this.isLoading) return;
                 const newMapId = `map_${Date.now()}_${Math.random().toString(36).substring(2, 7)}`;
                 const mapName = `Untitled Map ${Object.keys(this.allMapsData.maps).length + 1}`;
                 console.log(`Creating new map: ${newMapId} - ${mapName}`);

                 this.allMapsData.maps[newMapId] = {
                     name: mapName, nodes: [], connections: [], nextId: 1,
                     rootNodeId: null, lastSavedView: null
                 };

                 this.createInitialNodeForMap(newMapId);
                 this.renderTabs();
                 this.switchToMap(newMapId); // Switches view and enables layout button
                 // Consider auto-save? this.saveToCloud();
            }

             createInitialNodeForMap(mapId) {
                 const mapData = this.allMapsData.maps[mapId];
                 if (!mapData || mapData.nodes.length > 0) return;

                 const nodeId = 1;
                 const initialNode = {
                     id: nodeId, title: mapData.name || 'Main Topic',
                     content: 'Start adding ideas!', x: 0, y: 0, parentId: null,
                     color: this.getDefaultNodeColor(), shape: 'rounded-rectangle'
                 };
                 mapData.nodes.push(initialNode);
                 mapData.rootNodeId = nodeId;
                 mapData.nextId = nodeId + 1;
                 console.log(`Created initial node ${nodeId} for map ${mapId}`);
             }

            getNextId() {
                 if (this.displayMode !== 'single' || !this.currentMapId) {
                     console.error("Cannot get next ID without an active single map."); return Date.now();
                 }
                 const mapData = this.getCurrentMapData();
                 if (!mapData) return Date.now();
                 mapData.nextId = (mapData.nextId || 1);
                 return mapData.nextId++;
            }

            getNodeById(id) {
                 if (this.displayMode !== 'single') return null;
                 return this.nodes.find(n => n.id === id);
            }

            getNodeElement(nodeId) {
                 // Use cache first for performance, especially during layout
                 if (this.displayMode === 'single' && this.nodeElementCache.has(nodeId)) {
                     return this.nodeElementCache.get(nodeId);
                 }
                 // Fallback to query selector (needed for 'all' mode or if cache missed)
                 const element = this.canvas.querySelector(`.node[data-id="${nodeId}"]`);
                 // Cache if found in single mode
                 if (this.displayMode === 'single' && element && nodeId !== undefined) {
                     this.nodeElementCache.set(nodeId, element);
                 }
                 return element;
            }

            getChildren(parentId) {
                 if (this.displayMode !== 'single') return [];
                 return this.connections
                     .filter(c => c.from === parentId)
                     .map(c => this.getNodeById(c.to))
                     .filter(node => node); // Filter out nulls if data inconsistency occurs
            }


            // --- Node Operations (operate on current map data) ---

            addNode(nodeData) {
                 if (this.displayMode !== 'single' || !this.currentMapId) return;
                 const mapData = this.getCurrentMapData(); if (!mapData) return;

                 nodeData.color = nodeData.color || this.getDefaultNodeColor();
                 nodeData.shape = nodeData.shape || 'rounded-rectangle';
                 nodeData.parentId = nodeData.parentId !== undefined ? nodeData.parentId : null;

                 mapData.nodes.push(nodeData); this.nodes = mapData.nodes;

                 if (nodeData.parentId !== null) {
                     const parentExists = this.getNodeById(nodeData.parentId);
                     if (parentExists) {
                         if (!mapData.connections.some(c => c.from === nodeData.parentId && c.to === nodeData.id)) {
                              mapData.connections.push({ from: nodeData.parentId, to: nodeData.id });
                              this.connections = mapData.connections;
                         }
                     } else {
                          console.warn(`Parent node ${nodeData.parentId} not found for node ${nodeData.id} in map ${this.currentMapId}. Setting parentId to null.`);
                          nodeData.parentId = null; // Correct data
                     }
                 }

                 const nodeElement = this.createNodeElement(nodeData);
                 this.applyNodeStyle(nodeData, nodeElement);
                 this.updateNodeElementPosition(nodeData, nodeElement);
                 this.canvas.appendChild(nodeElement);
                 this.nodeElementCache.set(nodeData.id, nodeElement); // Add to cache

                 this.buildRootNodeMap();
                 this.updateStructureTree();
                 this.updateConnections();
                 this.selectNode(nodeData.id);
                 gsap.fromTo(nodeElement, { scale: 0.5, opacity: 0 }, { scale: 1, opacity: 1, duration: 0.3, ease: "back.out(1.7)" });
                 console.log(`Node added to map ${this.currentMapId}: ID=${nodeData.id}`);
            }

            deleteNodeAndDescendants(nodeId) {
                 // Renamed to be clear it removes children too
                 if (this.displayMode !== 'single' || !this.currentMapId) return;
                 const mapData = this.getCurrentMapData();
                 if (!mapData || nodeId === mapData.rootNodeId) {
                     this.showToast("Cannot delete the root node.", true); return;
                 }

                 const nodesToDeleteIds = this.findNodeAndDescendants(nodeId);
                 if (nodesToDeleteIds.length === 0) return;
                 console.log(`Deleting nodes from map ${this.currentMapId}: ${nodesToDeleteIds.join(', ')}`);

                 // Remove elements with animation
                 nodesToDeleteIds.forEach(id => {
                     const element = this.getNodeElement(id);
                     if (element) {
                         gsap.to(element, { scale: 0.5, opacity: 0, duration: 0.2, onComplete: () => element.remove() });
                     }
                     this.rootNodeMap.delete(id);
                     this.nodeElementCache.delete(id); // Remove from cache
                 });

                 // Filter data arrays
                 mapData.nodes = mapData.nodes.filter(node => !nodesToDeleteIds.includes(node.id));
                 mapData.connections = mapData.connections.filter(conn =>
                     !nodesToDeleteIds.includes(conn.from) && !nodesToDeleteIds.includes(conn.to)
                 );
                 this.nodes = mapData.nodes; // Sync local state
                 this.connections = mapData.connections; // Sync local state

                 // Reset selection if deleted
                 if (this.selectedNodeId !== null && nodesToDeleteIds.includes(this.selectedNodeId)) {
                     this.selectedNodeId = null;
                 }
                 if (this.contextMenuNodeId !== null && nodesToDeleteIds.includes(this.contextMenuNodeId)) {
                     this.contextMenuNodeId = null; this.closeContextMenu();
                 }

                 this.updateConnections();
                 this.updateStructureTree();
            }

            deleteMapById(mapIdToDelete) {
                if (this.isLoading || !this.allMapsData.maps[mapIdToDelete]) {
                    console.error(`Attempted to delete non-existent map: ${mapIdToDelete}`);
                    this.showToast("Map not found.", true); return;
                }

                const mapName = this.allMapsData.maps[mapIdToDelete]?.name || 'Untitled Map';
                console.log(`Deleting map: ${mapIdToDelete} ("${mapName}")`);
                delete this.allMapsData.maps[mapIdToDelete];

                let needsUIRefresh = false;
                if (this.displayMode === 'single' && this.currentMapId === mapIdToDelete) {
                    console.log("Active map was deleted. Switching to 'Display All' mode.");
                    this.currentMapId = null; this.allMapsData.meta.activeMapId = null;
                    this.displayMode = 'all'; this.allMapsData.meta.displayMode = 'all';
                    needsUIRefresh = true;
                }

                this.renderTabs(); // Always update tabs

                if (needsUIRefresh || this.displayMode === 'all') {
                    this.renderDisplayAll(true); // Re-render the 'all' view canvas and center
                }
                this.updateAutoLayoutButtonState(); // Update button state (will be disabled)

                this.showToast(`Map "${this.escapeHtml(mapName)}" deleted.`);
                this.saveToCloud(); // Save deletion immediately
            }

             createNodeElement(nodeData) {
                 const element = document.createElement('div');
                 element.className = 'node';
                 element.dataset.id = nodeData.id;
                 this.updateNodeElementContent(element, nodeData);
                 return element;
             }

             updateNodeElementContent(element, nodeData) {
                 if (!element) return;
                 const safeTitle = this.escapeHtml(nodeData.title) || 'Untitled';
                 const safeContent = nodeData.content ? this.escapeHtml(nodeData.content).replace(/\n/g, '<br>') : '';
                 element.innerHTML = `
                     <div class="node-title">${safeTitle}</div>
                     ${safeContent ? `<div class="node-content">${safeContent}</div>` : ''}
                 `;
             }

             applyNodeStyle(node, element = null) {
                 const targetElement = element || this.getNodeElement(node.id);
                 if (!targetElement) return;
                 const bgColor = node.color || this.getDefaultNodeColor();
                 targetElement.style.setProperty('--node-bg-color', bgColor);
                 // Ensure text color contrasts with background (simple check)
                 const titleColor = this.getContrastingTextColor(bgColor);
                 targetElement.style.setProperty('--node-text-color', titleColor);
                 targetElement.style.setProperty('--node-content-color', titleColor === '#ffffff' ? 'rgba(255,255,255,0.85)' : 'rgba(0,0,0,0.7)'); // Slightly dimmer content
                 targetElement.classList.remove('node-shape-rectangle', 'node-shape-rounded-rectangle', 'node-shape-stadium', 'node-shape-ellipse');
                 targetElement.classList.add(`node-shape-${node.shape || 'rounded-rectangle'}`);
             }

             applyCurrentStylesToAllNodes() {
                 if (this.displayMode === 'single' && this.nodes) {
                     this.nodes.forEach(node => this.applyNodeStyle(node));
                 } else if (this.displayMode === 'all') {
                     Object.values(this.allMapsData.maps).forEach(mapData => {
                         if (mapData.rootNodeId && mapData.nodes) {
                             const rootNodeData = mapData.nodes.find(n => n.id === mapData.rootNodeId);
                             const element = this.getNodeElement(mapData.rootNodeId);
                             if (rootNodeData && element) {
                                 this.applyNodeStyle(rootNodeData, element);
                             }
                         }
                     });
                 }
             }

             updateNodeElementPosition(node, element = null) {
                 const targetElement = element || this.getNodeElement(node.id);
                 if (targetElement) {
                     const xPos = typeof node.x === 'number' ? node.x : 0;
                     const yPos = typeof node.y === 'number' ? node.y : 0;
                     // Don't use GSAP here, just set the initial/dragged position
                     targetElement.style.transform = `translate(${xPos}px, ${yPos}px)`;
                 }
             }

             selectNode(nodeId) {
                 if (this.displayMode !== 'single') return;
                 if (this.selectedNodeId !== nodeId) {
                     this.deselectNode();
                     this.selectedNodeId = nodeId;
                 }
                 const element = this.getNodeElement(nodeId);
                 if (element) {
                      element.classList.add('selected');
                 }
                 this.updateStructureTree();
             }

             deselectNode() {
                 if (this.displayMode !== 'single' || this.selectedNodeId === null) return;
                 const prevElement = this.getNodeElement(this.selectedNodeId);
                 if (prevElement) {
                     prevElement.classList.remove('selected');
                 }
                 this.selectedNodeId = null;
                 this.updateStructureTree();
             }

            // --- Root Finding & Connections ---
             buildRootNodeMap() {
                 this.rootNodeMap.clear();
                 if (this.displayMode !== 'single' || !this.nodes || this.nodes.length === 0) return;
                 const parentMap = new Map();
                 this.connections.forEach(c => parentMap.set(c.to, c.from));
                 const findRootRecursive = (currentId, path = new Set()) => { // Add path for loop detection
                     if (this.rootNodeMap.has(currentId)) return this.rootNodeMap.get(currentId);
                     if (path.has(currentId)) { // Loop detected
                         console.warn(`Loop detected involving node ${currentId}. Treating as root.`);
                         this.rootNodeMap.set(currentId, currentId);
                         return currentId;
                     }
                     path.add(currentId);
                     const parentId = parentMap.get(currentId);
                     if (parentId === undefined || parentId === null) { // It's a root
                         this.rootNodeMap.set(currentId, currentId);
                         path.delete(currentId); // Clean up path
                         return currentId;
                     }
                     const rootId = findRootRecursive(parentId, path);
                     this.rootNodeMap.set(currentId, rootId);
                     path.delete(currentId); // Clean up path
                     return rootId;
                 };
                 this.nodes.forEach(node => {
                     if (!this.rootNodeMap.has(node.id)) {
                         findRootRecursive(node.id);
                     }
                 });
             }

             getBranchColor(nodeId) {
                 if (this.displayMode !== 'single') return null;
                 const rootId = this.rootNodeMap.get(nodeId);
                 if (rootId !== undefined && rootId !== nodeId && this.branchColors.length > 0) {
                    const numericRootId = Number(rootId);
                    if (!isNaN(numericRootId)) {
                       const colorIndex = Math.abs(numericRootId % this.branchColors.length);
                       return this.branchColors[colorIndex];
                    }
                 }
                 return null;
             }

             updateConnections() {
                this.connectorSvg.innerHTML = '';
                if (this.displayMode !== 'single' || !this.connections || this.connections.length === 0) return;

                const defaultColor = this.getDefaultConnectorColor();
                const fragment = document.createDocumentFragment();
                let visibleConnectionCount = 0;

                this.connections.forEach(conn => {
                    try {
                        const fromNode = this.getNodeById(conn.from);
                        const toNode = this.getNodeById(conn.to);
                        if (!fromNode || !toNode) return;
                        // Use cached elements for performance
                        const fromElement = this.getNodeElement(fromNode.id);
                        const toElement = this.getNodeElement(toNode.id);

                        if (fromElement && toElement && fromElement.offsetWidth > 0 && toElement.offsetWidth > 0) {
                            // Calculate center points based on node data (x,y) and element dimensions
                            const fromX = (fromNode.x || 0) + fromElement.offsetWidth / 2;
                            const fromY = (fromNode.y || 0) + fromElement.offsetHeight / 2;
                            const toX = (toNode.x || 0) + toElement.offsetWidth / 2;
                            const toY = (toNode.y || 0) + toElement.offsetHeight / 2;
                            const color = conn.color || this.getBranchColor(toNode.id) || defaultColor;
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', fromX); line.setAttribute('y1', fromY);
                            line.setAttribute('x2', toX); line.setAttribute('y2', toY);
                            line.style.stroke = color;
                            line.classList.add('connector-line');
                            line.dataset.fromId = fromNode.id; line.dataset.toId = toNode.id;
                            fragment.appendChild(line);
                            visibleConnectionCount++;
                        }
                    } catch (error) { console.error("Error creating connection:", error, conn); }
                });
                this.connectorSvg.appendChild(fragment);
            }

             // --- Canvas Transformation, Zoom, Center ---
             updateCanvasTransform() {
                 const transform = `translate(${this.offset.x}px, ${this.offset.y}px) scale(${this.scale})`;
                 this.canvas.style.transform = transform;
                 this.connectorSvg.style.transform = transform;
             }

             zoom(factor) {
                 const rect = this.canvasContainer.getBoundingClientRect();
                 const centerX = rect.width / 2;
                 const centerY = rect.height / 2;
                 this.zoomAtPoint(factor, centerX, centerY);
             }

             zoomAtPoint(factor, screenX, screenY) {
                 const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * factor));
                 if (newScale === this.scale) return;
                 const pointX = (screenX - this.offset.x) / this.scale;
                 const pointY = (screenY - this.offset.y) / this.scale;
                 this.offset.x = screenX - pointX * newScale;
                 this.offset.y = screenY - pointY * newScale;
                 this.scale = newScale;
                 this.updateCanvasTransform();
             }

             centerView(userInitiated = false) {
                 let elementsToCenter = [];
                 if (this.displayMode === 'single' && this.nodes && this.nodes.length > 0) {
                      // Use cached elements for centering calculation
                     elementsToCenter = this.nodes.map(node => ({ node, element: this.getNodeElement(node.id) }))
                                            .filter(item => item.element && item.element.offsetWidth > 0);
                 } else if (this.displayMode === 'all') {
                     elementsToCenter = Object.entries(this.allMapsData.maps).map(([mapId, mapData]) => {
                         if (!mapData?.nodes || !mapData.rootNodeId) return null;
                         const rootNodeData = mapData.nodes.find(n => n.id === mapData.rootNodeId);
                         const element = this.getNodeElement(mapData.rootNodeId); // Get element from canvas
                         return { node: rootNodeData, element: element };
                     }).filter(item => item && item.node && item.element && item.element.offsetWidth > 0);
                 }

                 if (elementsToCenter.length === 0) {
                      this.offset = { x: this.canvasContainer.offsetWidth / 2, y: this.canvasContainer.offsetHeight / 3 };
                      this.scale = 1;
                      this.updateCanvasTransform(); return;
                 }

                 let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                 elementsToCenter.forEach(({ node, element }) => {
                     let currentX = node.x || 0;
                     let currentY = node.y || 0;
                     // Use element's layout position if in 'all' mode
                     if (this.displayMode === 'all') {
                         const transform = element.style.transform;
                         const match = transform.match(/translate\(\s*(-?\d+(?:\.\d+)?px)\s*,\s*(-?\d+(?:\.\d+)?px)\s*\)/);
                         if (match) { currentX = parseFloat(match[1]); currentY = parseFloat(match[2]); }
                     }
                     minX = Math.min(minX, currentX);
                     maxX = Math.max(maxX, currentX + element.offsetWidth);
                     minY = Math.min(minY, currentY);
                     maxY = Math.max(maxY, currentY + element.offsetHeight);
                 });

                 const nodesWidth = Math.max(maxX - minX, 150);
                 const nodesHeight = Math.max(maxY - minY, 50);
                 const nodesCenterX = minX + nodesWidth / 2;
                 const nodesCenterY = minY + nodesHeight / 2;
                 const containerRect = this.canvasContainer.getBoundingClientRect();
                 const padding = Math.min(containerRect.width, containerRect.height) * 0.1;
                 const scaleX = (containerRect.width - padding * 2) / nodesWidth;
                 const scaleY = (containerRect.height - padding * 2) / nodesHeight;
                 const targetScale = Math.max(this.minScale, Math.min(this.maxScale, scaleX, scaleY, 1.5)); // Limit max zoom
                 const targetOffsetX = containerRect.width / 2 - nodesCenterX * targetScale;
                 const targetOffsetY = containerRect.height / 2 - nodesCenterY * targetScale;

                 if (userInitiated) {
                      gsap.to(this, {
                          scale: targetScale,
                          offset: { x: targetOffsetX, y: targetOffsetY },
                          duration: 0.4, ease: "power2.out",
                          onUpdate: () => this.updateCanvasTransform(),
                      });
                 } else {
                      this.scale = targetScale;
                      this.offset.x = targetOffsetX; this.offset.y = targetOffsetY;
                      this.updateCanvasTransform();
                 }
             }

             // --- Node Edit Modal ---
             openNodeModal() { this.nodeModal.classList.add('active'); setTimeout(() => this.nodeTitleInput.focus(), 50); }
             closeNodeModal() {
                 this.nodeModal.classList.remove('active');
                 this.nodeForm.reset();
                 this.nodeColorInput.value = this.getDefaultNodeColor();
                 this.editingNodeId = null;
                 this.contextMenuNodeId = null; // Clear context if modal was opened from it
             }
             saveNodeEdit() {
                  if (this.displayMode !== 'single' || !this.currentMapId) return;
                  const mapData = this.getCurrentMapData(); if (!mapData) return;

                  const title = this.nodeTitleInput.value.trim();
                  const content = this.nodeContentInput.value.trim();
                  const color = this.nodeColorInput.value;
                  const shape = this.nodeShapeSelect.value;

                  if (this.editingNodeId !== null) { // Editing existing node
                      const node = this.getNodeById(this.editingNodeId);
                      if (node) {
                          node.title = title; node.content = content; node.color = color; node.shape = shape;
                          this.updateNodeElementContent(this.getNodeElement(node.id), node);
                          this.applyNodeStyle(node);
                          this.updateConnections(); // Size might change
                          this.updateStructureTree();
                          if (node.id === mapData.rootNodeId) {
                              mapData.name = title;
                              this.renderTabs(); // Update tab text
                              this.sidebarTitle.textContent = `Structure: ${mapData.name || 'Untitled'}`; // Update sidebar title too
                          }
                      }
                  } else { // Adding new node (parent ID from context menu)
                      let parentId = this.contextMenuNodeId;
                      if (parentId === null) {
                           console.error("Cannot add node without a parent context."); this.closeNodeModal(); return;
                      }
                      let position = this.calculateNewNodePosition(parentId);
                      const newNode = {
                          id: this.getNextId(), title, content, x: position.x, y: position.y,
                          parentId: parentId, color, shape
                      };
                      this.addNode(newNode); // Handles adding to mapData, connections, DOM etc.
                      // No need to call buildRootNodeMap or updateStructureTree here, addNode does it
                  }
                  this.closeNodeModal();
             }


             // --- Map Delete Confirmation Modal ---
             createConfirmationModal() {
                this.confirmModal = document.createElement('div');
                this.confirmModal.id = 'confirm-modal';
                this.confirmModal.className = 'modal'; // Use existing modal styles

                const content = document.createElement('div');
                content.className = 'modal-content';

                const header = document.createElement('div');
                header.className = 'modal-header';
                this.confirmModalTitle = document.createElement('h3');
                this.confirmModalTitle.className = 'modal-title';
                this.confirmModalCloseBtn = document.createElement('button');
                this.confirmModalCloseBtn.className = 'modal-close';
                this.confirmModalCloseBtn.innerHTML = '&times;';
                this.confirmModalCloseBtn.title = 'Close';
                header.appendChild(this.confirmModalTitle);
                header.appendChild(this.confirmModalCloseBtn);

                this.confirmModalBody = document.createElement('div');
                this.confirmModalBody.className = 'modal-body'; // Use new class for body text

                const footer = document.createElement('div');
                footer.className = 'modal-footer';
                this.confirmModalCancelBtn = document.createElement('button');
                this.confirmModalCancelBtn.type = 'button';
                this.confirmModalCancelBtn.className = 'btn btn-secondary';
                this.confirmModalCancelBtn.textContent = 'Cancel';
                this.confirmModalConfirmBtn = document.createElement('button');
                this.confirmModalConfirmBtn.type = 'button';
                this.confirmModalConfirmBtn.className = 'btn btn-danger'; // Use danger style
                this.confirmModalConfirmBtn.textContent = 'Delete';
                footer.appendChild(this.confirmModalCancelBtn);
                footer.appendChild(this.confirmModalConfirmBtn);

                content.appendChild(header);
                content.appendChild(this.confirmModalBody);
                content.appendChild(footer);
                this.confirmModal.appendChild(content);

                this.bodyEl.appendChild(this.confirmModal); // Add to body

                // Add event listeners for the modal itself
                this.confirmModalCloseBtn.addEventListener('click', () => this.closeConfirmationModal());
                this.confirmModalCancelBtn.addEventListener('click', () => this.closeConfirmationModal());
                // Confirm button listener is added when the modal is shown
             }

             showDeleteMapConfirmation(mapId, mapName) {
                 if (!this.confirmModal) this.createConfirmationModal(); // Ensure exists

                 this.mapIdToDelete = mapId; // Store the ID temporarily
                 this.confirmModalTitle.textContent = 'Confirm Deletion';
                 this.confirmModalBody.innerHTML = `Are you sure you want to permanently delete the mind map "<strong>${this.escapeHtml(mapName)}</strong>"?<br>This action cannot be undone.`;
                 this.confirmModalConfirmBtn.textContent = 'Delete Map';

                 // Remove previous listener if any and add new one
                 const confirmHandler = () => {
                     this.deleteMapById(this.mapIdToDelete);
                     this.closeConfirmationModal();
                 };
                 this.confirmModalConfirmBtn.replaceWith(this.confirmModalConfirmBtn.cloneNode(true)); // Clone to remove old listeners
                 this.confirmModalConfirmBtn = this.confirmModal.querySelector('.btn-danger'); // Re-select the cloned button
                 this.confirmModalConfirmBtn.addEventListener('click', confirmHandler, { once: true }); // Add listener to the new button


                 this.confirmModal.classList.add('active');
             }

             closeConfirmationModal() {
                 if (this.confirmModal) {
                     this.confirmModal.classList.remove('active');
                 }
                 this.mapIdToDelete = null; // Clear temp ID
             }

             updateConfirmationModalStyle() {
                 // This function might be needed if the modal style depends heavily on CSS variables
                 // that change with the theme and aren't automatically inherited.
                 // For now, relying on existing modal CSS seems sufficient.
                 // Example: If button styles needed explicit updates:
                 // if (this.confirmModalConfirmBtn) {
                 //     this.confirmModalConfirmBtn.style.backgroundColor = getComputedStyle(this.htmlEl).getPropertyValue('--danger-bg');
                 //     // etc.
                 // }
             }

             // --- Context Menu ---
             showContextMenu(x, y, mode) {
                 this.closeContextMenu();
                 this.contextMenu.style.display = 'block';

                 const singleOptions = [this.addChildOption, this.editNodeOption, this.changeConnectorColorOption, this.deleteNodeOption, this.singleMapDivider];
                 const allOptions = [this.openMapOption, this.deleteMapOption, this.allMapsDivider];

                 singleOptions.forEach(el => el.style.display = (mode === 'single') ? 'flex' : 'none');
                 allOptions.forEach(el => el.style.display = (mode === 'all') ? 'flex' : 'none');

                 if (mode === 'single' && this.contextMenuNodeId !== null) {
                     const node = this.getNodeById(this.contextMenuNodeId);
                     const mapData = this.getCurrentMapData();
                     const isRoot = node && mapData && node.id === mapData.rootNodeId;
                     const hasParentConnection = node && !isRoot && this.connections.some(c => c.to === node.id);
                     this.changeConnectorColorOption.style.display = hasParentConnection ? 'flex' : 'none';
                     this.deleteNodeOption.style.display = (node && !isRoot) ? 'flex' : 'none';
                     this.singleMapDivider.style.display = (hasParentConnection || (node && !isRoot)) ? 'block' : 'none';
                 }

                 // Position Menu
                 let adjustedX = x; let adjustedY = y;
                 this.contextMenu.style.left = `${adjustedX}px`; this.contextMenu.style.top = `${adjustedY}px`;
                 requestAnimationFrame(() => { // Adjust after initial placement
                    const menuRect = this.contextMenu.getBoundingClientRect();
                    const winWidth = window.innerWidth; const winHeight = window.innerHeight;
                    if (menuRect.right > winWidth - 10) adjustedX = x - menuRect.width;
                    if (menuRect.bottom > winHeight - 10) adjustedY = y - menuRect.height;
                    if (adjustedX < 10) adjustedX = 10; if (adjustedY < 10) adjustedY = 10;
                    this.contextMenu.style.left = `${adjustedX}px`; this.contextMenu.style.top = `${adjustedY}px`;
                 });
             }
             closeContextMenu() {
                 if (this.contextMenu.style.display === 'block') {
                      this.contextMenu.style.display = 'none';
                 }
                 // Don't clear context IDs here, might be needed by modals/pickers
             }

             // --- Structure Tree ---
             updateStructureTree() {
                 this.structureTree.innerHTML = '';
                 if (this.displayMode !== 'single') {
                     this.renderMapListSidebar(); // Show map list in 'all' mode
                     return;
                 }
                 if (!this.nodes || this.nodes.length === 0) {
                     this.structureTree.innerHTML = '<p style="color: var(--text-muted); font-style: italic;">Map is empty.</p>';
                     return;
                 }

                 const nodesMap = new Map();
                 this.nodes.forEach(node => { nodesMap.set(node.id, { ...node, children: [] }); });
                 this.connections.forEach(conn => {
                     const parentNode = nodesMap.get(conn.from); const childNode = nodesMap.get(conn.to);
                     if(parentNode && childNode){ parentNode.children.push(childNode); }
                 });

                 const childIds = new Set(this.connections.map(conn => conn.to));
                 const rootNodes = this.nodes.filter(node => !childIds.has(node.id))
                                         .map(node => nodesMap.get(node.id))
                                         .sort((a, b) => (a?.title || '').localeCompare(b?.title || ''));

                 if (rootNodes.length === 0 && this.nodes.length > 0) {
                     const mapData = this.getCurrentMapData();
                     if (mapData && mapData.rootNodeId && nodesMap.has(mapData.rootNodeId)) {
                         rootNodes.push(nodesMap.get(mapData.rootNodeId));
                         console.warn("Using designated rootNodeId for tree as no parentless nodes found.");
                     } else if (this.nodes.length > 0) {
                         rootNodes.push(nodesMap.get(this.nodes[0].id)); // Fallback: first node
                          console.warn("Could not find root for tree. Using first node as root.");
                     }
                 }

                 rootNodes.forEach(node => {
                     const treeElement = this.createTreeElement(node);
                     if (treeElement) this.structureTree.appendChild(treeElement);
                 });
             }

             createTreeElement(node) {
                 if (!node) return null;
                 const container = document.createElement('div');
                 const nodeElement = document.createElement('div');
                 nodeElement.classList.add('tree-node');
                 nodeElement.textContent = node.title || 'Untitled';
                 nodeElement.title = node.title || 'Untitled';
                 if (node.id === this.selectedNodeId) { nodeElement.classList.add('selected'); }
                 nodeElement.addEventListener('click', (e) => {
                     e.stopPropagation(); this.selectNode(node.id); this.scrollToNode(node.id);
                      if (window.innerWidth <= 768 && this.sidebar.classList.contains('open')) { this.toggleSidebar(false); }
                 });
                 container.appendChild(nodeElement);
                 if (node.children && node.children.length > 0) {
                     const childrenContainer = document.createElement('div');
                     childrenContainer.classList.add('tree-children');
                     node.children.sort((a, b) => (a?.title || '').localeCompare(b?.title || ''))
                         .forEach(child => {
                             const childElement = this.createTreeElement(child);
                             if (childElement) childrenContainer.appendChild(childElement);
                         });
                     container.appendChild(childrenContainer);
                 }
                 return container;
             }

              scrollToNode(nodeId) {
                 if (this.displayMode !== 'single') return;
                 const node = this.getNodeById(nodeId); const element = this.getNodeElement(nodeId);
                 if (!node || !element) return;
                 const nodeX = node.x || 0; const nodeY = node.y || 0;
                 const nodeWidth = element.offsetWidth; const nodeHeight = element.offsetHeight;
                 const containerRect = this.canvasContainer.getBoundingClientRect();
                 const targetX = nodeX + nodeWidth / 2; const targetY = nodeY + nodeHeight / 2;
                 const desiredOffsetX = containerRect.width / 2 - targetX * this.scale;
                 const desiredOffsetY = containerRect.height / 2 - targetY * this.scale;
                 gsap.to(this.offset, { x: desiredOffsetX, y: desiredOffsetY, duration: 0.4, ease: "power2.out", onUpdate: () => this.updateCanvasTransform() });
             }

             // --- New Node Position Calculation ---
              calculateNewNodePosition(parentId) {
                 if (this.displayMode !== 'single') return {x: 0, y: 0};
                 const parentNode = this.getNodeById(parentId);
                 const parentElement = this.getNodeElement(parentId);
                 const parentX = parentNode?.x || 0; const parentY = parentNode?.y || 0;

                 if(parentNode && parentElement && parentElement.offsetWidth > 0) {
                     const parentWidth = parentElement.offsetWidth;
                     // Use layout constants
                     const spacingX = this.treeLayoutHorizontalSpacing;
                     const spacingY = this.treeLayoutVerticalSpacing;

                     const children = this.getChildren(parentId)
                         .map(node => ({ node, element: this.getNodeElement(node.id) }))
                         .filter(data => data.node && data.element && data.element.offsetHeight > 0)
                         .sort((a,b) => (a.node.y || 0) - (b.node.y || 0));

                     let targetX = parentX + parentWidth + spacingX;
                     let targetY;
                     if (children.length > 0) {
                         const lastChild = children[children.length - 1];
                         targetY = (lastChild.node.y || 0) + lastChild.element.offsetHeight + spacingY;
                     } else {
                         targetY = parentY + spacingY / 2;
                     }
                     return { x: targetX, y: targetY };
                 } else {
                     console.warn("Calculating position without valid parent element.");
                     const screenCenter = { x: this.canvasContainer.offsetWidth / 2, y: this.canvasContainer.offsetHeight / 3 };
                     return this.screenToCanvasCoords(screenCenter.x, screenCenter.y);
                 }
             }

             screenToCanvasCoords(screenX, screenY) {
                 const rect = this.canvasContainer.getBoundingClientRect();
                 const canvasX = (screenX - rect.left - this.offset.x) / this.scale;
                 const canvasY = (screenY - rect.top - this.offset.y) / this.scale;
                 return { x: canvasX, y: canvasY };
            }

            // --- Auto Layout ---
            updateAutoLayoutButtonState() {
                 if (this.autoLayoutBtn) {
                      this.autoLayoutBtn.disabled = !(this.displayMode === 'single' && this.currentMapId && this.nodes.length > 0);
                 }
             }

            applyAutoLayout() {
                 if (this.displayMode !== 'single' || !this.currentMapId || !this.nodes || this.nodes.length === 0) {
                     this.showToast("Auto-layout only available when viewing a single map with nodes.", true);
                     return;
                 }
                 const mapData = this.getCurrentMapData();
                 if (!mapData || !mapData.rootNodeId) {
                      this.showToast("Cannot apply layout: Root node not found.", true);
                      return;
                 }
                 const rootNode = this.getNodeById(mapData.rootNodeId);
                 if (!rootNode) {
                     this.showToast("Cannot apply layout: Root node data missing.", true);
                     return;
                 }

                 console.log("Applying Tree Layout...");
                 this.showToast("Applying tree layout...", false);

                 // Prepare data structure for layout calculation
                 const nodePositions = new Map(); // Stores calculated { x, y } for each nodeId
                 const nodeSubtreeHeights = new Map(); // Stores calculated height for each node's subtree

                 // --- Step 1: Calculate subtree heights recursively (bottom-up) ---
                 const calculateSubtreeHeight = (nodeId) => {
                     if (nodeSubtreeHeights.has(nodeId)) return nodeSubtreeHeights.get(nodeId);

                     const element = this.getNodeElement(nodeId);
                     const nodeHeight = element?.offsetHeight || this.nodeHeightEstimate;
                     const children = this.getChildren(nodeId);

                     if (children.length === 0) {
                         nodeSubtreeHeights.set(nodeId, nodeHeight);
                         return nodeHeight;
                     }

                     let totalChildrenHeight = 0;
                     children.forEach(child => {
                         totalChildrenHeight += calculateSubtreeHeight(child.id);
                     });

                     // Add spacing between children
                     const totalSpacing = (children.length - 1) * this.treeLayoutVerticalSpacing;
                     const subtreeHeight = Math.max(nodeHeight, totalChildrenHeight + totalSpacing); // Subtree height is max of node or children block
                     nodeSubtreeHeights.set(nodeId, subtreeHeight);
                     return subtreeHeight;
                 };

                 // --- Step 2: Position nodes recursively (top-down) ---
                 const positionNodesRecursive = (nodeId, currentX, startY) => {
                     const element = this.getNodeElement(nodeId);
                     const nodeHeight = element?.offsetHeight || this.nodeHeightEstimate;
                     const subtreeHeight = nodeSubtreeHeights.get(nodeId) || nodeHeight;

                     // Center node vertically within its allocated subtree space
                     const currentY = startY + (subtreeHeight / 2) - (nodeHeight / 2);
                     nodePositions.set(nodeId, { x: currentX, y: currentY });

                     const children = this.getChildren(nodeId);
                     if (children.length > 0) {
                         const childX = currentX + (element?.offsetWidth || 150) + this.treeLayoutHorizontalSpacing;
                         let childStartY = startY;

                         children.forEach(child => {
                             const childSubtreeHeight = nodeSubtreeHeights.get(child.id) || this.nodeHeightEstimate;
                             positionNodesRecursive(child.id, childX, childStartY);
                             childStartY += childSubtreeHeight + this.treeLayoutVerticalSpacing; // Move startY for the next sibling
                         });
                     }
                 };

                 // --- Run calculations ---
                 calculateSubtreeHeight(mapData.rootNodeId); // Start height calculation from root
                 positionNodesRecursive(mapData.rootNodeId, 0, 0); // Start positioning from root at (0,0)

                 // --- Step 3: Apply calculated positions with animation ---
                 const tl = gsap.timeline({
                     onComplete: () => {
                         this.updateConnections(); // Update connectors after animation
                         this.centerView(true); // Center view after layout
                         this.showToast("Layout applied!", false);
                         console.log("Tree Layout Animation Complete.");
                     }
                 });

                 this.nodes.forEach(node => {
                     const newPos = nodePositions.get(node.id);
                     const element = this.getNodeElement(node.id);
                     if (newPos && element) {
                         // Update node data immediately
                         node.x = newPos.x;
                         node.y = newPos.y;
                         // Add animation to timeline
                         tl.to(element, {
                             x: newPos.x, // GSAP can animate translate directly via x/y
                             y: newPos.y,
                             duration: 0.5,
                             ease: "power2.inOut"
                         }, 0); // "<" means start at the same time as the previous animation
                     } else if (element) {
                         console.warn(`No calculated position for node ${node.id}. Skipping animation.`);
                          // Ensure it's still drawn if it exists but wasn't positioned (e.g., disconnected node)
                          const currentTransform = element.style.transform;
                          const match = currentTransform.match(/translate\(\s*(-?\d+(?:\.\d+)?px)\s*,\s*(-?\d+(?:\.\d+)?px)\s*\)/);
                          if (match) { node.x = parseFloat(match[1]); node.y = parseFloat(match[2]); }
                          else { node.x = node.x || 0; node.y = node.y || 0; } // Keep existing or default
                     }
                 });

                 // Update connections *during* animation for a slightly better feel? Or just at end? Let's try at end.
                 // tl.add(this.updateConnections.bind(this), ">-0.1"); // Add connection update near the end

            }


            // --- Cloud Persistence ---

            checkApiConfig() {
                if (!JSONBIN_API_KEY || JSONBIN_API_KEY.startsWith('$2a$10$YOUR_KEY_')) {
                    this.showToast('This is a test  demo - you can't save your mind map', true); console.error('Error: jsonbin.io API Key not set.'); return false;
                }
                if (!JSONBIN_BIN_ID || JSONBIN_BIN_ID === 'YOUR_BIN_ID_HERE') {
                     this.showToast('Error: jsonbin.io Bin ID is not set!', true); console.error('Error: jsonbin.io Bin ID not set.'); return false;
                }
                return true;
            }

            updateCurrentMapData() {
                 if (this.displayMode === 'single' && this.currentMapId) {
                     const mapData = this.allMapsData.maps[this.currentMapId];
                     if (mapData) {
                         mapData.nodes = this.nodes; mapData.connections = this.connections;
                         if (mapData.nodes.length > 0 && !mapData.rootNodeId) {
                             const potentialRoot = mapData.nodes.find(n => n.parentId === null) || mapData.nodes[0];
                             mapData.rootNodeId = potentialRoot.id;
                         }
                         const rootNode = mapData.nodes.find(n => n.id === mapData.rootNodeId);
                         if (rootNode && rootNode.title !== mapData.name) { mapData.name = rootNode.title; }
                         mapData.lastSavedView = { offset: { ...this.offset }, scale: this.scale };
                         // nextId is updated within mapData by getNextId()
                         console.log(`Updated map data in memory for ${this.currentMapId} before save.`);
                     }
                 }
             }


            async saveToCloud() {
                if (this.isLoading || !this.checkApiConfig()) return;
                this.isLoading = true; this.setLoadingState(true);
                console.log("Saving all maps to cloud...");

                try {
                    this.updateCurrentMapData(); // Ensure current map state is captured
                    this.allMapsData.meta.theme = this.currentTheme;
                    this.allMapsData.meta.displayMode = this.displayMode;
                    this.allMapsData.meta.activeMapId = this.currentMapId;

                    // Basic validation before saving
                    Object.values(this.allMapsData.maps).forEach(map => {
                         if (!map.nodes) map.nodes = []; if (!map.connections) map.connections = [];
                         if (map.nodes.length > 0 && (!map.rootNodeId || !map.nodes.some(n => n.id === map.rootNodeId))) {
                            const root = map.nodes.find(n => n.parentId === null) || map.nodes[0];
                            map.rootNodeId = root.id; console.warn(`Auto-assigned rootNodeId ${root.id} to map "${map.name || 'Untitled'}"`);
                         }
                         if(!map.name && map.rootNodeId) { const root = map.nodes.find(n => n.id === map.rootNodeId); map.name = root?.title || 'Untitled Map'; }
                         if (map.nodes.length === 0) map.rootNodeId = null;
                    });

                    const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}`, {
                        method: 'PUT',
                        headers: { 'Content-Type': 'application/json', 'X-Master-Key': JSONBIN_API_KEY, 'X-Bin-Versioning': 'false' },
                        body: JSON.stringify(this.allMapsData)
                    });
                    if (!response.ok) { const errorData = await response.json().catch(() => ({})); throw new Error(`API Error (${response.status}): ${errorData.message || response.statusText}`); }
                    const result = await response.json();
                    console.log('Save successful:', result.metadata.id);
                    this.showToast('All mind maps saved to cloud!');
                } catch (error) {
                     console.error('Error saving mind maps to cloud:', error);
                     this.showToast(`Error saving: ${error.message}`, true);
                } finally {
                    this.isLoading = false; this.setLoadingState(false);
                }
            }

            async loadFromCloud() {
                 if (this.isLoading || !this.checkApiConfig()) return false;
                 this.isLoading = true; this.setLoadingState(true);
                 console.log("Loading all maps from cloud..."); let loadedSuccessfully = false;

                 try {
                     const response = await fetch(`https://api.jsonbin.io/v3/b/${JSONBIN_BIN_ID}/latest`, {
                         method: 'GET', headers: { 'X-Master-Key': JSONBIN_API_KEY }
                     });
                     if (!response.ok) {
                         if (response.status === 404) { // Bin empty/doesn't exist
                             console.log("Bin not found or is empty. Initializing fresh state.");
                             this.allMapsData = { maps: {}, meta: { theme: getInitialTheme(), displayMode: 'all', activeMapId: null } };
                             this.currentMapId = null; this.displayMode = 'all'; this.currentTheme = getInitialTheme();
                             loadedSuccessfully = true; return true;
                         } else { const errorData = await response.json().catch(() => ({})); throw new Error(`API Error (${response.status}): ${errorData.message || response.statusText}`); }
                     }
                     const data = await response.json(); const loadedData = data.record;

                     if (!loadedData || typeof loadedData.maps !== 'object' || typeof loadedData.meta !== 'object') { throw new Error("Invalid data structure received."); }

                     // Validate and sanitize loaded data
                     for (const mapId in loadedData.maps) {
                         const map = loadedData.maps[mapId];
                         if (!map || !Array.isArray(map.nodes) || !Array.isArray(map.connections)) {
                              console.warn(`Removing invalid map data for ID: ${mapId}`); delete loadedData.maps[mapId]; continue;
                         }
                         if (map.nodes.length > 0 && (!map.rootNodeId || !map.nodes.some(n => n.id === map.rootNodeId))) {
                              const newRoot = map.nodes.find(n => n.parentId === null) || map.nodes[0];
                              map.rootNodeId = newRoot.id; console.warn(`Corrected rootNodeId for map "${map.name || mapId}". Set to ${newRoot.id}`);
                         }
                         if (map.nodes.length === 0) map.rootNodeId = null;
                         if (!map.name && map.rootNodeId) { map.name = map.nodes.find(n => n.id === map.rootNodeId)?.title || 'Untitled Map'; }
                         map.nextId = map.nextId || (map.nodes.length > 0 ? Math.max(...map.nodes.map(n => n.id), 0) + 1 : 1);
                         if (map.lastSavedView && (typeof map.lastSavedView.offset !== 'object' || typeof map.lastSavedView.scale !== 'number')) { delete map.lastSavedView; }
                         // Sanitize node positions
                         map.nodes.forEach(n => {
                            n.x = typeof n.x === 'number' ? n.x : 0;
                            n.y = typeof n.y === 'number' ? n.y : 0;
                            n.shape = n.shape || 'rounded-rectangle';
                         });
                     }

                     this.allMapsData = loadedData;
                     this.currentTheme = this.allMapsData.meta.theme || getInitialTheme();
                     this.displayMode = this.allMapsData.meta.displayMode || 'single';
                     this.currentMapId = this.allMapsData.meta.activeMapId || null;

                     if (this.currentMapId && !this.allMapsData.maps[this.currentMapId]) {
                         console.warn(`Loaded activeMapId ${this.currentMapId} no longer exists. Resetting view.`);
                         this.currentMapId = null; this.displayMode = 'all';
                         this.allMapsData.meta.activeMapId = null; this.allMapsData.meta.displayMode = 'all';
                     }
                      if (!this.currentMapId && Object.keys(this.allMapsData.maps).length > 0) {
                         this.displayMode = 'all'; this.allMapsData.meta.displayMode = 'all';
                      }

                     applyTheme(this.currentTheme); localStorage.setItem(themePrefKey, this.currentTheme);
                     console.log(`Cloud data processed. Maps: ${Object.keys(this.allMapsData.maps).length}. Initial Mode: ${this.displayMode}, Map: ${this.currentMapId}`);
                     this.showToast('Mind maps loaded from cloud!');
                     loadedSuccessfully = true;
                 } catch (error) {
                     console.error('Error loading mind maps from cloud:', error);
                     this.showToast(`Error loading: ${error.message}`, true);
                      if (!this.allMapsData.maps) this.allMapsData.maps = {}; // Ensure base structure
                      if (!this.allMapsData.meta) this.allMapsData.meta = { theme: getInitialTheme(), displayMode: 'all', activeMapId: null };
                     loadedSuccessfully = false;
                 } finally {
                     this.isLoading = false; this.setLoadingState(false);
                 }
                 return loadedSuccessfully;
            }


            setLoadingState(isLoading) {
                 this.saveBtn.disabled = isLoading;
                 this.loadBtn.disabled = isLoading;
                 this.newMapBtn.disabled = isLoading;
                 if (this.autoLayoutBtn) this.autoLayoutBtn.disabled = isLoading || !(this.displayMode === 'single' && this.currentMapId && this.nodes.length > 0);
            }


             // --- UI Feedback & Helpers ---
            showToast(message, isError = false) {
                 const existingToast = document.querySelector('.toast-notification');
                 if (existingToast) existingToast.remove();
                 const toast = document.createElement('div');
                 toast.className = 'toast-notification';
                 if (isError) toast.classList.add('error');
                 toast.textContent = message;
                 document.body.appendChild(toast);
                 requestAnimationFrame(() => { toast.classList.add('show'); });
                 setTimeout(() => {
                     toast.classList.remove('show');
                     toast.addEventListener('transitionend', () => { if (toast.parentNode) { toast.remove(); } }, { once: true });
                 }, isError ? 4000 : 3000); // Longer display for errors
             }

            findNodeAndDescendants(startNodeId) {
                  if (this.displayMode !== 'single') return [];
                  const resultIds = []; const node = this.getNodeById(startNodeId); if (!node) return resultIds;
                  const queue = [startNodeId]; const visited = new Set();
                  while (queue.length > 0) {
                      const currentId = queue.shift(); if (visited.has(currentId)) continue;
                      visited.add(currentId); resultIds.push(currentId);
                      this.connections.forEach(conn => {
                          if (conn.from === currentId && this.getNodeById(conn.to) && !visited.has(conn.to)) { queue.push(conn.to); }
                      });
                  }
                  return resultIds;
              }

            toggleTheme() {
                const newTheme = this.currentTheme === 'light' ? 'dark' : 'light';
                this.currentTheme = newTheme;
                this.allMapsData.meta.theme = newTheme; // Update meta state
                applyTheme(newTheme); // applies theme and triggers style updates
                localStorage.setItem(themePrefKey, newTheme);
                console.log(`Theme changed to ${newTheme}`);
            }

            toggleFullscreen() { /* ... (unchanged) ... */
               if (!document.fullscreenElement) { this.htmlEl.requestFullscreen().catch(err => console.error(`Fullscreen error: ${err.message}`)); }
               else if (document.exitFullscreen) { document.exitFullscreen().catch(err => console.error(`Exit fullscreen error: ${err.message}`)); }
            }
            handleFullscreenChange() { /* ... (unchanged) ... */
               this.isFullscreen = !!document.fullscreenElement; this.updateFullscreenIcon(); console.log(`Fullscreen state: ${this.isFullscreen}`);
            }
            updateFullscreenIcon() { /* ... (unchanged) ... */
                const icon = this.fullscreenToggleBtn?.querySelector('i'); if (!icon) return;
                if (this.isFullscreen) { icon.className = 'fas fa-compress'; this.fullscreenToggleBtn.setAttribute('data-tooltip', 'Exit Fullscreen'); }
                else { icon.className = 'fas fa-expand'; this.fullscreenToggleBtn.setAttribute('data-tooltip', 'Enter Fullscreen'); }
            }

            // Helper to get default colors respecting theme
            getDefaultNodeColor() { return getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff'; }
            getDefaultConnectorColor() { return getComputedStyle(this.htmlEl).getPropertyValue('--connector-default-color').trim() || '#cbd5e1'; }
            getCurrentMapData() {
                 if (this.displayMode === 'single' && this.currentMapId && this.allMapsData.maps[this.currentMapId]) { return this.allMapsData.maps[this.currentMapId]; }
                 return null;
             }
             escapeHtml(unsafe) {
                 if (!unsafe) return '';
                 return unsafe.toString()
                      .replace(/&/g, "&amp;")
                      .replace(/</g, "&lt;")
                      .replace(/>/g, "&gt;")
                      .replace(/"/g, "&quot;")
                      .replace(/'/g, "&#039;");
            }
            // Simple contrast checker
            getContrastingTextColor(hexcolor){
                if (!hexcolor) return 'var(--node-text-color)'; // fallback to default CSS var
                hexcolor = hexcolor.replace("#", "");
                if (hexcolor.length === 3) { hexcolor = hexcolor.split('').map(c => c + c).join(''); }
                const r = parseInt(hexcolor.substring(0, 2), 16);
                const g = parseInt(hexcolor.substring(2, 4), 16);
                const b = parseInt(hexcolor.substring(4, 6), 16);
                const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
                // Use CSS variables for text color to respect theme overrides
                return (yiq >= 128) ? (this.currentTheme === 'dark' ? 'var(--text)' : '#1f2937') // Dark text on light bg
                                    : (this.currentTheme === 'dark' ? '#f9fafb' : 'var(--text)'); // Light text on dark bg
            }

        } // End MindMap Class

        // --- Initialize ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing Mind Map Application.");
            window.mindMapInstance = new MindMap();
        });

    </script>
</body>
</html>
