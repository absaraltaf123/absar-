<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Make responsive -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Premium Mind Map Maker</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
    <style>
        :root {
            /* Light Mode Defaults */
            --primary: #6366f1;
            --primary-light: #818cf8;
            --primary-dark: #4f46e5;
            --secondary: #f3f4f6;
            --background: #ffffff;
            --canvas-bg: #f9fafb; /* Light background for canvas */
            --text: #1f2937;
            --text-muted: #6b7280;
            --border: #e5e7eb;
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            --connector-width: 2.5px;
            --connector-default-color: #cbd5e1; /* Default grey */
            --node-bg-color: white; /* Default node background */
            --node-border-color: rgba(0, 0, 0, 0.1);
            --node-text-color: var(--text);
            --node-content-color: #4b5563;
            --modal-bg: white;
            --input-bg: white;
            --input-border: var(--border);
            --control-bg: rgba(255, 255, 255, 0.8);
            --control-icon-color: #6b7280;
            --sidebar-bg: var(--secondary);
            --tree-hover-bg: #e5e7eb;
            --tree-selected-bg: var(--primary-light);
            --tree-selected-text: white;

            --sidebar-width: 250px;
            --header-height: 65px; /* Approximate */
        }

        /* Dark Mode Variables */
        html.dark-mode {
            --primary: #818cf8; /* Lighter primary */
            --primary-light: #a7b2fb;
            --primary-dark: #6366f1;
            --secondary: #374151; /* Darker grey */
            --background: #111827; /* Very dark grey */
            --canvas-bg: #1f2937; /* Dark grey canvas */
            --text: #f3f4f6; /* Light grey text */
            --text-muted: #9ca3af;
            --border: #4b5563; /* Medium grey border */
            --shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3), 0 2px 4px -1px rgba(0, 0, 0, 0.2);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.4), 0 4px 6px -2px rgba(0, 0, 0, 0.3);
            --connector-default-color: #6b7280; /* Darker default connector */
            --node-bg-color: #374151; /* Dark node background */
            --node-border-color: rgba(255, 255, 255, 0.1);
            --node-text-color: var(--text);
            --node-content-color: #d1d5db; /* Lighter content text */
            --modal-bg: #1f2937;
            --input-bg: #374151;
            --input-border: #4b5563;
            --control-bg: rgba(31, 41, 55, 0.8); /* Darker control bg */
            --control-icon-color: #9ca3af;
            --sidebar-bg: #1f2937;
            --tree-hover-bg: #374151;
            --tree-selected-bg: var(--primary); /* Use lighter primary */
            --tree-selected-text: #111827; /* Dark text on selected */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            -webkit-tap-highlight-color: transparent; /* Remove blue tap highlight on mobile */
            transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease; /* Smooth theme transitions */
        }

        html, body {
             height: 100%;
             overflow: hidden;
             overscroll-behavior: none;
        }

        body {
            background-color: var(--background);
            color: var(--text);
            display: flex;
            flex-direction: column;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.8rem 1.5rem;
            background-color: var(--background);
            border-bottom: 1px solid var(--border);
            box-shadow: var(--shadow);
            z-index: 10;
            flex-shrink: 0;
            min-height: var(--header-height);
        }

        @media (max-width: 400px) {
           .logo span { display: none; }
        }

        .logo {
            font-weight: 700;
            font-size: 1.4rem;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .toolbar {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        #sidebar-toggle, #theme-toggle { /* Style theme toggle similar to others */
            display: inline-flex; /* Use inline-flex for alignment */
            align-items: center;
            justify-content: center;
            margin-right: 0.5rem;
            font-size: 1.1rem; /* Match other icons */
            padding: 0.6rem;
            border: 1px solid var(--border);
            background-color: var(--secondary);
            border-radius: 0.375rem;
            cursor: pointer;
            color: var(--text-muted); /* Muted color for utility icons */
            width: 38px; /* Explicit width/height */
            height: 38px;
            transition: background-color 0.2s ease, border-color 0.2s ease, color 0.2s ease;
        }
        #sidebar-toggle:hover, #theme-toggle:hover {
             background-color: var(--border); /* Use border color for hover */
             border-color: var(--text-muted);
             color: var(--text);
        }
        #sidebar-toggle { display: none; } /* Hidden by default, shown in media query */


        .btn {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: 1px solid transparent;
            font-weight: 500;
            cursor: pointer;
            display: inline-flex; /* Changed from flex */
            align-items: center;
            gap: 0.5rem;
            transition: all 0.2s ease;
            font-size: 0.9rem;
            white-space: nowrap; /* Prevent wrapping */
        }

        .btn i {
             font-size: 0.9em;
             width: 1em;
             text-align: center;
        }

        .btn-primary {
            background-color: var(--primary);
            color: white; /* Keep white for primary */
            border-color: var(--primary);
        }
        html.dark-mode .btn-primary {
            color: var(--background); /* Dark text on light primary in dark mode */
        }

        .btn-primary:hover {
            background-color: var(--primary-dark);
            border-color: var(--primary-dark);
        }

        .btn-secondary {
            background-color: var(--secondary);
            color: var(--text);
            border-color: var(--border);
        }

        .btn-secondary:hover {
            background-color: var(--border); /* Use border color for hover */
            border-color: var(--text-muted);
        }

        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
            position: relative;
        }

        .sidebar {
            width: var(--sidebar-width);
            border-right: 1px solid var(--border);
            padding: 1rem;
            background-color: var(--sidebar-bg);
            overflow-y: auto;
            flex-shrink: 0;
            z-index: 5;
             transition: transform 0.3s ease, background-color 0.2s ease, border-color 0.2s ease; /* Added bg/border transition */
             height: 100%;
        }

        .sidebar-title {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text);
        }

        .canvas-container {
            flex: 1;
            position: relative;
            overflow: hidden;
            background-color: var(--canvas-bg);
            height: 100%;
            touch-action: none; /* Essential for preventing browser default panning/zooming */
        }

        #connector-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
            z-index: 0;
            transform-origin: 0 0;
        }

        #connector-svg line {
            stroke-width: var(--connector-width);
            stroke-linecap: round;
            transition: stroke 0.3s ease;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: grab;
            transform-origin: 0 0;
            z-index: 1;
        }

        #canvas.grabbing {
            cursor: grabbing;
        }

        /* Node Styling */
        .node {
            position: absolute;
            min-width: 120px;
            max-width: 220px;
            padding: 0.8rem 1rem;
            border-radius: 0.6rem; /* Base rounding */
            border: 1px solid var(--node-border-color);
            cursor: pointer;
            transition: box-shadow 0.2s ease, border-color 0.2s ease, transform 0.1s linear, background-color 0.2s ease;
            user-select: none;
            -webkit-user-select: none;

            /* Glassy Effect Refined */
            background-color: var(--node-bg-color);
            /* Slightly softer inset shadow, more emphasis on regular shadow */
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.15), var(--shadow);
            transform: translate(0,0);
        }
        html.dark-mode .node {
             box-shadow: inset 0 1px 1px rgba(255,255,255,0.05), var(--shadow); /* Less bright inset in dark mode */
        }


        .node:hover {
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.15), var(--shadow-lg);
            border-color: var(--primary-light);
        }
        html.dark-mode .node:hover {
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.05), var(--shadow-lg);
        }

        .node.selected {
            border: 2px solid var(--primary);
             box-shadow: inset 0 1px 1px rgba(255,255,255,0.15), var(--shadow-lg);
        }
         html.dark-mode .node.selected {
            box-shadow: inset 0 1px 1px rgba(255,255,255,0.05), var(--shadow-lg);
         }

        /* Node Shapes */
        .node.node-shape-rectangle { border-radius: 0.3rem; }
        .node.node-shape-rounded-rectangle { border-radius: 0.6rem; }
        .node.node-shape-stadium { border-radius: 999px; }
        .node.node-shape-ellipse { border-radius: 50%; padding: 1rem; min-width: auto; text-align: center; }


        .node-title, .node-content {
             user-select: text;
             -webkit-user-select: text;
             word-wrap: break-word;
        }

        .node-title {
            font-weight: 600;
            font-size: 0.9rem;
            margin-bottom: 0.4rem;
            color: var(--node-text-color);
        }

        .node-content {
            font-size: 0.78rem;
            color: var(--node-content-color);
            line-height: 1.4;
        }

        /* Modal Styling */
         .modal {
             position: fixed; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0, 0, 0, 0.6); display: flex; align-items: center; justify-content: center; z-index: 20; visibility: hidden; opacity: 0; transition: visibility 0s 0.2s, opacity 0.2s ease;
         }
         html.dark-mode .modal {
            background-color: rgba(0, 0, 0, 0.7); /* Darker overlay */
         }
         .modal.active { visibility: visible; opacity: 1; transition: visibility 0s, opacity 0.2s ease; }
         .modal-content { background-color: var(--modal-bg); border-radius: 0.5rem; padding: 1.5rem; width: 90%; max-width: 450px; box-shadow: var(--shadow-lg); transform: scale(0.9); transition: transform 0.2s ease, background-color 0.2s ease; }
         .modal.active .modal-content { transform: scale(1); }
         .modal-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; border-bottom: 1px solid var(--border); padding-bottom: 0.8rem; }
         .modal-title { font-weight: 600; font-size: 1.15rem; color: var(--text); }
         .modal-close { background: none; border: none; cursor: pointer; font-size: 1.5rem; color: var(--text-muted); line-height: 1; padding: 0.2rem; /* Add padding for easier tapping */ }
         .modal-close:hover { color: var(--text); }
         .form-group { margin-bottom: 1rem; }
         .form-label { display: block; margin-bottom: 0.5rem; font-weight: 500; font-size: 0.9rem; color: var(--text); }
         .form-input, .form-textarea, .form-select, .form-color { width: 100%; padding: 0.75rem; border-radius: 0.375rem; border: 1px solid var(--input-border); font-size: 0.95rem; transition: border-color 0.2s ease, box-shadow 0.2s ease, background-color 0.2s ease, color 0.2s ease; background-color: var(--input-bg); color: var(--text); }
         .form-input:focus, .form-textarea:focus, .form-select:focus, .form-color:focus { outline: none; border-color: var(--primary); box-shadow: 0 0 0 3px color-mix(in srgb, var(--primary) 20%, transparent); } /* Adjusted focus ring */
         .form-textarea { resize: vertical; min-height: 80px; line-height: 1.5; }
         .form-select { appearance: none; background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%236b7280' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E"); background-repeat: no-repeat; background-position: right 0.5rem center; background-size: 1.5em 1.5em; padding-right: 2.5rem; }
         html.dark-mode .form-select { background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' fill='none' viewBox='0 0 20 20'%3E%3Cpath stroke='%239ca3af' stroke-linecap='round' stroke-linejoin='round' stroke-width='1.5' d='M6 8l4 4 4-4'/%3E%3C/svg%3E"); } /* Dark mode arrow */
         .form-color { padding: 0.25rem; height: 40px; cursor: pointer; }
         .modal-footer { display: flex; justify-content: flex-end; gap: 0.5rem; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border); }

        /* Context Menu */
         .contextmenu { position: absolute; background-color: var(--modal-bg); border-radius: 0.375rem; box-shadow: var(--shadow-lg); border: 1px solid var(--border); z-index: 15; overflow: hidden; display: none; min-width: 200px; /* Slightly wider */ }
         .contextmenu-item { padding: 0.6rem 1rem; cursor: pointer; display: flex; align-items: center; gap: 0.75rem; color: var(--text); font-size: 0.875rem; transition: background-color 0.15s ease, color 0.15s ease; }
         .contextmenu-item i { width: 16px; text-align: center; color: var(--text-muted); transition: color 0.15s ease; }
         .contextmenu-item:hover { background-color: var(--secondary); color: var(--primary); }
         .contextmenu-item:hover i { color: var(--primary); }
         .contextmenu-item.danger:hover { background-color: #fee2e2; color: #ef4444; }
         html.dark-mode .contextmenu-item.danger:hover { background-color: #450a0a; color: #f87171; } /* Dark mode danger */
         .contextmenu-item.danger:hover i { color: #ef4444; }
         html.dark-mode .contextmenu-item.danger:hover i { color: #f87171; }
         .contextmenu-divider { height: 1px; background-color: var(--border); margin: 0.25rem 0; }
         /* Hidden connector color option */
         #change-connector-color-option { display: none; }


        /* Controls */
        .controls {
            position: absolute;
            bottom: 1rem;
            right: 1rem;
            display: flex;
            gap: 0.5rem;
            background-color: var(--control-bg);
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
            border-radius: 0.5rem;
            padding: 0.5rem;
            box-shadow: var(--shadow);
            z-index: 5;
        }

        .control-btn {
            background: none;
            border: none;
            cursor: pointer;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 0.375rem;
            color: var(--control-icon-color);
            transition: background-color 0.2s ease, color 0.2s ease;
        }

        .control-btn:hover {
            background-color: var(--secondary);
            color: var(--primary);
        }
        .control-btn i {
             font-size: 1.1rem;
        }

        /* Mini Tooltip */
         .mini-tooltip { position: relative; }
         .mini-tooltip::after { content: attr(data-tooltip); position: absolute; bottom: 110%; left: 50%; transform: translateX(-50%); background-color: color-mix(in srgb, var(--background) 90%, black); color: var(--text); font-size: 0.75rem; padding: 0.25rem 0.5rem; border-radius: 0.25rem; white-space: nowrap; opacity: 0; pointer-events: none; transition: opacity 0.2s ease 0.1s; margin-bottom: 0.5rem; z-index: 10; box-shadow: var(--shadow); }
         .mini-tooltip:hover::after { opacity: 1; }


        /* Structure Tree Styling */
         .tree-node { font-size: 0.85rem; padding: 4px 8px; cursor: pointer; border-radius: 4px; transition: background-color 0.15s ease, color 0.15s ease, font-weight 0.15s ease; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; margin-bottom: 2px; color: var(--text-muted); }
         .tree-node:hover { background-color: var(--tree-hover-bg); color: var(--text); }
         .tree-node.selected { background-color: var(--tree-selected-bg); color: var(--tree-selected-text); font-weight: 600; }
         .tree-children { padding-left: 16px; border-left: 1px solid var(--border); margin-left: 8px; }

         /* Toast Notification */
          .toast-notification { position: fixed; bottom: 2rem; left: 50%; transform: translateX(-50%) translateY(100%); background-color: #10b981; color: white; padding: 0.75rem 1.5rem; border-radius: 0.375rem; box-shadow: var(--shadow-lg); z-index: 50; opacity: 0; transition: opacity 0.3s ease, transform 0.3s ease; font-size: 0.9rem; pointer-events: none; /* Prevent interaction */ }
          .toast-notification.error { background-color: #ef4444; }
          .toast-notification.show { opacity: 1; transform: translateX(-50%) translateY(0); }
          html.dark-mode .toast-notification { background-color: #059669; color: #f0fdf4; }
          html.dark-mode .toast-notification.error { background-color: #dc2626; color: #fef2f2; }

        /* Hidden Color Input */
        #connector-color-picker {
            visibility: hidden;
            width: 0;
            height: 0;
            position: absolute;
            left: -100px;
        }


        /* Mobile Adjustments */
        @media (max-width: 768px) {
            :root {
                --sidebar-width: 220px;
            }
            .header {
                padding: 0.6rem 1rem;
                min-height: 60px;
            }
            .logo { font-size: 1.2rem; }
             .toolbar .btn span { display: none; }
             .toolbar .btn { padding: 0.6rem; }
             .toolbar .btn i { font-size: 1.1rem; margin: 0; }
             .toolbar { gap: 0.3rem; }

            #sidebar-toggle { display: inline-flex; } /* Show toggle */
            .sidebar {
                position: absolute;
                top: 0;
                left: 0;
                transform: translateX(-100%);
                height: 100%; /* Ensure full height */
                max-height: calc(100vh - var(--header-height)); /* Adjust max height */
                top: var(--header-height); /* Position below header */
                z-index: 15;
                border-right: 1px solid var(--border);
                box-shadow: var(--shadow-lg);
                overflow-y: auto; /* Ensure scrollable if content overflows */
            }
            .sidebar.open {
                transform: translateX(0);
            }

            .controls {
                bottom: 0.8rem;
                right: 0.8rem;
                padding: 0.4rem;
            }
             .control-btn { width: 38px; height: 38px; }
             .mini-tooltip::after { display: none; } /* Hide tooltips on mobile */

             .modal-content { max-width: 95%; padding: 1rem; }
             .modal-title { font-size: 1.1rem; }
             .modal-footer { margin-top: 1rem; }
        }

    </style>
</head>
<body>
    <div class="header">
        <div class="logo">
            <i class="fas fa-brain"></i>
            <span>Mind Map</span>
        </div>
        <div class="toolbar">
             <!-- Sidebar Toggle Button -->
            <button id="sidebar-toggle" class="mini-tooltip" data-tooltip="Toggle Sidebar" aria-label="Toggle Sidebar">
                <i class="fas fa-bars"></i>
            </button>
            <!-- Theme Toggle Button -->
            <button id="theme-toggle" class="mini-tooltip" data-tooltip="Toggle Theme" aria-label="Toggle Theme">
                <i class="fas fa-sun"></i> <!-- Icon changes dynamically -->
            </button>
            <button id="new-node-btn" class="btn btn-primary mini-tooltip" data-tooltip="Add Root Node" aria-label="Add Root Node">
                <i class="fas fa-plus"></i>
                <span>Add Root</span>
            </button>
            <button id="save-btn" class="btn btn-secondary mini-tooltip" data-tooltip="Save to File" aria-label="Save to File">
                <i class="fas fa-save"></i>
                <span>Save</span>
            </button>
            <button id="load-btn" class="btn btn-secondary mini-tooltip" data-tooltip="Load from File" aria-label="Load from File">
                <i class="fas fa-folder-open"></i>
                <span>Load</span>
            </button>
        </div>
    </div>

    <div class="container">
        <div id="sidebar" class="sidebar" aria-label="Mind Map Structure Sidebar">
            <div class="sidebar-title">Mind Map Structure</div>
            <div id="structure-tree"></div>
        </div>
        <div class="canvas-container">
            <svg id="connector-svg" aria-hidden="true"></svg>
            <div id="canvas" role="application" aria-label="Mind Map Canvas"></div>
        </div>
    </div>

    <div class="controls" role="toolbar" aria-label="Canvas Controls">
        <button id="zoom-in" class="control-btn mini-tooltip" data-tooltip="Zoom In" aria-label="Zoom In">
            <i class="fas fa-search-plus"></i>
        </button>
        <button id="zoom-out" class="control-btn mini-tooltip" data-tooltip="Zoom Out" aria-label="Zoom Out">
            <i class="fas fa-search-minus"></i>
        </button>
        <button id="center-view" class="control-btn mini-tooltip" data-tooltip="Center View" aria-label="Center View">
            <i class="fas fa-compress-arrows-alt"></i>
        </button>
        <button id="fullscreen-toggle" class="control-btn mini-tooltip" data-tooltip="Toggle Fullscreen" aria-label="Toggle Fullscreen">
            <i class="fas fa-expand"></i> <!-- Icon changes dynamically -->
        </button>
    </div>

    <div id="node-modal" class="modal" role="dialog" aria-modal="true" aria-labelledby="modal-title-id">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="modal-title-id">Edit Node</h3>
                <button class="modal-close" title="Close" aria-label="Close">&times;</button>
            </div>
            <form id="node-form">
                <div class="form-group">
                    <label class="form-label" for="node-title">Title</label>
                    <input type="text" id="node-title" class="form-input" placeholder="Enter node title" required>
                </div>
                <div class="form-group">
                    <label class="form-label" for="node-content">Content (Optional)</label>
                    <textarea id="node-content" class="form-textarea" placeholder="Enter node content"></textarea>
                </div>
                <!-- Style Options -->
                <div style="display: flex; gap: 1rem; margin-bottom: 1rem;">
                    <div class="form-group" style="flex: 1;">
                        <label class="form-label" for="node-color">Node Color</label>
                        <input type="color" id="node-color" class="form-color" value="#ffffff" aria-label="Node Background Color">
                    </div>
                    <div class="form-group" style="flex: 2;">
                        <label class="form-label" for="node-shape">Node Shape</label>
                        <select id="node-shape" class="form-select">
                            <option value="rectangle">Rectangle</option>
                            <option value="rounded-rectangle">Rounded</option>
                            <option value="stadium">Stadium</option>
                            <option value="ellipse">Ellipse</option>
                        </select>
                    </div>
                </div>
                 <!-- End Style Options -->
                <div class="modal-footer">
                    <button type="button" id="cancel-node" class="btn btn-secondary">Cancel</button>
                    <button type="submit" id="save-node" class="btn btn-primary">Save</button>
                </div>
            </form>
        </div>
    </div>

    <div id="context-menu" class="contextmenu" role="menu" aria-label="Node Actions Menu">
        <div id="add-child-option" class="contextmenu-item" role="menuitem">
            <i class="fas fa-plus" aria-hidden="true"></i>
            <span>Add Child Node</span>
        </div>
        <div id="edit-node-option" class="contextmenu-item" role="menuitem">
            <i class="fas fa-edit" aria-hidden="true"></i>
            <span>Edit / Style Node</span>
        </div>
        <div id="change-connector-color-option" class="contextmenu-item" role="menuitem"> <!-- Initially hidden via CSS -->
             <i class="fas fa-palette" aria-hidden="true"></i>
             <span>Change Connector Color</span>
        </div>
        <div class="contextmenu-divider" role="separator"></div>
        <div id="delete-node-option" class="contextmenu-item danger" role="menuitem">
            <i class="fas fa-trash" aria-hidden="true"></i>
            <span>Delete Node</span>
        </div>
    </div>

    <!-- Hidden color input for connector -->
    <input type="color" id="connector-color-picker" aria-label="Connector Color Picker" style="visibility: hidden; position: absolute; left: -9999px;">

    <!-- Toast Notification Placeholder (dynamically created) -->
    <!-- <div class="toast-notification" role="alert">Message</div> -->

    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script>

        // --- Theme Helper (runs early) ---
        const themePrefKey = 'mindMapTheme';
        function applyTheme(theme) {
            const htmlEl = document.documentElement;
            const themeToggleBtn = document.getElementById('theme-toggle');
            const icon = themeToggleBtn?.querySelector('i');

            if (theme === 'dark') {
                htmlEl.classList.add('dark-mode');
                if (icon) icon.className = 'fas fa-moon'; // Show moon in dark mode
                 if (themeToggleBtn) themeToggleBtn.setAttribute('data-tooltip', 'Switch to Light Mode');
                 if (themeToggleBtn) themeToggleBtn.setAttribute('aria-label', 'Switch to Light Mode');
            } else {
                htmlEl.classList.remove('dark-mode');
                if (icon) icon.className = 'fas fa-sun'; // Show sun in light mode
                 if (themeToggleBtn) themeToggleBtn.setAttribute('data-tooltip', 'Switch to Dark Mode');
                 if (themeToggleBtn) themeToggleBtn.setAttribute('aria-label', 'Switch to Dark Mode');
            }
        }

        function getInitialTheme() {
            const savedTheme = localStorage.getItem(themePrefKey);
            if (savedTheme) return savedTheme;
            // Check system preference
            if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                return 'dark';
            }
            return 'light'; // Default to light
        }

        // Apply initial theme immediately
        applyTheme(getInitialTheme());
        // --- End Theme Helper ---


        class MindMap {
            constructor() {
                this.nodes = [];
                // Connections can now have an optional 'color' property
                this.connections = []; // Format: { from: id, to: id, color?: '#hex' }
                this.selectedNodeId = null;
                this.editingNodeId = null;
                this.nextId = 1;
                this.scale = 1;
                this.minScale = 0.1;
                this.maxScale = 3;
                this.offset = { x: 0, y: 0 };
                this.dragStart = { x: 0, y: 0 };
                this.isPanning = false;
                this.isMovingNode = false;
                this.nodeStartPos = { x: 0, y: 0 };
                this.isTouch = false;
                this.longPressTimeout = null;
                this.currentTheme = getInitialTheme(); // Track current theme
                this.isFullscreen = !!document.fullscreenElement; // Track fullscreen state

                 // Branch Colors
                 this.branchColors = [
                     '#fb7185', '#fdba74', '#d9f99d', '#a7f3d0',
                     '#a5f3fc', '#c7d2fe', '#fbcfe8', '#fca5a5',
                     '#fed7aa', '#bef264', '#86efac', '#67e8f9',
                     '#a78bfa', '#f9a8d4'
                 ];
                 // Default connector color will be read from CSS vars dynamically

                // DOM elements
                this.htmlEl = document.documentElement;
                this.container = document.querySelector('.container');
                this.sidebar = document.getElementById('sidebar');
                this.sidebarToggle = document.getElementById('sidebar-toggle');
                this.canvasContainer = document.querySelector('.canvas-container');
                this.canvas = document.getElementById('canvas');
                this.connectorSvg = document.getElementById('connector-svg');
                this.nodeModal = document.getElementById('node-modal');
                this.nodeForm = document.getElementById('node-form');
                this.modalTitle = this.nodeModal.querySelector('.modal-title');
                this.nodeTitleInput = document.getElementById('node-title');
                this.nodeContentInput = document.getElementById('node-content');
                this.nodeColorInput = document.getElementById('node-color');
                this.nodeShapeSelect = document.getElementById('node-shape');
                this.saveNodeBtn = document.getElementById('save-node');
                this.cancelNodeBtn = document.getElementById('cancel-node');
                this.newNodeBtn = document.getElementById('new-node-btn');
                this.contextMenu = document.getElementById('context-menu');
                this.addChildOption = document.getElementById('add-child-option');
                this.editNodeOption = document.getElementById('edit-node-option');
                this.changeConnectorColorOption = document.getElementById('change-connector-color-option');
                this.deleteNodeOption = document.getElementById('delete-node-option');
                this.connectorColorPicker = document.getElementById('connector-color-picker'); // Hidden input
                this.zoomInBtn = document.getElementById('zoom-in');
                this.zoomOutBtn = document.getElementById('zoom-out');
                this.centerViewBtn = document.getElementById('center-view');
                this.fullscreenToggleBtn = document.getElementById('fullscreen-toggle');
                this.themeToggleBtn = document.getElementById('theme-toggle');
                this.saveBtn = document.getElementById('save-btn');
                this.loadBtn = document.getElementById('load-btn');
                this.structureTree = document.getElementById('structure-tree');
                this.modalCloseBtn = this.nodeModal.querySelector('.modal-close');

                this.contextMenuNodeId = null;
                this.rootNodeMap = new Map(); // Maps node ID to its root node ID

                this.init();
            }

            // --- Initialization & Setup ---
            init() {
                console.log("MindMap Initializing...");
                this.setupEventListeners();
                this.updateFullscreenIcon(); // Set initial fullscreen icon state

                let loadedFromStorage = false;
                try {
                   loadedFromStorage = this.loadFromLocalStorage(); // Try loading data (now includes theme)
                } catch (error) {
                   console.error("Error loading from local storage during init:", error);
                   localStorage.removeItem('mindMapData'); // Clear potentially corrupt data
                   this.showToast('Error loading previous session. Starting fresh.', true);
                }

                // Apply loaded/initial theme (redundant with early script, but safe)
                applyTheme(this.currentTheme);

                if (!loadedFromStorage || this.nodes.length === 0) {
                    if (!loadedFromStorage) {
                        this.clearMap(false); // Clear map state, but keep view/theme
                        console.log("No valid data in localStorage or load failed.");
                    }
                    if (this.nodes.length === 0) {
                         console.log("Creating initial node.");
                         const initialX = this.canvasContainer.offsetWidth / 2;
                         const initialY = this.canvasContainer.offsetHeight / 3;
                         const initialNode = {
                             id: this.getNextId(),
                             title: 'Main Topic',
                             content: 'Right-click or Tap-hold',
                             x: 0, y: 0,
                             parentId: null,
                             color: getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff', // Use current theme's default
                             shape: 'rounded-rectangle'
                         };
                         this.addNode(initialNode);
                         // Initial offset to approximately center the first node
                         this.offset.x = initialX - (initialNode.x * this.scale);
                         this.offset.y = initialY - (initialNode.y * this.scale);
                         this.updateCanvasTransform();
                    }
                } else {
                    console.log(`Loaded ${this.nodes.length} nodes from localStorage. Creating DOM elements.`);
                    // Rebuild DOM from loaded data
                    const tempConnections = [...this.connections]; // Keep connections safe
                    this.connections = []; // Clear connections temporarily for correct parentId calculation

                    this.nodes.forEach(nodeData => {
                        const nodeElement = document.createElement('div');
                        nodeElement.className = 'node';
                        nodeElement.dataset.id = nodeData.id;
                        this.updateNodeElementContent(nodeElement, nodeData);
                        this.canvas.appendChild(nodeElement);
                        this.applyNodeStyle(nodeData, nodeElement); // Apply loaded style
                        this.updateNodeElementPosition(nodeData, nodeElement); // Apply loaded position
                    });
                    this.connections = tempConnections; // Restore connections
                }

                 // Final setup steps
                 this.buildRootNodeMap(); // Crucial for connector colors etc.
                 this.updateCanvasTransform(); // Apply loaded/initial transform
                 // applyAllNodeStyles might be redundant if styles applied during creation loop
                 this.updateConnections(); // Draw connections based on loaded data
                 this.updateStructureTree();
                 // Center view after elements are rendered and dimensions are known
                 requestAnimationFrame(() => this.centerView());
                 console.log("Initialization complete.");
            }

            setupEventListeners() {
                // --- Mouse Events ---
                this.canvasContainer.addEventListener('mousedown', this.handleInteractionStart.bind(this), false);
                // Add listeners to document to catch mouseup/mousemove outside the canvas
                document.addEventListener('mousemove', this.handleInteractionMove.bind(this), false);
                document.addEventListener('mouseup', this.handleInteractionEnd.bind(this), false);
                // Optional: Handle mouse leaving the window entirely
                // document.addEventListener('mouseleave', this.handleInteractionLeave.bind(this), false);

                // --- Touch Events ---
                // Use { passive: false } to allow preventDefault() for panning/zooming
                this.canvasContainer.addEventListener('touchstart', this.handleInteractionStart.bind(this), { passive: false });
                this.canvasContainer.addEventListener('touchmove', this.handleInteractionMove.bind(this), { passive: false });
                this.canvasContainer.addEventListener('touchend', this.handleInteractionEnd.bind(this), false);
                this.canvasContainer.addEventListener('touchcancel', this.handleInteractionEnd.bind(this), false); // Handle interruption

                // --- Context Menu ---
                this.canvasContainer.addEventListener('contextmenu', e => {
                    e.preventDefault(); // Prevent default browser context menu
                    // Only show custom menu on non-touch interactions (long press handles touch)
                    if (!this.isTouch) {
                        this.handleContextMenu(e);
                    }
                });

                // --- Node Modal Form Submission ---
                this.nodeForm.addEventListener('submit', (e) => {
                    e.preventDefault();
                    const title = this.nodeTitleInput.value.trim();
                    const content = this.nodeContentInput.value.trim();
                    const color = this.nodeColorInput.value;
                    const shape = this.nodeShapeSelect.value;

                    if (!title) {
                        this.showToast("Node title cannot be empty.", true);
                        return;
                    }

                    if (this.editingNodeId !== null) {
                        // Update existing node
                        const node = this.getNodeById(this.editingNodeId);
                        if (node) {
                            node.title = title; node.content = content; node.color = color; node.shape = shape;
                            const nodeElement = this.getNodeElement(node.id);
                            this.updateNodeElementContent(nodeElement, node);
                            this.applyNodeStyle(node, nodeElement);
                            this.updateConnections(); // Redraw connections (size might change)
                            this.updateStructureTree();
                            this.showToast("Node updated.");
                        }
                    } else {
                        // Add new node (either root or child)
                        let parentId = this.contextMenuNodeId; // Will be null if adding a root node
                        let position = this.calculateNewNodePosition(parentId);
                        const newNodeData = {
                            id: this.getNextId(), title, content,
                            x: position.x, y: position.y,
                            parentId: parentId, color, shape
                        };
                        this.addNode(newNodeData); // This handles connections, structure tree, etc.
                        this.showToast("Node added.");
                        // Note: addNode calls buildRootNodeMap and updateConnections
                    }
                    this.closeModal();
                    this.saveToLocalStorage();
                });

                // --- Modal Buttons ---
                this.cancelNodeBtn.addEventListener('click', () => this.closeModal());
                this.modalCloseBtn.addEventListener('click', () => this.closeModal());

                // --- Toolbar Buttons ---
                this.newNodeBtn.addEventListener('click', () => {
                    this.closeContextMenu();
                    this.contextMenuNodeId = null; // Explicitly set context to null (adding root)
                    this.editingNodeId = null; // Not editing
                    this.modalTitle.textContent = 'Add Root Node';
                    // Use current theme's default node color for new root nodes
                    const defaultNodeColor = getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff';
                    this.nodeColorInput.value = defaultNodeColor;
                    this.nodeShapeSelect.value = 'rounded-rectangle'; // Default shape
                    this.nodeTitleInput.value = ''; this.nodeContentInput.value = ''; // Clear fields
                    this.openModal();
                });
                this.saveBtn.addEventListener('click', () => this.saveToFile());
                this.loadBtn.addEventListener('click', () => this.loadFromFile());
                this.sidebarToggle.addEventListener('click', () => this.toggleSidebar());
                this.themeToggleBtn.addEventListener('click', () => this.toggleTheme());

                // --- Context Menu Options ---
                this.addChildOption.addEventListener('click', () => {
                    if (this.contextMenuNodeId !== null) {
                        this.editingNodeId = null; // We are adding, not editing
                        this.modalTitle.textContent = 'Add Child Node';
                        // Default child node style (e.g., color from parent, default shape)
                        const parentNode = this.getNodeById(this.contextMenuNodeId);
                        const defaultNodeColor = parentNode?.color || getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff';
                        this.nodeColorInput.value = defaultNodeColor;
                        this.nodeShapeSelect.value = 'rounded-rectangle';
                        this.nodeTitleInput.value = ''; this.nodeContentInput.value = '';
                        this.openModal(); // contextMenuNodeId is already set from context menu open
                        this.closeContextMenu();
                    } else {
                        console.warn("Add child called without context node ID.");
                    }
                });
                this.editNodeOption.addEventListener('click', () => {
                    if (this.contextMenuNodeId !== null) {
                        const node = this.getNodeById(this.contextMenuNodeId);
                        if (node) {
                            this.editingNodeId = this.contextMenuNodeId; // Set editing state
                            this.modalTitle.textContent = 'Edit / Style Node';
                            // Populate form with existing node data
                            this.nodeTitleInput.value = node.title;
                            this.nodeContentInput.value = node.content || '';
                            // Ensure default values are handled if loading old data without these fields
                            const defaultNodeColor = getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff';
                            this.nodeColorInput.value = node.color || defaultNodeColor;
                            this.nodeShapeSelect.value = node.shape || 'rounded-rectangle';
                            this.openModal();
                        } else {
                             console.warn("Edit called for non-existent node ID:", this.contextMenuNodeId);
                        }
                        this.closeContextMenu();
                    } else {
                        console.warn("Edit called without context node ID.");
                    }
                });
                 this.changeConnectorColorOption.addEventListener('click', () => {
                     if (this.contextMenuNodeId !== null) {
                         const node = this.getNodeById(this.contextMenuNodeId);
                         // Ensure the node exists and has a parent (only incoming connectors can have their color changed this way)
                         if (node && node.parentId !== null) {
                             // Find the specific connection object to get its current color
                             const connection = this.connections.find(c => c.from === node.parentId && c.to === node.id);
                             // Set current color on picker (use custom, fallback to branch, fallback to default CSS)
                              const defaultConnectorColor = getComputedStyle(this.htmlEl).getPropertyValue('--connector-default-color').trim() || '#cbd5e1';
                              const branchColor = this.getBranchColor(node.id);
                             this.connectorColorPicker.value = connection?.color || branchColor || defaultConnectorColor;
                             this.connectorColorPicker.click(); // Open browser's color picker
                         } else {
                            console.warn("Change connector color called for root node or non-existent node.");
                         }
                         this.closeContextMenu(); // Close menu after initiating color change
                     }
                 });
                 // Listener for the *hidden* color picker input changes
                this.connectorColorPicker.addEventListener('input', (e) => { // Use 'input' for live updates if picker supports it
                     if (this.contextMenuNodeId !== null) {
                         const node = this.getNodeById(this.contextMenuNodeId);
                         if (node && node.parentId !== null) {
                             let connection = this.connections.find(c => c.from === node.parentId && c.to === node.id);
                             if (connection) {
                                 connection.color = e.target.value; // Update connection color in our data
                                 this.updateConnections();        // Redraw connectors immediately
                                 this.saveToLocalStorage();       // Persist the change
                             } else { // Should not happen if option was visible, but handle defensively
                                 console.warn("Could not find connection to update color for node:", this.contextMenuNodeId);
                             }
                         }
                         // Do not clear contextMenuNodeId here, let the user finish picking.
                         // It will be cleared naturally on the next interaction start or context menu open.
                     }
                 });

                this.deleteNodeOption.addEventListener('click', () => {
                     if (this.contextMenuNodeId !== null) {
                         const nodeToDelete = this.getNodeById(this.contextMenuNodeId);
                         if (nodeToDelete) {
                            // Use a more user-friendly confirmation
                            const childrenCount = this.findNodeAndDescendants(this.contextMenuNodeId).length - 1;
                            const confirmationMessage = childrenCount > 0
                                ? `Delete node "${nodeToDelete.title}" and its ${childrenCount} descendant(s)?`
                                : `Delete node "${nodeToDelete.title}"?`;

                             if (confirm(confirmationMessage)) {
                                 this.deleteNode(this.contextMenuNodeId); // This handles redraw, state updates
                                 this.saveToLocalStorage();
                                 this.showToast("Node deleted.");
                             }
                         } else {
                            console.warn("Delete called for non-existent node ID:", this.contextMenuNodeId);
                         }
                         this.closeContextMenu();
                     } else {
                        console.warn("Delete called without context node ID.");
                     }
                 });


                // --- Controls ---
                this.zoomInBtn.addEventListener('click', () => { this.zoom(1.25); this.saveViewToLocalStorage(); });
                this.zoomOutBtn.addEventListener('click', () => { this.zoom(0.8); this.saveViewToLocalStorage(); });
                this.centerViewBtn.addEventListener('click', () => { this.centerView(true); /* centerView saves view state */ });
                this.fullscreenToggleBtn.addEventListener('click', () => this.toggleFullscreen());
                // Listen for fullscreen changes triggered by browser UI (e.g., Esc key)
                document.addEventListener('fullscreenchange', () => this.handleFullscreenChange());


                // --- Global Click/Tap Listener (for closing menus/modals) ---
                document.addEventListener('click', (e) => {
                    // Close context menu if click is outside it
                    if (this.contextMenu.style.display === 'block' && !this.contextMenu.contains(e.target)) {
                         this.closeContextMenu();
                    }
                    // Close modal if click is on the backdrop overlay
                    if (this.nodeModal.classList.contains('active') && e.target === this.nodeModal) {
                         this.closeModal();
                    }
                     // Close sidebar on mobile if click is outside it and the toggle button
                     if (window.innerWidth <= 768 && this.sidebar.classList.contains('open')) {
                         if (!this.sidebar.contains(e.target) && !this.sidebarToggle.contains(e.target)) {
                             this.toggleSidebar(false); // Explicitly close
                         }
                     }
                }, true); // Use capture phase to catch clicks early

                // --- Wheel Zoom ---
                this.canvasContainer.addEventListener('wheel', (e) => {
                    e.preventDefault(); // Prevent page scrolling
                    const zoomFactor = e.deltaY < 0 ? 1.1 : 0.9; // Zoom in/out based on scroll direction
                    const rect = this.canvasContainer.getBoundingClientRect();
                    // Calculate mouse position relative to the canvas container
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;
                    this.zoomAtPoint(zoomFactor, mouseX, mouseY); // Zoom centered on the mouse pointer
                    this.saveViewToLocalStorage(); // Persist view changes
                }, { passive: false }); // Need false to allow preventDefault

                // --- Keyboard Shortcuts ---
                document.addEventListener('keydown', (e) => {
                    // Don't trigger shortcuts if modal is active or if typing in an input/textarea
                    if (this.nodeModal.classList.contains('active') || ['INPUT', 'TEXTAREA'].includes(e.target.tagName)) {
                        return;
                    }

                    // Delete Node (Delete or Backspace key)
                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (this.selectedNodeId !== null) {
                             // Prevent default backspace navigation only if focus is not on input
                            if (e.target === document.body || e.target === this.canvasContainer) {
                                e.preventDefault();
                            }
                            const nodeToDelete = this.getNodeById(this.selectedNodeId);
                            if (nodeToDelete) {
                                const childrenCount = this.findNodeAndDescendants(this.selectedNodeId).length - 1;
                                const confirmationMessage = childrenCount > 0
                                    ? `Delete selected node "${nodeToDelete.title}" and its ${childrenCount} descendant(s)?`
                                    : `Delete selected node "${nodeToDelete.title}"?`;

                                if (confirm(confirmationMessage)) {
                                    this.deleteNode(this.selectedNodeId);
                                    this.saveToLocalStorage();
                                    this.showToast("Node deleted.");
                                }
                            }
                        }
                    }
                    // Escape Key (Close menus/modals, deselect, exit fullscreen)
                    if (e.key === 'Escape') {
                         if (this.contextMenu.style.display === 'block') {
                             this.closeContextMenu();
                         } else if (this.nodeModal.classList.contains('active')) {
                              this.closeModal();
                         } else if (this.selectedNodeId !== null) {
                              this.deselectNode();
                         } else if (this.isFullscreen) { // Also exit fullscreen on Escape
                            document.exitFullscreen().catch(err => console.error("Error exiting fullscreen:", err));
                         }
                    }
                    // Save (Ctrl/Cmd + S)
                    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                         e.preventDefault(); this.saveToFile();
                    }
                    // Load (Ctrl/Cmd + O)
                    if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                         e.preventDefault(); this.loadFromFile();
                    }
                    // Add Child (Tab or Insert on selected node?) - Future enhancement
                    // Edit Node (Enter or F2 on selected node?) - Future enhancement
                });

                 // --- Window Resize ---
                 // Use debouncing to avoid excessive calls during resize
                 let resizeTimeout;
                 window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(() => {
                        // Re-center view on resize to adapt layout
                        this.centerView();
                        // Close sidebar if window becomes larger than mobile breakpoint
                         if (window.innerWidth > 768 && this.sidebar.classList.contains('open')) {
                             this.toggleSidebar(false);
                         }
                    }, 150); // Adjust debounce delay as needed
                 });

                 // --- System Theme Changes ---
                 window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
                     // Only change if no explicit preference is saved in local storage
                     if (!localStorage.getItem(themePrefKey)) {
                         const newTheme = e.matches ? 'dark' : 'light';
                         this.currentTheme = newTheme;
                         applyTheme(newTheme); // Apply visual theme
                         this.applyAllNodeStyles(); // Re-apply styles (defaults might change)
                         this.updateConnections(); // Re-draw connectors (default color might change)
                     }
                 });
            }

            // --- Interaction Handlers ---
             handleInteractionStart(e) {
                this.isTouch = e.type.startsWith('touch');
                 if (this.isTouch) {
                    // Prevent default touch actions like scrolling/zooming while interacting with canvas
                    e.preventDefault();
                 }

                 this.closeContextMenu(); // Close any open context menu on new interaction
                 const interactionPos = this.getInteractionPosition(e);
                 // Use elementFromPoint to find the element under the cursor/touch
                 const targetElement = document.elementFromPoint(interactionPos.clientX, interactionPos.clientY);
                 const targetNodeElement = targetElement ? targetElement.closest('.node') : null;

                 // Long Press for Context Menu on Touch
                 if (this.isTouch) {
                     if(this.longPressTimeout) clearTimeout(this.longPressTimeout); // Clear previous timer
                     this.longPressTimeout = setTimeout(() => {
                         if (targetNodeElement) {
                              // Use the initial touch position for context menu
                              this.handleContextMenu(this.dragStart || interactionPos);
                         }
                         this.longPressTimeout = null; // Timer finished or cleared
                     }, 500); // 500ms for long press
                 }

                 if (targetNodeElement) {
                     // --- Start Moving Node ---
                     const nodeId = parseInt(targetNodeElement.dataset.id);
                     this.selectNode(nodeId); // Select the node being interacted with
                     this.isMovingNode = true;
                     this.isPanning = false;
                     const node = this.getNodeById(nodeId);
                     if (!node) { // Should not happen, but safety check
                         this.isMovingNode = false; return;
                     }
                     // Record starting positions
                     this.dragStart = { x: interactionPos.clientX, y: interactionPos.clientY };
                     this.nodeStartPos = { x: node.x, y: node.y };
                     // Update cursor styles
                     targetNodeElement.style.cursor = 'grabbing';
                     this.canvas.style.cursor = 'grabbing'; // Canvas cursor too
                     document.body.style.cursor = 'grabbing'; // Body cursor prevents flickering
                     // Stop propagation to prevent triggering panning on the canvas container
                     // e.stopPropagation(); // careful with stopping propagation

                 } else if (targetElement && (targetElement.closest('.controls') || targetElement.closest('.header') || targetElement.closest('.sidebar'))) {
                      // --- Interaction on Controls/Header/Sidebar ---
                      // Do nothing - allow default button actions etc.
                      this.isPanning = false;
                      this.isMovingNode = false;
                 } else {
                     // --- Start Panning Canvas ---
                     this.isPanning = true;
                     this.isMovingNode = false;
                     this.dragStart = { x: interactionPos.clientX, y: interactionPos.clientY };
                     // Update cursor styles
                     this.canvas.classList.add('grabbing');
                     document.body.style.cursor = 'grabbing';
                     this.deselectNode(); // Deselect any node when starting a pan
                 }
             }

            handleInteractionMove(e) {
                 // Only process move if panning or moving a node
                 if (!this.isPanning && !this.isMovingNode) return;
                 if (this.isTouch) {
                    e.preventDefault(); // Prevent scrolling page during drag/pan
                 }

                 const interactionPos = this.getInteractionPosition(e);
                 const dx = interactionPos.clientX - this.dragStart.x;
                 const dy = interactionPos.clientY - this.dragStart.y;

                 // Cancel long press timer if significant movement occurs
                 if (this.longPressTimeout && (Math.abs(dx) > 5 || Math.abs(dy) > 5)) {
                     clearTimeout(this.longPressTimeout);
                     this.longPressTimeout = null;
                 }

                 if (this.isMovingNode && this.selectedNodeId !== null) {
                     // --- Move Node ---
                     const node = this.getNodeById(this.selectedNodeId);
                     if (node) {
                         // Calculate position change in canvas coordinates (adjusting for scale)
                         const deltaX = dx / this.scale;
                         const deltaY = dy / this.scale;
                         // Update node's logical position
                         node.x = this.nodeStartPos.x + deltaX;
                         node.y = this.nodeStartPos.y + deltaY;
                         // Update node's visual position (transform)
                         this.updateNodeElementPosition(node);
                         // Update connectors continuously during drag for better feedback
                         this.updateConnections();
                     }
                 } else if (this.isPanning) {
                     // --- Pan Canvas ---
                     // Update canvas offset directly
                     this.offset.x += dx;
                     this.offset.y += dy;
                     // Update drag start position for the next move calculation
                     this.dragStart = { x: interactionPos.clientX, y: interactionPos.clientY };
                     // Apply the new transform to the canvas and SVG layer
                     this.updateCanvasTransform();
                 }
            }

            handleInteractionEnd(e) {
                 // Clear long press timer if interaction ends before it fires
                 if (this.longPressTimeout) {
                     clearTimeout(this.longPressTimeout);
                     this.longPressTimeout = null;
                 }

                 if (this.isMovingNode) {
                     // --- End Moving Node ---
                     this.isMovingNode = false;
                     // Reset cursor styles
                     const nodeElement = this.getNodeElement(this.selectedNodeId);
                     if(nodeElement) nodeElement.style.cursor = 'pointer';
                     this.canvas.style.cursor = 'grab';
                     document.body.style.cursor = 'default';
                     // Save the final node position
                     this.saveToLocalStorage();
                 }
                 if (this.isPanning) {
                     // --- End Panning ---
                     this.isPanning = false;
                     // Reset cursor styles
                     this.canvas.classList.remove('grabbing');
                     document.body.style.cursor = 'default';
                     // Save the final view state (offset, scale)
                     this.saveViewToLocalStorage();
                 }
                 // Reset isTouch flag (will be set again on next touchstart)
                 // this.isTouch = false; // Better to set at the start of interactions
            }

            // handleInteractionLeave(e) {
                 // Optional: If the mouse leaves the *window* during a drag/pan, treat it as an interaction end.
                 // if (!this.isTouch && (this.isMovingNode || this.isPanning)) {
                 //    console.log("Mouse left window during interaction, ending.");
                 //    this.handleInteractionEnd(e);
                 // }
            // }

            getInteractionPosition(e) {
                // Handles both MouseEvent and TouchEvent
                if (e.touches && e.touches.length > 0) {
                    // Use the first touch point for single-touch interactions
                    return { clientX: e.touches[0].clientX, clientY: e.touches[0].clientY };
                } else if (e.changedTouches && e.changedTouches.length > 0) {
                     // Useful for touchend/touchcancel events
                     return { clientX: e.changedTouches[0].clientX, clientY: e.changedTouches[0].clientY };
                }
                // Default to mouse event coordinates
                return { clientX: e.clientX, clientY: e.clientY };
            }

            handleContextMenu(pos) {
                // pos should be { clientX, clientY }
                 const targetElement = document.elementFromPoint(pos.clientX, pos.clientY);
                 const targetNodeElement = targetElement ? targetElement.closest('.node') : null;

                 if (targetNodeElement) {
                     // --- Context Menu on a Node ---
                     const nodeId = parseInt(targetNodeElement.dataset.id);
                     const node = this.getNodeById(nodeId);
                     if (!node) return; // Exit if node data not found

                     this.selectNode(nodeId); // Select the node being right-clicked/long-pressed
                     this.contextMenuNodeId = nodeId; // Store the ID for menu actions

                     // Show/Hide "Change Connector Color" based on whether the node has a parent
                     const hasParent = node.parentId !== null;
                     this.changeConnectorColorOption.style.display = hasParent ? 'flex' : 'none'; // Use flex for alignment

                     // Show the context menu at the interaction position
                     this.showContextMenu(pos.clientX, pos.clientY);
                 } else {
                     // --- Context Menu on Canvas Background ---
                     // Optional: Could have a context menu for the canvas itself (e.g., "Add Root Node", "Paste")
                     // For now, just close any existing menu and deselect node
                     this.contextMenuNodeId = null;
                     this.closeContextMenu();
                     this.deselectNode();
                 }
            }

            toggleSidebar(forceState) {
                 // forceState: true = open, false = close, undefined = toggle
                 const shouldOpen = typeof forceState === 'boolean' ? forceState : !this.sidebar.classList.contains('open');
                 this.sidebar.classList.toggle('open', shouldOpen);
                 // Update aria-expanded for accessibility
                 this.sidebarToggle.setAttribute('aria-expanded', shouldOpen.toString());
            }

            // --- ID Management, Coordinates, Node Helpers ---
            getNextId() { return this.nextId++; }

            screenToCanvasCoords(screenX, screenY) {
                 // Converts screen coordinates (e.g., mouse click) to canvas's internal coordinates
                 const rect = this.canvasContainer.getBoundingClientRect();
                 const canvasX = (screenX - rect.left - this.offset.x) / this.scale;
                 const canvasY = (screenY - rect.top - this.offset.y) / this.scale;
                 return { x: canvasX, y: canvasY };
            }
            getNodeById(id) { return this.nodes.find(n => n.id === id); }
            getNodeElement(nodeId) { return this.canvas.querySelector(`.node[data-id="${nodeId}"]`); }

            getParentId(nodeId) {
                 // Find the connection where this node is the 'to' target
                 const connection = this.connections.find(c => c.to === nodeId);
                 return connection ? connection.from : null; // Return parent ID or null if root/no connection found
            }

            // --- Node Management ---
            addNode(nodeData) {
                // Check if ID already exists (e.g., from loading data)
                if (this.getNodeById(nodeData.id)) {
                    console.warn(`Node with ID ${nodeData.id} already exists. Skipping add.`);
                    // Ensure nextId is higher than any existing ID
                    this.nextId = Math.max(this.nextId, nodeData.id + 1);
                    return; // Don't add duplicates
                }
                // Ensure nextId is correctly updated if adding with a specific ID
                 this.nextId = Math.max(this.nextId, nodeData.id + 1);

                // Ensure default values are set if missing
                const defaultNodeColor = getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff';
                nodeData.color = nodeData.color || defaultNodeColor;
                nodeData.shape = nodeData.shape || 'rounded-rectangle';
                // parentId should be passed correctly, default to null if undefined
                nodeData.parentId = nodeData.parentId !== undefined ? nodeData.parentId : null;

                // Add node data to the array
                this.nodes.push(nodeData);

                // Create DOM element for the node
                const nodeElement = document.createElement('div');
                nodeElement.className = 'node'; // Base class
                nodeElement.dataset.id = nodeData.id; // Store ID on the element
                nodeElement.setAttribute('role', 'treeitem'); // Accessibility role
                nodeElement.setAttribute('aria-label', nodeData.title); // Basic label

                this.updateNodeElementContent(nodeElement, nodeData); // Set inner HTML (title, content)
                this.applyNodeStyle(nodeData, nodeElement);          // Apply color and shape classes/styles
                this.updateNodeElementPosition(nodeData, nodeElement); // Set initial transform: translate
                this.canvas.appendChild(nodeElement);                // Add element to the canvas

                // Add connection if it's a child node
                if (nodeData.parentId !== null) {
                    const parentNode = this.getNodeById(nodeData.parentId);
                    if (parentNode) {
                         // Check if this connection already exists (e.g., during loading)
                         if (!this.connections.some(c => c.from === nodeData.parentId && c.to === nodeData.id)) {
                             // Add connection WITHOUT a custom color initially (will use branch/default)
                             this.connections.push({ from: nodeData.parentId, to: nodeData.id });
                         }
                    } else {
                         // Parent ID was specified but parent node doesn't exist - treat as root
                         console.warn(`Parent node ${nodeData.parentId} not found for new node ${nodeData.id}. Adding as root.`);
                         nodeData.parentId = null; // Correct the data
                    }
                }

                // Update internal state and UI
                this.buildRootNodeMap();    // Important for connector colors
                this.updateStructureTree(); // Update the sidebar tree view
                this.updateConnections();   // Draw/redraw connections including the new one
                this.selectNode(nodeData.id); // Select the newly added node

                // Animate the node appearance
                gsap.fromTo(nodeElement,
                    { scale: 0.5, opacity: 0 },
                    { scale: 1, opacity: 1, duration: 0.3, ease: "back.out(1.7)" });

                console.log(`Node added: ID=${nodeData.id}, Title='${nodeData.title}'`);
            }

            updateNodeElementContent(element, nodeData) {
                 if (!element) return;
                 // Sanitize title and content to prevent basic HTML injection
                 const safeTitle = nodeData.title ? nodeData.title.replace(/</g, "&lt;").replace(/>/g, "&gt;") : 'Untitled';
                 const safeContent = nodeData.content ? nodeData.content.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\n/g, '<br>') : '';

                 element.innerHTML = `
                     <div class="node-title">${safeTitle}</div>
                     ${safeContent ? `<div class="node-content">${safeContent}</div>` : ''}
                 `;
                 // Update ARIA label if title changed
                 element.setAttribute('aria-label', safeTitle);
            }

            applyNodeStyle(node, element = null) {
                 const targetElement = element || this.getNodeElement(node.id);
                 if (!targetElement) return;

                 // Get default node color for the current theme as a fallback
                 const defaultNodeColor = getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff';
                 // Set background color using CSS variable for consistency
                 targetElement.style.setProperty('--node-bg-color', node.color || defaultNodeColor);

                 // Manage shape classes
                 targetElement.classList.remove(
                    'node-shape-rectangle', 'node-shape-rounded-rectangle',
                    'node-shape-stadium', 'node-shape-ellipse'
                 );
                 targetElement.classList.add(`node-shape-${node.shape || 'rounded-rectangle'}`);
            }

            applyAllNodeStyles() {
                // Useful after theme change to ensure nodes reflect new defaults if they don't have custom colors
                this.nodes.forEach(node => this.applyNodeStyle(node));
            }

            updateNodeElementPosition(node, element = null) {
                const targetElement = element || this.getNodeElement(node.id);
                if (targetElement) {
                    // Use translate for positioning - generally better performance than top/left
                    targetElement.style.transform = `translate(${node.x}px, ${node.y}px)`;
                }
            }

            selectNode(nodeId) {
                 // Allow re-selecting the same node (e.g., to bring focus)
                 if (this.selectedNodeId !== nodeId) {
                     this.deselectNode(); // Deselect previously selected node first
                     this.selectedNodeId = nodeId;
                      console.log(`Node selected: ID=${nodeId}`);
                 } else {
                     // If clicking the already selected node, maybe do nothing or bring to front?
                 }

                 const element = this.getNodeElement(nodeId);
                 if (element) {
                      element.classList.add('selected');
                      element.setAttribute('aria-selected', 'true');
                      // Optional: Bring selected node visually to front if needed (can impact performance slightly)
                      // this.canvas.appendChild(element);
                 }
                 // Update the structure tree to reflect selection
                 this.updateStructureTreeSelection();
            }

            deselectNode() {
                 if (this.selectedNodeId !== null) {
                     const prevElement = this.getNodeElement(this.selectedNodeId);
                     if (prevElement) {
                         prevElement.classList.remove('selected');
                         prevElement.setAttribute('aria-selected', 'false');
                     }
                     console.log(`Node deselected: ID=${this.selectedNodeId}`);
                     this.selectedNodeId = null;
                     // Update the structure tree to reflect deselection
                     this.updateStructureTreeSelection();
                 }
            }

             updateStructureTreeSelection() {
                // Remove 'selected' from all tree nodes first
                this.structureTree.querySelectorAll('.tree-node.selected').forEach(el => {
                    el.classList.remove('selected');
                });
                // Add 'selected' to the currently selected node's tree element
                if (this.selectedNodeId !== null) {
                    const treeElement = this.structureTree.querySelector(`.tree-node[data-tree-id="${this.selectedNodeId}"]`);
                    if (treeElement) {
                        treeElement.classList.add('selected');
                        // Scroll the selected node into view within the sidebar
                        treeElement.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                    }
                }
             }


            deleteNode(nodeId) {
                const nodesToDeleteIds = this.findNodeAndDescendants(nodeId);
                if (nodesToDeleteIds.length === 0) {
                     console.warn("Attempted to delete non-existent node:", nodeId);
                     return;
                }
                console.log(`Deleting nodes: ${nodesToDeleteIds.join(', ')}`);

                // Animate and remove DOM elements
                nodesToDeleteIds.forEach(id => {
                    const element = this.getNodeElement(id);
                    if (element) {
                        gsap.to(element, {
                           scale: 0.5, opacity: 0, duration: 0.2,
                           onComplete: () => element.remove()
                        });
                    }
                    // Remove from root map cache
                    this.rootNodeMap.delete(id);
                });

                // Filter out deleted nodes and connections from data arrays
                this.nodes = this.nodes.filter(node => !nodesToDeleteIds.includes(node.id));
                this.connections = this.connections.filter(conn =>
                    !nodesToDeleteIds.includes(conn.from) && !nodesToDeleteIds.includes(conn.to)
                );

                // Clear selection if the selected node was deleted
                if (this.selectedNodeId !== null && nodesToDeleteIds.includes(this.selectedNodeId)) {
                    this.selectedNodeId = null;
                }
                // Clear context menu target if it was deleted
                 if (this.contextMenuNodeId !== null && nodesToDeleteIds.includes(this.contextMenuNodeId)) {
                     this.contextMenuNodeId = null;
                     this.closeContextMenu(); // Ensure menu is closed
                 }

                // Update UI
                this.updateConnections();   // Redraw connectors
                this.updateStructureTree(); // Rebuild sidebar tree
            }


            // --- Root Finding & Connections ---
             buildRootNodeMap() {
                 this.rootNodeMap.clear();
                 const parentMap = new Map(); // Map: childId -> parentId
                 this.connections.forEach(c => parentMap.set(c.to, c.from));

                 // Recursive function to find the ultimate root for a given node ID
                 const findRootRecursive = (currentId, visited = new Set()) => {
                     // 1. Check cache
                     if (this.rootNodeMap.has(currentId)) {
                         return this.rootNodeMap.get(currentId);
                     }
                     // 2. Detect loops
                     if (visited.has(currentId)) {
                         console.warn(`Loop detected involving node ${currentId}. Treating as root.`);
                         this.rootNodeMap.set(currentId, currentId); // Treat as its own root
                         return currentId;
                     }
                     visited.add(currentId); // Mark as visited for this path

                     // 3. Get parent
                     const parentId = parentMap.get(currentId);

                     // 4. Base case: No parent means it's a root
                     if (parentId === undefined || parentId === null) {
                         this.rootNodeMap.set(currentId, currentId);
                         return currentId;
                     }

                     // 5. Recursive step: Find the root of the parent
                     const rootId = findRootRecursive(parentId, visited);

                     // 6. Cache result for current node
                     this.rootNodeMap.set(currentId, rootId);
                     return rootId;
                 };

                 // Populate the map for all nodes
                 this.nodes.forEach(node => {
                     if (!this.rootNodeMap.has(node.id)) {
                         findRootRecursive(node.id, new Set()); // Start recursion for each potential root/branch
                     }
                 });
                 // console.log("Root map built:", this.rootNodeMap);
             }

             // Helper to get branch color based on root (used as fallback for connector color)
             getBranchColor(nodeId) {
                 const rootId = this.rootNodeMap.get(nodeId);
                 // Only assign branch colors to non-root nodes within a branch
                 if (rootId !== undefined && rootId !== nodeId && this.branchColors.length > 0) {
                     // Use a simple modulo hash of the root ID for consistent color assignment
                     // Use Math.abs to handle potential negative IDs if they ever occur
                     const colorIndex = Math.abs(rootId % this.branchColors.length);
                     return this.branchColors[colorIndex];
                 }
                 return null; // Return null if it's a root node or no colors defined
             }


             updateConnections() {
                 // Clear existing SVG lines
                 this.connectorSvg.innerHTML = '';

                 // Ensure root map is built (might be needed if called before init finishes)
                 if (this.rootNodeMap.size === 0 && this.nodes.length > 0) {
                     // console.warn("Root map empty, rebuilding before drawing connections.");
                     this.buildRootNodeMap();
                 }

                  // Get default connector color based on current theme CSS variable
                  const defaultColor = getComputedStyle(this.htmlEl).getPropertyValue('--connector-default-color').trim() || '#cbd5e1';

                 this.connections.forEach(conn => {
                     const fromNode = this.getNodeById(conn.from);
                     const toNode = this.getNodeById(conn.to);

                     if (fromNode && toNode) {
                         // Get the corresponding DOM elements
                         const fromElement = this.getNodeElement(fromNode.id);
                         const toElement = this.getNodeElement(toNode.id);

                         // Ensure elements exist and have dimensions before calculating connection points
                         if (fromElement && toElement && fromElement.offsetWidth > 0 && toElement.offsetWidth > 0) {
                             // Calculate center points of the nodes
                             const fromX = fromNode.x + fromElement.offsetWidth / 2;
                             const fromY = fromNode.y + fromElement.offsetHeight / 2;
                             const toX = toNode.x + toElement.offsetWidth / 2;
                             const toY = toNode.y + toElement.offsetHeight / 2;

                             // Determine connector color priority: Custom > Branch > Default
                             let color = conn.color || this.getBranchColor(toNode.id) || defaultColor;

                             // Create SVG line element
                             const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                             line.setAttribute('x1', fromX); line.setAttribute('y1', fromY);
                             line.setAttribute('x2', toX); line.setAttribute('y2', toY);
                             line.style.stroke = color; // Apply the determined color
                             // line.setAttribute('stroke', color); // Alternative way to set color
                             this.connectorSvg.appendChild(line);
                         } else {
                             // console.warn(`Skipping connection draw for ${conn.from}->${conn.to}: Elements not ready.`);
                         }
                     } else {
                        // console.warn(`Skipping connection draw for ${conn.from}->${conn.to}: Node data missing.`);
                     }
                 });
             }


             // --- Canvas Transformation, Zoom, Center ---
             updateCanvasTransform() {
                 // Apply the current offset and scale to both the node canvas and the SVG connector layer
                 const transform = `translate(${this.offset.x}px, ${this.offset.y}px) scale(${this.scale})`;
                 this.canvas.style.transform = transform;
                 this.connectorSvg.style.transform = transform; // Keep SVG layer synced
             }

             zoom(factor) {
                // Zooms towards the center of the canvas container
                 const rect = this.canvasContainer.getBoundingClientRect();
                 const centerX = rect.width / 2;
                 const centerY = rect.height / 2;
                 this.zoomAtPoint(factor, centerX, centerY);
             }

             zoomAtPoint(factor, screenX, screenY) {
                // Zooms towards a specific point on the screen (e.g., mouse cursor)
                 const newScale = Math.max(this.minScale, Math.min(this.maxScale, this.scale * factor));
                 // Don't zoom if already at min/max scale
                 if (newScale === this.scale) return;

                 // Calculate the canvas point corresponding to the screen point BEFORE zooming
                 const pointX_before = (screenX - this.offset.x) / this.scale;
                 const pointY_before = (screenY - this.offset.y) / this.scale;

                 // Calculate the new offset needed to keep the screen point stationary AFTER zooming
                 this.offset.x = screenX - pointX_before * newScale;
                 this.offset.y = screenY - pointY_before * newScale;

                 // Apply the new scale
                 this.scale = newScale;

                 // Update the visual transform
                 this.updateCanvasTransform();
             }

             centerView(userInitiated = false) {
                 if(this.nodes.length === 0){
                     // If no nodes, center the view at origin with scale 1
                     this.offset = { x: this.canvasContainer.offsetWidth / 2, y: this.canvasContainer.offsetHeight / 2 };
                     this.scale = 1;
                     if (userInitiated) {
                          gsap.to(this, {
                              scale: this.scale, offset: this.offset, duration: 0.4, ease: "power2.out",
                              onUpdate: () => this.updateCanvasTransform(),
                              onComplete: () => this.saveViewToLocalStorage() // Save after animation
                          });
                     } else {
                         this.updateCanvasTransform();
                         this.saveViewToLocalStorage(); // Save immediately if not animated
                     }
                     return;
                 }

                 // Calculate bounding box of all rendered nodes
                 let minX = Infinity, maxX = -Infinity, minY = Infinity, maxY = -Infinity;
                 let nodeCount = 0;

                 this.nodes.forEach(node => {
                     const element = this.getNodeElement(node.id);
                     // Only include nodes that are actually rendered and have dimensions
                     if(element && element.offsetWidth > 0 && element.offsetHeight > 0){
                         minX = Math.min(minX, node.x);
                         maxX = Math.max(maxX, node.x + element.offsetWidth);
                         minY = Math.min(minY, node.y);
                         maxY = Math.max(maxY, node.y + element.offsetHeight);
                         nodeCount++;
                     }
                 });

                 if(nodeCount === 0){ // If nodes exist but none are rendered yet, fallback
                      this.offset = { x: this.canvasContainer.offsetWidth / 2, y: this.canvasContainer.offsetHeight / 2 };
                      this.scale = 1;
                      this.updateCanvasTransform();
                      if(userInitiated) this.saveViewToLocalStorage(); // Save view if user initiated
                     return;
                 }

                 // Calculate dimensions and center of the bounding box
                 const nodesWidth = Math.max(maxX - minX, 200); // Ensure a minimum width/height
                 const nodesHeight = Math.max(maxY - minY, 100);
                 const nodesCenterX = minX + (maxX - minX) / 2;
                 const nodesCenterY = minY + (maxY - minY) / 2;

                 // Calculate required scale to fit the bounding box within the container viewport
                 const containerRect = this.canvasContainer.getBoundingClientRect();
                 const containerWidth = containerRect.width;
                 const containerHeight = containerRect.height;
                 // Add some padding around the edges
                 const padding = Math.min(containerWidth, containerHeight) * 0.1; // 10% padding

                 const scaleX = (containerWidth - padding * 2) / nodesWidth;
                 const scaleY = (containerHeight - padding * 2) / nodesHeight;
                 // Use the smaller scale factor to ensure everything fits, clamp within min/max/reasonable limits
                 const targetScale = Math.max(this.minScale, Math.min(this.maxScale, scaleX, scaleY, 1.2)); // Don't zoom in too much automatically

                 // Calculate offset to center the bounding box at the target scale
                 const targetOffsetX = containerWidth / 2 - nodesCenterX * targetScale;
                 const targetOffsetY = containerHeight / 2 - nodesCenterY * targetScale;

                 // Animate the transition if triggered by user action (button click)
                 if (userInitiated) {
                      gsap.to(this, {
                          scale: targetScale,
                          offset: { x: targetOffsetX, y: targetOffsetY },
                          duration: 0.4,
                          ease: "power2.out",
                          onUpdate: () => this.updateCanvasTransform(), // Update transform during animation
                          onComplete: () => this.saveViewToLocalStorage() // Save final state after animation
                      });
                 } else {
                      // Apply immediately if not user-initiated (e.g., on load, resize)
                      this.scale = targetScale;
                      this.offset.x = targetOffsetX;
                      this.offset.y = targetOffsetY;
                      this.updateCanvasTransform();
                      // Don't save view state here automatically for non-user actions like resize
                      // It will be saved by the specific action that triggered the centering (load, etc.)
                 }
             }


             // --- Modals & Menus ---
             openModal() {
                 this.nodeModal.classList.add('active');
                 this.nodeModal.setAttribute('aria-hidden', 'false');
                 // Set focus to the first input field shortly after opening
                 setTimeout(() => this.nodeTitleInput.focus(), 50);
             }
             closeModal() {
                 this.nodeModal.classList.remove('active');
                 this.nodeModal.setAttribute('aria-hidden', 'true');
                 this.nodeForm.reset(); // Reset form fields
                 // Reset color picker to current theme's default node bg
                 const defaultNodeColor = getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff';
                 this.nodeColorInput.value = defaultNodeColor;
                 // Clear editing state
                 this.editingNodeId = null;
                 this.contextMenuNodeId = null; // Clear context if modal was opened from context menu
                 console.log("Modal closed.");
             }
             showContextMenu(x, y) {
                 this.closeContextMenu(); // Close any existing menu first
                 this.contextMenu.style.display = 'block';
                 this.contextMenu.setAttribute('aria-hidden', 'false');

                 // Initial position
                 let adjustedX = x;
                 let adjustedY = y;
                 this.contextMenu.style.left = `${adjustedX}px`;
                 this.contextMenu.style.top = `${adjustedY}px`;

                 // Use requestAnimationFrame to ensure dimensions are calculated after display: block
                 requestAnimationFrame(() => {
                    const menuRect = this.contextMenu.getBoundingClientRect();
                    // Use window dimensions for boundary checks
                    const winWidth = window.innerWidth;
                    const winHeight = window.innerHeight;
                    const margin = 10; // Small margin from window edges

                    // Adjust position if menu goes off-screen
                    if (menuRect.right > winWidth - margin) {
                         adjustedX = x - menuRect.width; // Shift left
                    }
                    if (menuRect.bottom > winHeight - margin) {
                         adjustedY = y - menuRect.height; // Shift up
                    }
                    // Prevent going off top/left edges
                    if (adjustedX < margin) adjustedX = margin;
                    if (adjustedY < margin) adjustedY = margin;

                    // Apply adjusted position
                    this.contextMenu.style.left = `${adjustedX}px`;
                    this.contextMenu.style.top = `${adjustedY}px`;

                    // Optional: Focus the first item for keyboard navigation
                    // const firstItem = this.contextMenu.querySelector('[role="menuitem"]');
                    // if (firstItem) firstItem.focus();
                 });
             }
             closeContextMenu() {
                 if (this.contextMenu.style.display === 'block') {
                      this.contextMenu.style.display = 'none';
                      this.contextMenu.setAttribute('aria-hidden', 'true');
                      // Important: Don't clear contextMenuNodeId here if the color picker might be open.
                      // It's needed by the color picker's 'change'/'input' event.
                      // It gets cleared naturally on the next interaction or modal close/submit.
                 }
             }


            // --- Structure Tree ---
             updateStructureTree() {
                 this.structureTree.innerHTML = ''; // Clear previous tree
                 this.structureTree.setAttribute('role', 'tree'); // ARIA role

                 // Build a map of nodes with children arrays
                 const nodesMap = new Map();
                 this.nodes.forEach(node => {
                     nodesMap.set(node.id, { ...node, children: [] });
                 });

                 // Populate children arrays based on connections
                 this.connections.forEach(conn => {
                     const parentNode = nodesMap.get(conn.from);
                     const childNode = nodesMap.get(conn.to);
                     if(parentNode && childNode){
                        // Ensure parentId matches connection (consistency check)
                        childNode.parentId = conn.from;
                        parentNode.children.push(childNode);
                     }
                 });

                 // Find root nodes (nodes not present as 'to' in any connection)
                 const childIds = new Set(this.connections.map(conn => conn.to));
                 const rootNodes = this.nodes
                     .filter(node => !childIds.has(node.id))
                     .map(node => nodesMap.get(node.id)) // Get the object with children array
                     .sort((a, b) => a.title.localeCompare(b.title)); // Sort roots alphabetically

                 // Recursively create and append tree elements
                 rootNodes.forEach(node => {
                     const treeElement = this.createTreeElement(node);
                     if (treeElement) this.structureTree.appendChild(treeElement);
                 });

                 // Update selection highlighting in the newly built tree
                 this.updateStructureTreeSelection();
             }

             createTreeElement(node) {
                 if (!node) return null;

                 const container = document.createElement('div');
                 container.setAttribute('role', 'treeitem'); // Role for the container
                 container.setAttribute('aria-labelledby', `tree-node-label-${node.id}`);

                 const nodeElement = document.createElement('div');
                 nodeElement.classList.add('tree-node');
                 nodeElement.id = `tree-node-label-${node.id}`; // ID for aria-labelledby
                 nodeElement.dataset.treeId = node.id; // Store node ID for click handling
                 nodeElement.textContent = node.title || 'Untitled';
                 nodeElement.title = node.title; // Tooltip for potentially truncated text

                 // Add click listener to select node and scroll canvas
                 nodeElement.addEventListener('click', (e) => {
                     e.stopPropagation(); // Prevent clicks bubbling to parent tree items
                     this.selectNode(node.id);
                     this.scrollToNode(node.id);
                      // Close sidebar on mobile after selection
                      if (window.innerWidth <= 768 && this.sidebar.classList.contains('open')) {
                          this.toggleSidebar(false);
                      }
                 });
                 container.appendChild(nodeElement);

                 // Recursively add children if any
                 if (node.children && node.children.length > 0) {
                     const childrenContainer = document.createElement('div');
                     childrenContainer.classList.add('tree-children');
                     childrenContainer.setAttribute('role', 'group'); // Role for children group

                     node.children
                         .sort((a, b) => a.title.localeCompare(b.title)) // Sort children alphabetically
                         .forEach(child => {
                             const childElement = this.createTreeElement(child);
                             if (childElement) childrenContainer.appendChild(childElement);
                         });
                     container.appendChild(childrenContainer);
                     container.setAttribute('aria-expanded', 'true'); // Assume expanded for now
                 } else {
                     container.setAttribute('aria-expanded', 'false');
                 }

                 return container;
             }

              scrollToNode(nodeId) {
                // Scrolls the canvas view to center the specified node
                 const node = this.getNodeById(nodeId);
                 const element = this.getNodeElement(nodeId);
                 if (!node || !element || element.offsetWidth === 0) {
                     console.warn("Cannot scroll to node: Node data or element not found/ready.", nodeId);
                     return; // Cannot scroll if node or element is missing/not rendered
                 }

                 const containerRect = this.canvasContainer.getBoundingClientRect();
                 const nodeWidth = element.offsetWidth;
                 const nodeHeight = element.offsetHeight;

                 // Calculate the desired center point of the node in canvas coordinates
                 const targetX = node.x + nodeWidth / 2;
                 const targetY = node.y + nodeHeight / 2;

                 // Calculate the offset needed to place this point at the center of the viewport
                 // Target Offset = Viewport Center - (Node Center * Scale)
                 const desiredOffsetX = containerRect.width / 2 - targetX * this.scale;
                 const desiredOffsetY = containerRect.height / 2 - targetY * this.scale;

                 // Animate the transition to the new offset
                 gsap.to(this.offset, {
                     x: desiredOffsetX,
                     y: desiredOffsetY,
                     duration: 0.4, // Animation duration
                     ease: "power2.out", // Easing function
                     onUpdate: () => this.updateCanvasTransform(), // Update transform during animation
                     onComplete: () => this.saveViewToLocalStorage() // Save view state after animation completes
                 });
             }

            // --- New Node Position Calculation ---
              calculateNewNodePosition(parentId) {
                 const parentNode = parentId !== null ? this.getNodeById(parentId) : null;
                 const parentElement = parentId !== null ? this.getNodeElement(parentId) : null;

                 if(parentNode && parentElement && parentElement.offsetWidth > 0) {
                     // --- Calculate Position Relative to Parent ---
                     const parentWidth = parentElement.offsetWidth;
                     const parentHeight = parentElement.offsetHeight;

                     // Base spacing (adjust as needed) - use larger values for more space
                     const baseSpacingX = 200;
                     const baseSpacingY = 60;
                     // Adjust spacing based on current zoom scale (more space when zoomed out)
                     const spacingX = baseSpacingX / this.scale;
                     const spacingY = baseSpacingY / this.scale;

                     // Find existing children of the parent, sorted by Y position
                     const children = this.connections
                         .filter(c => c.from === parentId)
                         .map(c => ({ node: this.getNodeById(c.to), element: this.getNodeElement(c.to) }))
                         // Filter out children that might not be rendered yet or have no dimensions
                         .filter(data => data.node && data.element && data.element.offsetHeight > 0)
                         .sort((a,b) => a.node.y - b.node.y); // Sort by current Y position

                     // Default X position: to the right of the parent
                     let targetX = parentNode.x + parentWidth + spacingX;
                     let targetY;

                     if (children.length > 0) {
                         // Place below the lowest existing child
                         const lastChild = children[children.length - 1];
                         targetY = lastChild.node.y + lastChild.element.offsetHeight + spacingY;
                     } else {
                         // First child: Place roughly vertically aligned with the parent's center
                         // Estimate new node height (use parent's height as a proxy or a default)
                         const newNodeApproxHeight = parentHeight > 0 ? parentHeight : 60; // Default height if parent not rendered
                         targetY = parentNode.y + parentHeight / 2 - newNodeApproxHeight / 2;
                     }
                     return { x: targetX, y: targetY };

                 } else {
                     // --- Calculate Position for Root Node (or Orphan) ---
                     // Find approximate center of the current view in canvas coordinates
                     const screenCenter = {
                         x: this.canvasContainer.offsetWidth / 2,
                         y: this.canvasContainer.offsetHeight / 3 // Place slightly higher than true center
                     };
                     const canvasCoords = this.screenToCanvasCoords(screenCenter.x, screenCenter.y);

                     // Add slight random offset to prevent stacking if multiple roots are added quickly
                     const randomOffsetX = (Math.random() - 0.5) * 50 / this.scale;
                     const randomOffsetY = (Math.random() - 0.5) * 50 / this.scale;

                     // Check if this position overlaps significantly with existing root nodes
                     // (Simple check: find nearby nodes - could be more sophisticated)
                     const overlapThreshold = 150 / this.scale; // Radius to check for overlap
                     let positionOK = false;
                     let attempts = 0;
                     let finalX = canvasCoords.x + randomOffsetX;
                     let finalY = canvasCoords.y + randomOffsetY;

                     while (!positionOK && attempts < 10) {
                         positionOK = true;
                         for (const node of this.nodes) {
                              if (node.parentId === null) { // Check against other root nodes
                                   const dist = Math.sqrt(Math.pow(node.x - finalX, 2) + Math.pow(node.y - finalY, 2));
                                   if (dist < overlapThreshold) {
                                        // Try shifting position
                                        finalX += (Math.random() - 0.5) * 100 / this.scale;
                                        finalY += (Math.random() - 0.5) * 100 / this.scale;
                                        positionOK = false;
                                        attempts++;
                                        break; // Re-check all roots with new position
                                   }
                              }
                         }
                     }

                     return { x: finalX, y: finalY };
                 }
             }

            // --- Persistence ---
            saveToFile() {
                try {
                    // Create a clean data object for saving
                    // Ensure parentId is correctly derived from connections just before saving
                    this.nodes.forEach(n => {
                       n.parentId = this.getParentId(n.id); // Recalculate parentId from connections
                    });

                    const data = {
                        nodes: this.nodes,
                        connections: this.connections, // Includes optional connector colors
                        nextId: this.nextId,
                        view: { offset: this.offset, scale: this.scale }, // Save current view
                        theme: this.currentTheme // Save theme preference
                    };
                    const dataStr = JSON.stringify(data, null, 2); // Pretty print JSON
                    const blob = new Blob([dataStr], { type: 'application/json;charset=utf-8' }); // Specify charset

                    // Use File System Access API if available (more modern, asks for save location)
                    if ('showSaveFilePicker' in window) {
                        window.showSaveFilePicker({
                           suggestedName: `mindmap-${new Date().toISOString().slice(0,10)}.json`,
                           types: [{ description: 'Mind Map JSON', accept: {'application/json': ['.json']} }],
                        }).then(handle => handle.createWritable())
                          .then(writable => {
                              writable.write(blob).then(() => {
                                 writable.close();
                                 this.showToast('Mind map saved successfully!');
                              });
                          }).catch(err => {
                              // Handle errors, e.g., user cancellation
                              if (err.name !== 'AbortError') {
                                   console.error('Error saving file via File System Access API:', err);
                                   this.showToast('Error saving mind map!', true);
                              } else {
                                   console.log('File save cancelled by user.');
                              }
                          });
                    } else {
                        // Fallback to traditional download link method
                        const url = URL.createObjectURL(blob);
                        const exportLink = document.createElement('a');
                        exportLink.href = url;
                        exportLink.download = `mindmap-${new Date().toISOString().slice(0,10)}.json`;
                        document.body.appendChild(exportLink);
                        exportLink.click();
                        document.body.removeChild(exportLink);
                        URL.revokeObjectURL(url); // Clean up blob URL
                        this.showToast('Mind map download started!');
                    }
                } catch (error) {
                     console.error('Error preparing mind map data for saving:', error);
                     this.showToast('Error preparing data for saving!', true);
                }
            }

            loadFromFile() {
                 // Use File System Access API if available (more modern)
                 if ('showOpenFilePicker' in window) {
                     window.showOpenFilePicker({
                         types: [{ description: 'Mind Map JSON', accept: {'application/json': ['.json']} }],
                         multiple: false
                     }).then(([fileHandle]) => fileHandle.getFile())
                       .then(file => file.text())
                       .then(jsonString => this.processLoadedData(jsonString))
                       .catch(err => {
                            if (err.name !== 'AbortError') {
                                console.error('Error loading file via File System Access API:', err);
                                this.showToast('Error loading file!', true);
                            } else {
                                console.log('File open cancelled by user.');
                            }
                       });
                 } else {
                     // Fallback to traditional input element method
                     const input = document.createElement('input');
                     input.type = 'file';
                     input.accept = '.json,application/json';
                     input.onchange = e => {
                         const file = e.target.files[0];
                         if (!file) return;
                         const reader = new FileReader();
                         reader.onload = event => {
                             this.processLoadedData(event.target.result);
                         };
                         reader.onerror = () => {
                             this.showToast('Error reading file!', true);
                             console.error('FileReader error:', reader.error);
                         };
                         reader.readAsText(file);
                     };
                     input.click(); // Programmatically trigger the file input
                 }
            }

            processLoadedData(jsonString) {
                 try {
                     const data = JSON.parse(jsonString);

                     // --- Basic Data Validation ---
                     if (!data || typeof data !== 'object') throw new Error("Invalid file content: Not an object.");
                     if (!Array.isArray(data.nodes)) throw new Error("Invalid format: Missing 'nodes' array.");
                     if (!Array.isArray(data.connections)) throw new Error("Invalid format: Missing 'connections' array.");
                     if (typeof data.nextId !== 'number' || data.nextId < 1) throw new Error("Invalid format: Missing or invalid 'nextId'.");

                     console.log(`File content parsed. Nodes: ${data.nodes.length}, Connections: ${data.connections.length}`);

                     // --- Load Data and Rebuild ---
                     this.clearMap(false); // Clear current state but keep theme/view initially

                     // Load core data
                     this.nodes = data.nodes || [];
                     this.connections = data.connections || [];
                     this.nextId = data.nextId || 1;
                     // Load theme preference, default to light if missing/invalid
                     this.currentTheme = (data.theme === 'dark' || data.theme === 'light') ? data.theme : 'light';
                     applyTheme(this.currentTheme); // Apply loaded theme visually

                     // Load view state, use defaults if missing/invalid
                     if (data.view && data.view.offset && typeof data.view.offset.x === 'number' && typeof data.view.offset.y === 'number' && typeof data.view.scale === 'number') {
                         this.offset = data.view.offset;
                         this.scale = Math.max(this.minScale, Math.min(this.maxScale, data.view.scale)); // Clamp scale
                     } else {
                         this.offset = { x: 0, y: 0 }; this.scale = 1; // Default view
                         console.warn("View data missing or invalid in loaded file, using defaults.");
                     }

                     // --- Data Sanitization & Defaulting ---
                      const defaultNodeColor = getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff';
                      const nodeIds = new Set(this.nodes.map(n => n.id)); // Get all valid node IDs from the loaded set

                      // Sanitize Nodes
                      this.nodes.forEach(node => {
                         // Ensure basic fields exist
                         node.title = node.title || 'Untitled';
                         node.content = node.content || '';
                         node.x = typeof node.x === 'number' ? node.x : 0;
                         node.y = typeof node.y === 'number' ? node.y : 0;
                         // Sanitize/default style properties
                         node.color = node.color && /^#[0-9a-fA-F]{6}$/.test(node.color) ? node.color : defaultNodeColor;
                         node.shape = ['rectangle', 'rounded-rectangle', 'stadium', 'ellipse'].includes(node.shape) ? node.shape : 'rounded-rectangle';
                         // Validate parentId based *only* on the loaded nodes
                         if (node.parentId !== undefined && node.parentId !== null && !nodeIds.has(node.parentId)) {
                              console.warn(`Node ${node.id} has invalid parentId ${node.parentId} (not found in loaded nodes). Setting parentId to null.`);
                              node.parentId = null; // Make it a root node if parent is missing
                         } else {
                             node.parentId = node.parentId !== undefined ? node.parentId : null; // Ensure it's null if not set
                         }
                      });

                     // Sanitize Connections
                     this.connections = this.connections.filter(conn => {
                         const fromExists = nodeIds.has(conn.from);
                         const toExists = nodeIds.has(conn.to);
                         if (!fromExists || !toExists) {
                             console.warn(`Removing invalid connection (node missing): ${conn.from} -> ${conn.to}`);
                             return false; // Remove connection if either node doesn't exist
                         }
                         // Validate custom color format if it exists
                         if (conn.color && !/^#[0-9a-fA-F]{6}$/.test(conn.color)) {
                             console.warn(`Invalid color format "${conn.color}" for connection ${conn.from} -> ${conn.to}. Removing custom color.`);
                             delete conn.color; // Remove invalid color, will fallback to default/branch
                         }
                         return true;
                     });

                     // Ensure parentId in node data matches the validated connections (Final consistency check)
                      const connectionParentMap = new Map(this.connections.map(c => [c.to, c.from])); // Map: childId -> parentId from connections
                      this.nodes.forEach(node => {
                          const actualParentId = connectionParentMap.get(node.id) ?? null;
                          if (node.parentId !== actualParentId) {
                              // console.warn(`Correcting node.parentId mismatch for node ${node.id}. Was ${node.parentId}, connection indicates ${actualParentId}.`);
                              node.parentId = actualParentId; // Trust the connection data after filtering
                          }
                      });

                     // --- Rebuild DOM Elements ---
                     this.canvas.innerHTML = ''; // Clear existing DOM nodes
                     this.nodes.forEach(nodeData => {
                        const nodeElement = document.createElement('div');
                        nodeElement.className = 'node';
                        nodeElement.dataset.id = nodeData.id;
                        nodeElement.setAttribute('role', 'treeitem');
                        this.updateNodeElementContent(nodeElement, nodeData);
                        this.canvas.appendChild(nodeElement);
                        this.applyNodeStyle(nodeData, nodeElement);
                        this.updateNodeElementPosition(nodeData, nodeElement);
                     });

                     // --- Finalize UI Update ---
                     this.buildRootNodeMap();       // Rebuild root map based on loaded connections
                     this.updateCanvasTransform();  // Apply loaded view transform
                     this.updateConnections();      // Draw connectors for loaded data
                     this.updateStructureTree();    // Rebuild sidebar tree
                     requestAnimationFrame(() => this.centerView(false)); // Center view after rendering (don't treat as user action)

                     this.showToast('Mind map loaded successfully!');
                     this.saveToLocalStorage(); // Save the successfully loaded map + theme to local storage

                 } catch (error) {
                     console.error('Error processing loaded mind map data:', error);
                     this.showToast(`Error loading file: ${error.message}`, true);
                     // Optionally: Revert to a clean state or previous state if load fails badly
                     this.clearMap(); // Clear potentially corrupted state
                     this.init(); // Re-initialize an empty map
                 }
             }


             saveToLocalStorage() {
                 // Saves the entire current state (nodes, connections, view, theme)
                 try {
                      // Ensure parentId is up-to-date before saving
                      this.nodes.forEach(n => {
                          n.parentId = this.getParentId(n.id);
                      });
                     const data = {
                         nodes: this.nodes,
                         connections: this.connections, // Includes optional connector colors
                         nextId: this.nextId,
                         view: { offset: this.offset, scale: this.scale }, // Current view state
                         theme: this.currentTheme // Current theme
                     };
                     localStorage.setItem('mindMapData', JSON.stringify(data));
                     // console.log("Saved state to localStorage");
                 } catch (error) {
                     console.error("Error saving to localStorage:", error);
                     // Consider informing the user if storage quota might be exceeded
                     if (error.name === 'QuotaExceededError') {
                          this.showToast('Local storage full. Could not save changes.', true);
                     } else {
                          this.showToast('Could not save changes locally.', true);
                     }
                 }
             }

             saveViewToLocalStorage() {
                // Saves only the view state (offset, scale) to avoid rewriting all node data on pan/zoom
                  try {
                      const currentDataStr = localStorage.getItem('mindMapData');
                      let data = {};
                      if (currentDataStr) {
                           // Attempt to parse existing data
                           try {
                               data = JSON.parse(currentDataStr);
                               // Ensure it looks like our data structure, otherwise start fresh
                               if (!data || typeof data !== 'object' || !Array.isArray(data.nodes)) {
                                   console.warn("Invalid data found in localStorage while saving view. Overwriting with full state.");
                                   data = {}; // Reset data object
                               }
                           } catch (parseError) {
                                console.error("Error parsing localStorage data while saving view. Overwriting.", parseError);
                                data = {}; // Reset on parse error
                           }
                      }

                      // Ensure basic structure exists if we loaded partial/invalid data or started fresh
                      if (!data.nodes) data.nodes = this.nodes;
                      if (!data.connections) data.connections = this.connections;
                      if (!data.nextId) data.nextId = this.nextId;
                      if (!data.theme) data.theme = this.currentTheme;

                      // Update only the view part
                      data.view = { offset: this.offset, scale: this.scale };

                      // Save the updated data back to localStorage
                      localStorage.setItem('mindMapData', JSON.stringify(data));
                      // console.log("Saved VIEW to localStorage");
                  } catch (error) {
                      console.error("Error saving view state to localStorage:", error);
                      // Don't show toast for view state saving errors, could be too noisy
                  }
             }


             loadFromLocalStorage() {
                 // Loads the entire state from local storage on initial page load
                 try {
                     const savedData = localStorage.getItem('mindMapData');
                     if (savedData) {
                         const data = JSON.parse(savedData); // Can throw error if invalid JSON

                         // --- Basic Validation ---
                         if (!data || typeof data !== 'object' || !Array.isArray(data.nodes) || !Array.isArray(data.connections) || typeof data.nextId !== 'number') {
                             console.error("Invalid data structure found in localStorage. Clearing it.");
                             localStorage.removeItem('mindMapData');
                             return false; // Indicate load failed
                         }

                         // --- Load Core Data (Validation happens later in init/process) ---
                         this.nodes = data.nodes;
                         this.connections = data.connections; // Includes potential custom colors
                         this.nextId = data.nextId;
                         // Load theme preference, default to light if missing/invalid
                         this.currentTheme = (data.theme === 'dark' || data.theme === 'light') ? data.theme : getInitialTheme(); // Use initial theme as fallback

                         // Load view state, use defaults if missing/invalid
                         if (data.view && data.view.offset && typeof data.view.offset.x === 'number' && typeof data.view.offset.y === 'number' && typeof data.view.scale === 'number') {
                             this.offset = data.view.offset;
                             // Clamp scale loaded from storage
                             this.scale = Math.max(this.minScale, Math.min(this.maxScale, data.view.scale));
                         } else {
                              // Don't reset view here, keep potentially existing view state from constructor
                              console.warn("View data missing or invalid in localStorage.");
                         }

                         // --- Perform Sanitization & Consistency Checks ---
                         // (Similar logic as in processLoadedData, adapted slightly)
                         const defaultNodeColor = getComputedStyle(this.htmlEl).getPropertyValue('--node-bg-color').trim() || '#ffffff';
                         const nodeIds = new Set(this.nodes.map(n => n.id));

                         this.nodes.forEach(n => {
                             n.color = n.color && /^#[0-9a-fA-F]{6}$/.test(n.color) ? n.color : defaultNodeColor;
                             n.shape = ['rectangle', 'rounded-rectangle', 'stadium', 'ellipse'].includes(n.shape) ? n.shape : 'rounded-rectangle';
                             n.parentId = n.parentId !== undefined ? n.parentId : null;
                             if (n.parentId !== null && !nodeIds.has(n.parentId)) {
                                 n.parentId = null; // Orphan node if parent doesn't exist in loaded data
                             }
                         });

                         this.connections = this.connections.filter(conn => {
                             const fromExists = nodeIds.has(conn.from);
                             const toExists = nodeIds.has(conn.to);
                             if (!fromExists || !toExists) return false; // Remove invalid connections
                             if (conn.color && !/^#[0-9a-fA-F]{6}$/.test(conn.color)) {
                                  delete conn.color; // Remove invalid custom colors
                             }
                             return true;
                         });

                         // Ensure node.parentId matches filtered connections
                         const connectionParentMap = new Map(this.connections.map(c => [c.to, c.from]));
                         this.nodes.forEach(node => {
                              node.parentId = connectionParentMap.get(node.id) ?? null;
                         });

                         console.log(`Loaded ${this.nodes.length} nodes from localStorage.`);
                         return true; // Success
                     }
                 } catch (error) {
                     // Handle JSON parsing errors or other issues
                     console.error("Error loading from localStorage:", error);
                     localStorage.removeItem('mindMapData'); // Clear corrupted data
                 }
                 return false; // No data or error occurred
             }

            clearMap(clearViewAndTheme = true) {
                 console.log("Clearing map state.");
                 this.nodes = [];
                 this.connections = [];
                 this.selectedNodeId = null;
                 this.contextMenuNodeId = null;
                 this.editingNodeId = null;
                 this.nextId = 1;
                 // Clear DOM elements
                 this.canvas.innerHTML = '';
                 this.connectorSvg.innerHTML = '';
                 this.structureTree.innerHTML = '';
                 this.rootNodeMap.clear();
                 // Optionally reset view and theme
                 if (clearViewAndTheme) {
                    this.offset = { x: 0, y: 0 };
                    this.scale = 1;
                    this.currentTheme = getInitialTheme(); // Reset to initial/system theme
                    applyTheme(this.currentTheme);
                    this.updateCanvasTransform(); // Apply reset view
                 }
                 console.log("Map cleared.");
            }

            // --- UI Feedback ---
            showToast(message, isError = false) {
                // Remove any existing toast first
                const existingToast = document.querySelector('.toast-notification');
                if (existingToast) existingToast.remove();

                // Create new toast element
                const toast = document.createElement('div');
                toast.className = 'toast-notification';
                toast.setAttribute('role', 'alert'); // Accessibility
                if (isError) toast.classList.add('error');
                toast.textContent = message;
                document.body.appendChild(toast);

                // Animate toast in
                requestAnimationFrame(() => {
                    toast.classList.add('show');
                });

                // Set timeout to remove toast
                setTimeout(() => {
                    toast.classList.remove('show');
                    // Remove element from DOM after fade out transition completes
                    toast.addEventListener('transitionend', () => {
                         // Check if it's still in the DOM before removing
                         if (toast.parentNode) {
                             toast.remove();
                         }
                     }, { once: true }); // Ensure listener runs only once
                }, 3000); // Display duration (3 seconds)
            }

            // --- Helper: Find Node and Descendants ---
            findNodeAndDescendants(startNodeId) {
                 // Performs a breadth-first search (BFS) to find all reachable nodes starting from startNodeId
                 const resultIds = [];
                 const node = this.getNodeById(startNodeId);
                 if (!node) return resultIds; // Return empty if start node doesn't exist

                 const queue = [startNodeId]; // Initialize queue with the starting node
                 const visited = new Set();   // Keep track of visited nodes to prevent infinite loops
                 visited.add(startNodeId);    // Mark start node as visited

                 while (queue.length > 0) {
                     const currentId = queue.shift(); // Dequeue the next node ID
                     resultIds.push(currentId);       // Add it to the results

                     // Find direct children of the current node
                     this.connections.forEach(conn => {
                         if (conn.from === currentId) {
                             const childId = conn.to;
                             // Check if child exists and hasn't been visited yet
                             if (this.getNodeById(childId) && !visited.has(childId)) {
                                 visited.add(childId); // Mark child as visited
                                 queue.push(childId);  // Enqueue child for processing
                             }
                         }
                     });
                 }
                 return resultIds; // Return array of IDs including the startNodeId and all descendants
             }

             // --- Theme Toggle ---
             toggleTheme() {
                const newTheme = this.currentTheme === 'light' ? 'dark' : 'light';
                this.currentTheme = newTheme;
                applyTheme(newTheme); // Apply visually (updates CSS vars, icons)
                localStorage.setItem(themePrefKey, newTheme); // Save user preference
                // Re-apply node styles and redraw connections in case default colors changed
                this.applyAllNodeStyles();
                this.updateConnections();
                this.saveToLocalStorage(); // Save the theme change with the rest of the data
                console.log(`Theme changed to ${newTheme}`);
                this.showToast(`Switched to ${newTheme} mode.`);
             }

             // --- Fullscreen Toggle ---
             toggleFullscreen() {
                if (!document.fullscreenElement) {
                    // Enter fullscreen
                    this.htmlEl.requestFullscreen()
                        .then(() => console.log("Entered fullscreen"))
                        .catch(err => {
                             console.error(`Error attempting to enable full-screen mode: ${err.message} (${err.name})`);
                             this.showToast('Could not enter fullscreen.', true);
                         });
                } else {
                    // Exit fullscreen
                    if (document.exitFullscreen) {
                        document.exitFullscreen()
                            .then(() => console.log("Exited fullscreen"))
                            .catch(err => {
                                console.error(`Error attempting to disable full-screen mode: ${err.message} (${err.name})`);
                                this.showToast('Could not exit fullscreen.', true);
                            });
                    }
                }
             }

             handleFullscreenChange() {
                // Update internal state and icon when fullscreen changes (e.g., via Esc key)
                this.isFullscreen = !!document.fullscreenElement;
                this.updateFullscreenIcon();
                console.log(`Fullscreen state changed: ${this.isFullscreen}`);
                // Optional: Recenter view slightly after fullscreen change? Might be jarring.
                // requestAnimationFrame(() => this.centerView());
             }

             updateFullscreenIcon() {
                 const icon = this.fullscreenToggleBtn?.querySelector('i');
                 const tooltipTarget = this.fullscreenToggleBtn; // Button itself has the tooltip attribute now
                 if (!icon || !tooltipTarget) return;

                 if (this.isFullscreen) {
                     icon.className = 'fas fa-compress'; // Show compress icon when fullscreen
                     tooltipTarget.setAttribute('data-tooltip', 'Exit Fullscreen');
                     tooltipTarget.setAttribute('aria-label', 'Exit Fullscreen');
                 } else {
                     icon.className = 'fas fa-expand'; // Show expand icon when not fullscreen
                     tooltipTarget.setAttribute('data-tooltip', 'Enter Fullscreen');
                     tooltipTarget.setAttribute('aria-label', 'Enter Fullscreen');
                 }
             }

        } // End MindMap Class

        // --- Initialize ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing Mind Map.");
            // Ensure initial theme is applied *before* initializing MindMap which might rely on CSS vars
            applyTheme(getInitialTheme());
            // Create the MindMap instance
            window.mindMapInstance = new MindMap();
        });

    </script>
</body>
</html>
```