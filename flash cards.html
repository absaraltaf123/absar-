<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>ABS Flashcards System</title>
  <!-- Elegant font from Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500&display=swap" rel="stylesheet">
  <!-- MathJax for LaTeX rendering -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script>
    // Verify D3.js is loaded
    window.addEventListener('load', function() {
      if (typeof d3 === 'undefined') {
        console.error('D3.js is not loaded properly');
      }
    });
  </script>
 <style>
    /* Header Styling */
    header {
      text-align: center;
      margin-bottom: 20px;
    }
    header h1 {
      font-size: 2.5em;
      margin: 3;
      color: #8b8888;
     
     
   

    }

    @keyframes glow {
      0% { text-shadow: 0 0 10px rgba(255, 154, 158, 0.8); }
      100% { text-shadow: 0 0 20px rgba(255, 154, 158, 1); }
    }

    /* Global Styles */
    body {
      font-family: 'Poppins', sans-serif;
      background: linear-gradient(135deg, #d3caca, #a6c1ee);
      margin: 0;
      padding: 40px;
      display: flex;
      flex-direction: column;
      align-items: center;
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* Enhanced Controls */
    .controls {
      display: flex;
      gap: 15px;
      margin-bottom: 30px;
      flex-wrap: wrap;
      justify-content: center;
      background: linear-gradient(135deg, 
        #FFF0F5, #FCE4EC, #F8BBD0, #F48FB1, #F06292, #EC407A
      );
      padding: 20px;
      border-radius: 15px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
    }

    .controls input[type="text"],
    .controls select {
      padding: 12px 18px;
      border: 2px solid rgba(102, 126, 234, 0.2);
      border-radius: 8px;
      font-size: 16px;
      transition: all 0.3s ease;
      background: linear-gradient(135deg, 
        #FFFFFF, #FAFAFA, #F5F5F5, #EEEEEE, #E0E0E0, #BDBDBD
      );
    }

    .controls input[type="text"]:focus,
    .controls select:focus {
      border-color: #ff6f61;
      box-shadow: 0 0 15px rgba(255, 111, 97, 0.5);
    }

    .controls button {
      padding: 12px 24px;
      background: linear-gradient(135deg, 
        #2C003E, #4A006F, #6A0099, #9C27B0, #D32F2F, #FF6F61
      );
      border: none;
      border-radius: 8px;
      color: #efff;
      font-size: 16px;
      cursor: pointer;
      transition: transform 0.3s, box-shadow 0.3s;
      letter-spacing: 0.5px;
    }

    .controls button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(255, 111, 97, 0.4);
    }

    /* Flashcards Container */
    .flashcard-container {
      display: flex;
      flex-wrap: wrap;
      gap: 25px;
      justify-content: center;
      width: 100%;
      max-width: 1200px;
      padding: 20px;
    }

    /* Flashcard Styling */
    .flashcard {
      min-width: 340px;
      min-height: 240px;
      max-width: 400px;
      width: auto;
      height: auto;
      perspective: 1000px;
      position: relative;
      cursor: pointer;
      margin: 15px;
      flex: 1 1 auto;
      transition: transform 0.3s ease, box-shadow 0.3s ease;
    }

    

    .flashcard-inner {
      position: relative;
      width: 100%;
      height: 100%;
      min-height: 180px;
      transition: transform 0.8s;
      transform-style: preserve-3d;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.12);
      border-radius: 10px;
      background: linear-gradient(135deg, #ffffff, #ffffff);
    }

    .flashcard.flipped .flashcard-inner {
      transform: rotateY(180deg);
    }

    .flashcard-front,
    .flashcard-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 10px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px 20px;
      box-sizing: border-box;
      font-family: 'Poppins', 'Playfair Display', serif;
      font-size: 18px;
      text-align: center;
      overflow-y: auto;
    }
    .flashcard-front > *,
 /* Keep front side centered but make back side start from top */
 .flashcard-back {
      justify-content: flex-start;
      text-align: left;
      padding-top: 20px;
    }
    
    .flashcard-front {
      background: linear-gradient(135deg, 
        #c8cdcd, #ebd7e8
      );
      color: #381818;
    }

    .flashcard-back {
      background: linear-gradient( #b7b0c0, #dcb2b2);
      color: #000000;
      transform: rotateY(180deg);
    }

    /* Note Card Styling */
    .flashcard.note {
      min-width: 400px;
      min-height: 300px;
    }
    .flashcard.note .flashcard-back {
      background: linear-gradient(135deg, #efe3be, #7a7171);
      color: #000000;
      transform: rotateY(180deg);
    }

    /* Edit Mode Styling */
    /* Add this to your existing CSS */
.edit-mode {
  background: linear-gradient(135deg, #ffffff, #f5f5f5);
  border-radius: 9px;
  padding: 20px;
  box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
  width: 100%;
  box-sizing: border-box;
  /* Add transition for smooth animation */
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  
  height: 100%;
  overflow: hidden;
  opacity: 0;
  padding: 0 20px;
}

/* Class added after mounting to trigger animation */
.edit-mode.expanded {
  max-height: 1000px; /* Large enough to accommodate all content */
  opacity: 1;
  padding: 20px;
}

.edit-mode input,
.edit-mode textarea {
  width: 100%;
  padding: 12px;
  margin-bottom: 15px;
  border: 2px solid #e0e0e0;
  border-radius: 8px;
  font-size: 14px;
  transition: all 0.3s ease;
  box-sizing: border-box;
  background: #ffffff;
}

.edit-mode textarea {
  min-height: 100px;
  resize: vertical;
}

.edit-mode input:focus,
.edit-mode textarea:focus {
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  outline: none;
}

.edit-mode .button-group {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

.edit-mode .save-btn,
.edit-mode .cancel-btn {
  padding: 10px 20px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  flex: 1;
}

.edit-mode .save-btn {
  background: linear-gradient(135deg, #667eea, #764ba2);
  color: white;
}

.edit-mode .cancel-btn {
  background: linear-gradient(135deg, #ff6b6b, #ff4757);
  color: white;
}

.edit-mode .save-btn:hover,
.edit-mode .cancel-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

.edit-mode .subcards-section {
  margin-top: 20px;
  padding-top: 20px;
  border-top: 2px solid #e0e0e0;
}

.edit-mode .subcards-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.edit-mode .add-subcard-btn {
  padding: 8px 16px;
  background: linear-gradient(135deg, #48bb78, #38a169);
  color: white;
  border: none;
  border-radius: 6px;
  cursor: pointer;
  transition: all 0.3s ease;
}

.edit-mode .add-subcard-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 12px rgba(72, 187, 120, 0.2);
}

    /* Delete & Edit Buttons */
    .delete-btn,
    .edit-btn {
      position: absolute;
      top: 12px;
      width: 28px;
      height: 28px;
      border: none;
      border-radius: 50%;
      font-size: 18px;
      cursor: pointer;
      opacity: 0;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 2;
    }

    .delete-btn {
      right: 12px;
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      box-shadow: 0 2px 8px rgba(255, 107, 107, 0.3);
      color: #fff;
    }

    .edit-btn {
      right: 48px;
      background: linear-gradient(135deg, 
        #E3F2FD, #BBDEFB, #90CAF9, #64B5F6, #42A5F5, #2196F3
      );
      box-shadow: 0 2px 8px rgba(255, 193, 7, 0.3);
      color: #fff;
    }

    .flashcard:hover .delete-btn,
    .flashcard:hover .edit-btn {
      opacity: 1;
      transform: scale(1.1);
    }

    /* Subcards Container Styling */
    .subcards-container {
      margin-top: 10px;
      padding: 10px;
      background: linear-gradient(135deg, #f093fb, #f5576c);
      border-radius: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    /* Subcard Styling */
    .flashcard.subcard {
      min-width: 200px;
      min-height: 140px;
      max-width: 300px;
      position: relative;
      border: 2px solid transparent;
      border-radius: 10px;
      background-clip: padding-box;
      cursor: pointer;
      perspective: 800px;
    }
    .flashcard.subcard::before {
      content: "";
      position: absolute;
      top: -2px;
      left: -2px;
      right: -2px;
      bottom: -2px;
      z-index: -1;
      background: linear-gradient(135deg, #6a11cb, #2575fc);
      border-radius: 12px;
    }
    .flashcard.subcard .flashcard-back {
      background: linear-gradient(135deg, #ff9a9e, #fad0c4);
      color: #fff;
    }

    /* Modal Styling for Subcards */
    #subcardsModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 2000;
      backdrop-filter: blur(10px);
    }
    #subcardsModal .modal-content {
      background: #fff;
      padding: 20px;
      border-radius: 10px;
      max-width: 80%;
      max-height: 80%;
      overflow-y: auto;
      position: relative;
      animation: fadeInScale 0.4s ease-out;
    }
    .close-modal {
      position: absolute;
      top: 10px;
      right: 10px;
      background: #dc3545;
      color: #fff;
      border: none;
      border-radius: 50%;
      width: 30px;
      height: 30px;
      font-size: 16px;
      cursor: pointer;
    }
    .modal-subcards-container {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      justify-content: center;
      margin-top: 40px;
    }

    /* Modal Styling for Expanded Note */
    #noteModal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.5);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 3000;
      backdrop-filter: blur(10px);
    }
    #noteModal .modal-content {
      background: linear-gradient(135deg, 
        #FFFFFF, #FAFAFA, #F5F5F5, #EEEEEE, #E0E0E0, #BDBDBD
       
        );
        color: #000;
      padding: 40px;
      border-radius: 10px;
      max-width: 90%;
      max-height: 90%;
      overflow-y: auto;
      position: relative;
      animation: fadeInScale 0.4s ease-out;
    }
    
    /* Edit Panel Modal for Fullscreen Mode */
    #editPanelModal {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 200%;
      background: rgba(0,0,0,0.7);
      display: none;
      justify-content: center left;
      align-items: center right;
     
      

      z-index: 10000;
      backdrop-filter: blur(30px);
      opacity: 0;
      transition: opacity 0.3s ease-out;
    }
    
    #editPanelModal.active {
      opacity: 1;
    }
    
    .edit-panel-content {
  background: rgba(254, 253, 250, 0.95);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 30px;
  width: 90%;
  max-width: 600px;
  position: absolute;
  top: 10%;
  left: 30%;
  transform: translate(-50%, -50%);
  z-index: 10055;
  color: #333;
  box-shadow: 0 15px 40px rgba(0, 0, 0, 0.3);
}
    
    #editPanelModal.active .edit-panel-content {
      transform: scale(1);
    }
    
    #editPanelModal .edit-panel-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid rgba(0, 0, 0, 0.1);
    }
    
    #editPanelModal .edit-panel-title {
      font-size: 24px;
      font-weight: 600;
      color: #333;
      margin: 0;
    }
    
    #editPanelModal .close-edit-panel {
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      color: white;
      border: none;
      border-radius: 50%;
      width: 36px;
      height: 36px;
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
    }
    
    #editPanelModal .close-edit-panel:hover {
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(255, 107, 107, 0.6);
    }
    
    #editPanelModal .edit-panel-form {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    #editPanelModal .form-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    
    #editPanelModal .form-group label {
      font-weight: 500;
      color: #555;
      font-size: 14px;
    }
    
    #editPanelModal .form-group input,
    #editPanelModal .form-group textarea {
      padding: 12px 15px;
      border: 2px solid #e0e0e0;
      border-radius: 10px;
      font-size: 16px;
      transition: all 0.3s ease;
      background: #ffffff;
    }
    
    #editPanelModal .form-group textarea {
      min-height: 150px;
      resize: vertical;
    }
    
    #editPanelModal .form-group input:focus,
    #editPanelModal .form-group textarea:focus {
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      outline: none;
    }
    
    #editPanelModal .button-group {
      display: flex;
      gap: 15px;
      margin-top: 10px;
    }
    
    #editPanelModal .save-btn,
    #editPanelModal .cancel-btn {
      padding: 12px 25px;
      border: none;
      border-radius: 10px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.3s ease;
      flex: 1;
    }
    
    #editPanelModal .save-btn {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
    }
    
    #editPanelModal .cancel-btn {
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      color: white;
    }
    
    #editPanelModal .save-btn:hover,
    #editPanelModal .cancel-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
    }
    
    #editPanelModal .subcards-section {
      margin-top: 30px;
      padding-top: 20px;
      border-top: 2px solid #e0e0e0;
    }
    
    #editPanelModal .subcards-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    #editPanelModal .subcards-container {
      display: flex;
      flex-wrap: wrap;
      gap: 15px;
      margin-top: 15px;
    }

    /* Keyframes for smooth fade-in/scale animation */
    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.95);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Footer Styling */
 

    
    /* ===== Toggle Button ===== */
   
    /* ===== Side Panel Container ===== */
    
    /* Fullscreen overlay animations */
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }
    #fullscreenOverlay.fadeIn {
      animation: fadeIn 0.5s ease-out;
    }
    #fullscreenOverlay.fadeOut {
      animation: fadeOut 0.5s ease-out;
    }

    .practice-deck-wrapper {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(13, 27, 42, 0.9);
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 4000;
      backdrop-filter: blur(10px);
    }
    .practice-deck-wrapper.active {
      opacity: 1;
      pointer-events: auto;
    }
    .practice-deck {
      position: relative;
      height: 450px;
      width: 100%;
      max-width: 700px;
      margin: auto;
      perspective: 2000px;
      overflow: visible;
      transform: translateY(-100px) translateX(50px) scale(0.98);
      transition: transform 0.5s ease;
    }

    /* Toggle Button - modified to be fixed at top right */
    #modeSwitchBtn {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 5000;
      margin-bottom: 20px;
      padding: 10px 15px;
      background-color: #28a745;
      color: #fff;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
    }
    #modeSwitchBtn:hover {
      background-color: #218838;
    }

    /* Flashcard Styles */
    .practice-card {
      position: absolute;
      width: 320px;
      height: 610px;
      transform-style: preserve-3d;
      transition: transform 0.6s ease, box-shadow 0.6s ease;
      border-radius: 20px;
      background: linear-gradient(145deg, #1b263b, #415a77);
      box-shadow: 0 15px 35px rgba(0, 0, 0, 0.5);
      cursor: pointer;
      outline: none;
    }

    .practice-card.active {
      z-index: 10;
      transform: translateZ(50px) scale(1.05);
    }

    .practice-card-face {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      border-radius: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 30px;
      text-align: center;
    }

    .practice-card-front {
      background: linear-gradient(145deg, #778da9, #e0e1dd);
      color: #0d1b2a;
      font-size: 1.5rem;
      font-family: 'Roboto Slab', serif;
    }

    .practice-card-back {
      background: linear-gradient(145deg, #415a77, #1b263b);
      color: #e0e1dd;
      transform: rotateY(180deg);
      font-size: 1.3rem;
      font-family: 'Roboto Slab', serif;
    }

    /* Controls & Close Button */
    .practice-controls {
      position: absolute;
      bottom: 20px;
      display: flex;
      gap: 20px;
    }
    .practice-controls .control-btn {
      padding: 12px 25px;
      font-size: 1rem;
      font-family: 'Open Sans', sans-serif;
      background: #778da9;
      color: #0d1b2a;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
    }

    .practice-controls .control-btn:hover {
      background: #e0e1dd;
      transform: translateY(-5px);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
    }

    .practice-controls .control-btn:focus {
      outline: 2px solid #e0e1dd;
      outline-offset: 2px;
    }

    .practice-close-btn {
      position: absolute;
      top: 20px;
      right: 20px;
      padding: 12px 25px;
      font-size: 1rem;
      font-family: 'Open Sans', sans-serif;
      background: #ff4757;
      color: white;
      border: none;
      border-radius: 50px;
      cursor: pointer;
      transition: transform 0.3s ease, background 0.3s ease, box-shadow 0.3s ease;
    }

    .practice-close-btn:hover {
      background: #ff6b81;
      transform: translateY(-5px);
      box-shadow: 0 8px 15px rgba(0, 0, 0, 0.3);
    }

    /* Controls Panel Styling */
    .input-panel {
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin-bottom: 30px;
  padding: 30px;
  background: linear-gradient(135deg, #6b46c1, #805ad5);
  border-radius: 20px;
  box-shadow: 
    0 10px 30px rgba(107, 70, 193, 0.2),
    inset 0 -2px 6px rgba(255, 255, 255, 0.1);
  backdrop-filter: blur(10px);
  max-width: 600px;
  width: 100%;
  position: relative;
  overflow: hidden;
  transition: all 0.4s ease-in-out;
  border: 1px solid rgba(255, 255, 255, 0.12);
}

/* Animated background effect */
.input-panel::before {
  content: '';
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
  animation: shimmer 10s infinite linear;
}

/* Additional decorative elements */
.input-panel::after {
  content: '';
  position: absolute;
  bottom: -50px;
  right: -50px;
  width: 150px;
  height: 150px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
  z-index: 0;
}

/* Particle effect elements */
.input-panel .particle {
  position: absolute;
  width: 6px;
  height: 6px;
  border-radius: 50%;
  background-color: rgba(255, 255, 255, 0.4);
  pointer-events: none;
}

.input-panel .particle:nth-child(1) {
  top: 20%;
  left: 10%;
  animation: float 8s infinite ease-in-out;
}

.input-panel .particle:nth-child(2) {
  top: 30%;
  right: 15%;
  width: 8px;
  height: 8px;
  animation: float 12s infinite ease-in-out;
}

.input-panel .particle:nth-child(3) {
  bottom: 25%;
  left: 20%;
  width: 4px;
  height: 4px;
  animation: float 10s infinite ease-in-out;
}

.input-panel .particle:nth-child(4) {
  bottom: 15%;
  right: 25%;
  animation: float 14s infinite ease-in-out;
}

.input-panel .particle:nth-child(5) {
  top: 45%;
  left: 35%;
  width: 5px;
  height: 5px;
  animation: floatReverse 11s infinite ease-in-out;
}

/* Enhanced styling for inputs */
.input-panel input {
  padding: 15px 20px;
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: 12px;
  height: 50px;
  background: rgba(255, 255, 255, 0.12);
  color: white;
  font-size: 16px;
  transition: all 0.3s ease;
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.1),
    0 0 0 transparent;
  width: 100%;
  outline: none;
  position: relative;
  z-index: 1;
  backdrop-filter: blur(5px);
  letter-spacing: 0.3px;
}

.input-panel input::placeholder {
  color: rgba(255, 255, 255, 0.5);
  transition: all 0.3s ease;
}

.input-panel input:focus {
  border-color: rgba(255, 255, 255, 0.3);
  box-shadow: 
    inset 0 2px 4px rgba(0, 0, 0, 0.1),
    0 0 20px rgba(255, 255, 255, 0.1);
  transform: translateY(-2px);
}

.input-panel input:focus::placeholder {
  opacity: 0.7;
  transform: translateX(5px);
}

/* Textarea styling */
.input-panel input[id="answer"] {
  height: 150px;
  resize: vertical;
  min-height: 150px;
  max-height: 300px;
  font-family: inherit;
  line-height: 1.5;
  transition: height 0.3s ease, min-height 0.3s ease;
}

.input-panel input[id="answer"]:focus {
  min-height: 180px;
}

/* Label styling */
.input-panel label {
  color: rgba(255, 255, 255, 0.9);
  margin-bottom: 5px;
  font-weight: 500;
  font-size: 14px;
  text-transform: uppercase;
  letter-spacing: 1px;
  display: block;
  position: relative;
  z-index: 1;
  transition: all 0.3s ease;
  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
}

/* Form group styling */
.input-panel .form-group {
  position: relative;
  margin-bottom: 10px;
}

.input-panel .form-group:hover label {
  color: white;
  transform: translateX(3px);
}

/* Add floating decorative elements */
.input-panel .decoration {
  position: absolute;
  pointer-events: none;
  opacity: 0.5;
  z-index: 0;
}

.input-panel .decoration-1 {
  top: 20px;
  right: 20px;
  width: 40px;
  height: 40px;
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  transform: rotate(45deg);
  animation: rotate 20s infinite linear;
}

.input-panel .decoration-2 {
  bottom: 30px;
  left: 25px;
  width: 25px;
  height: 25px;
  border: 2px solid rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  animation: pulse 15s infinite ease-in-out;
}

.input-panel .decoration-3 {
  top: 50%;
  right: 10%;
  width: 15px;
  height: 15px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 4px;
  transform: rotate(30deg);
  animation: float 18s infinite ease-in-out;
}

/* Hover state for panel */
.input-panel:hover {
  background: linear-gradient(135deg, #7c4ddb, #9168e0);
  box-shadow: 
    0 15px 40px rgba(107, 70, 193, 0.3),
    inset 0 -2px 10px rgba(255, 255, 255, 0.2);
  transform: translateY(-5px);
}

/* Focus state for the whole panel */
.input-panel:focus-within {
  background: linear-gradient(135deg, #7c4ddb, #9168e0);
  box-shadow: 
    0 15px 40px rgba(107, 70, 193, 0.3),
    inset 0 -2px 10px rgba(255, 255, 255, 0.2);
  transform: translateY(-5px);
}

/* Helper text styling */
.input-panel .helper-text {
  font-size: 12px;
  color: rgba(255, 255, 255, 0.7);
  margin-top: 5px;
  font-style: italic;
}

/* Error state */
.input-panel .error input {
  border-color: rgba(255, 100, 100, 0.5);
  background: rgba(255, 100, 100, 0.1);
}

.input-panel .error-message {
  color: rgba(255, 200, 200, 0.9);
  font-size: 12px;
  margin-top: 5px;
  display: block;
}

/* Success state */
.input-panel .success input {
  border-color: rgba(100, 255, 150, 0.5);
  background: rgba(100, 255, 150, 0.05);
}

/* Button styling within panel */
.input-panel button {
  background: rgba(255, 255, 255, 0.15);
  border: none;
  border-radius: 12px;
  color: white;
  padding: 15px 25px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
  letter-spacing: 0.5px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  z-index: 1;
  align-self: flex-end;
  margin-top: 10px;
}

.input-panel button::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
  transition: all 0.5s ease;
}

.input-panel button:hover {
  background: rgba(255, 255, 255, 0.25);
  transform: translateY(-3px);
  box-shadow: 0 7px 20px rgba(0, 0, 0, 0.15);
}

.input-panel button:hover::before {
  left: 100%;
}

.input-panel button:active {
  transform: translateY(0);
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1);
}

/* Tooltip styling */
.input-panel .tooltip {
  position: absolute;
  bottom: 100%;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0, 0, 0, 0.7);
  color: white;
  padding: 8px 12px;
  border-radius: 8px;
  font-size: 12px;
  opacity: 0;
  visibility: hidden;
  transition: all 0.3s ease;
  width: max-content;
  max-width: 200px;
  z-index: 10;
  pointer-events: none;
}

.input-panel .tooltip::after {
  content: '';
  position: absolute;
  top: 100%;
  left: 50%;
  transform: translateX(-50%);
  border: 5px solid transparent;
  border-top-color: rgba(0, 0, 0, 0.7);
}

.input-panel *:hover > .tooltip {
  opacity: 1;
  visibility: visible;
  bottom: calc(100% + 10px);
}

/* Animations */
@keyframes shimmer {
  0% {
    transform: rotate(0deg);
  }
  100% {
    transform: rotate(360deg);
  }
}

@keyframes float {
  0%, 100% {
    transform: translateY(0) translateX(0);
  }
  25% {
    transform: translateY(-10px) translateX(5px);
  }
  50% {
    transform: translateY(0) translateX(10px);
  }
  75% {
    transform: translateY(10px) translateX(5px);
  }
}

@keyframes floatReverse {
  0%, 100% {
    transform: translateY(0) translateX(0);
  }
  25% {
    transform: translateY(10px) translateX(-5px);
  }
  50% {
    transform: translateY(0) translateX(-10px);
  }
  75% {
    transform: translateY(-10px) translateX(-5px);
  }
}

@keyframes rotate {
  0% {
    transform: rotate(45deg);
  }
  100% {
    transform: rotate(405deg);
  }
}

@keyframes pulse {
  0%, 100% {
    transform: scale(1);
    opacity: 0.5;
  }
  50% {
    transform: scale(1.2);
    opacity: 0.7;
  }
}

/* Dark mode support */
@media (prefers-color-scheme: dark) {
  .input-panel {
    background: linear-gradient(135deg, #5a3aaa, #7b54d6);
  }
  
  .input-panel:hover,
  .input-panel:focus-within {
    background: linear-gradient(135deg, #6b46c1, #8662db);
  }
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .input-panel {
    padding: 25px;
    max-width: 100%;
  }
  
  .input-panel button {
    width: 100%;
    align-self: center;
  }
}

@media (max-width: 480px) {
  .input-panel {
    padding: 20px;
    border-radius: 15px;
  }
  
  .input-panel input {
    font-size: 14px;
    padding: 12px 15px;
  }
}

/* Accessible focus states */
.input-panel input:focus-visible {
  outline: 2px solid white;
  outline-offset: 2px;
}

.input-panel button:focus-visible {
  outline: 2px solid white;
  outline-offset: 2px;
}

/* Loading state */
.input-panel.loading::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 5px;
  background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.8), transparent);
  animation: loading 1.5s infinite;
  z-index: 9;
}

@keyframes loading {
  0% {
    left: -100%;
  }
  100% {
    left: 100%;
  }
}


    .button-panel {
      display: flex;
      flex-direction: column;
      height: 100%;
      justify-content: space-between;
    }

    .button-panel button, 
    .button-panel select {
      height: 50px;
      margin-bottom: 10px;
    }

    .input-panel input:focus {
      background: rgba(255, 255, 255, 0.15);
      border-color: rgba(255, 255, 255, 0.4);
      box-shadow: 
        0 0 20px rgba(255, 255, 255, 0.1),
        inset 0 2px 4px rgba(0, 0, 0, 0.2);
      transform: translateY(-2px);
    }

    .input-panel input::placeholder {
      color: rgba(255, 255, 255, 0.6);
      opacity: 1;
    }

    .input-panel input:hover {
      border-color: rgba(255, 255, 255, 0.3);
      background: rgba(255, 255, 255, 0.14);
    }
    .button-panel {
  display: flex;
  gap: 15px;
  margin: 40px auto;
  flex-wrap: wrap;
  justify-content: center;
  background: transparent;
  padding: 40px;
  border-radius: 20px;
  box-shadow:
    0 15px 35px rgb(253, 252, 252),
    inset 0 2px 6px rgba(180, 180, 180, 0.756);
  position: relative;
  max-width: 600px;
  width: 100%;
  overflow: hidden;
  transition: all 0.4s ease;
}

/* Add subtle animated background pattern */

/* Top border glow effect */


/* Corner accents */
.button-panel > .corner {
  position: absolute;
  width: 30px;
  height: 30px;
  z-index: 1;
}

.button-panel > .corner-tl {
  top: 0;
  left: 0;
  border-top: 2px solid rgba(103, 126, 234, 0.6);
  border-left: 2px solid rgba(103, 126, 234, 0.6);
  border-top-left-radius: 15px;
}

.button-panel > .corner-tr {
  top: 0;
  right: 0;
  border-top: 2px solid rgba(118, 75, 162, 0.6);
  border-right: 2px solid rgba(118, 75, 162, 0.6);
  border-top-right-radius: 15px;
}

.button-panel > .corner-bl {
  bottom: 0;
  left: 0;
  border-bottom: 2px solid rgba(118, 75, 162, 0.6);
  border-left: 2px solid rgba(118, 75, 162, 0.6);
  border-bottom-left-radius: 15px;
}

.button-panel > .corner-br {
  bottom: 0;
  right: 0;
  border-bottom: 2px solid rgba(103, 126, 234, 0.6);
  border-right: 2px solid rgba(103, 126, 234, 0.6);
  border-bottom-right-radius: 15px;
}


/* Button ripple effect */


.button-panel button:focus::after {
  animation: ripple 1s ease-out;
}

/* Button glow on hover */

.button-panel button:hover {
  transform: translateY(-3px) scale(1.02);
  box-shadow:
    0 8px 25px rgba(0, 0, 0, 0.3),
    inset 0 -2px 4px rgba(0, 0, 0, 0.2);
  background: linear-gradient(135deg, #7f9cf5, #805ad5);
}

.button-panel button:hover::before {
  opacity: 0.5;
  animation: buttonGlow 1.5s infinite alternate;
}

.button-panel button:active {
  transform: translateY(1px);
  box-shadow:
    0 2px 10px rgba(0, 0, 0, 0.2),
    inset 0 2px 4px rgba(0, 0, 0, 0.1);
}


.button-panel select:hover {
  background: linear-gradient(135deg, #1a202c, #2d3748);
  transform: translateY(-2px);
  box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
  border-color: rgba(255, 255, 255, 0.3);
}

.button-panel select:focus {
  outline: none;
  background: linear-gradient(135deg, #1a202c, #2d3748);
  border-color: rgba(255, 255, 255, 0.3);
  box-shadow: 
    0 4px 12px rgba(0, 0, 0, 0.15),
    0 0 0 3px rgba(103, 126, 234, 0.2);
}

.button-panel select option {
  background: #2d3748;
  color: white;
  padding: 12px;
  font-size: 14px;
  font-weight: 500;
}

.button-panel select option:hover {
  background: #4a5568;
}

.button-panel select option:checked {
  background: #667eea;
  color: white;
}

/* Responsive adjustments */
@media (max-width: 640px) {
  .button-panel {
    padding: 20px;
    gap: 10px;
  }
  
  .button-panel button,
  .button-panel select {
    width: 100%;
    text-align: center;
    padding: 12px 20px;
  }
  
  .button-panel select {
    background-position: right 20px center;
  }
}




    /* Create a container for input and button panels */
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .panel-wrapper {
      display: flex;
      gap: 21px;
      width: 100%;
      max-width: 1200px;
      margin-bottom: 30px;
      align-items: flex-start;
    }

    .input-panel, .button-panel {
      flex: 1;
      margin-bottom: 0;
      min-width: 300px;
      max-width: 500px;
      height: auto;
    }

    .button-panel {
      flex: 1;
      margin-bottom: 0;
      min-width: 200px;
      flex-direction: column;
      align-items: stretch;
    }

    .button-panel button, 
    .button-panel select {
      width: 100%;
      margin-bottom: 10px;
    }

    .button-panel button,
    .button-panel select {
      width: auto;
      margin-bottom: 0;
    }

    @media (max-width: 768px) {
      .button-panel select {
        min-width: 150px;
        padding: 10px 20px;
        font-size: 14px;
      }
    }

    @keyframes shimmer {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    /* Add responsive adjustments */
    @media (max-width: 768px) {
      .panel-wrapper {
        flex-direction: column;
      }
      
      .input-panel, .button-panel {
        width: 100%;
        max-width: 100%;
      }
      
      .button-panel button {
        padding: 10px 20px;
        font-size: 14px;
      }
    }

    /* Responsive Adjustments */
    @media (max-width: 200px) {
      .practice-card {
        width: 90%;
        height: 100;
      }
    }



body {
  background-color: #030712;
  margin: 0;
  padding: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  font-family: 'Inter', system-ui, sans-serif;
  color: white;
  perspective: 1000px;
  overflow-x: hidden;
}

/* Main panel container with 3D effect */
.button-panel {
  display: flex;
  gap: 16px;
  margin: 0 auto;
  flex-wrap: wrap;
  justify-content: center;
  background: transparent;
  padding: 40px;
  border-radius: 24px;
  position: relative;
  max-width: 700px;
  width: 100%;
  overflow: hidden;
  transform-style: preserve-3d;
  transition: transform 0.5s ease, box-shadow 0.5s ease;
  outline: 4px solid rgba(255, 255, 255, 0);
}



/* Glowing background effect with animation */
.button-panel::before {
  content: '';
  position: absolute;
  inset: 0;
  background: 
    radial-gradient(circle at 10% 10%, var(--glow-color-1) 0%, transparent 40%),
    radial-gradient(circle at 90% 90%, var(--glow-color-2) 0%, transparent 40%),
    radial-gradient(circle at 90% 10%, var(--glow-color-3) 0%, transparent 40%),
    radial-gradient(circle at 10% 90%, var(--accent-color-1) 0%, transparent 40%);
  opacity: 0.15;
  z-index: -1;
  filter: blur(30px);
  animation: backgroundPulse 10s infinite alternate;
  outline: 2px solid rgba(255, 255, 255, 0);
}

/* Panel glass-like border */


/* Moving light effect */



/* High-end 3D button with neon effect */
.button-panel button {
  padding: 14px 28px;
  background: rgba(237, 237, 237, 0.849);
  border: 1px solid var(--glass-border);
  border-radius: 14px;
  color: rgb(116, 73, 73);
  font-size: 16px;
  font-weight: 500;
  letter-spacing: 0.5px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  z-index: 5;
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  transform-style: preserve-3d;
  transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  box-shadow:
    0 5px 15px rgba(0, 0, 0, 0.3),
    inset 0 0 5px rgba(255, 255, 255, 0.05);
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  outline: 4px solid rgba(255, 255, 255, 0);
}

/* Button glow effects */
.button-panel button::before {
  content: '';
  position: absolute;
  inset: -2px;
  background: linear-gradient(
    45deg,
    var(--glow-color-1),
    var(--glow-color-2),
    var(--glow-color-3),
    var(--accent-color-1)
  );
  border-radius: 16px;
  z-index: -1;
  opacity: 0;
  transition: opacity 0.4s ease;
  filter: blur(8px);
  outline: 4px solid rgba(255, 255, 255, 0);
}

/* Button hover glow */
.button-panel button:hover {
  transform: translateY(-5px) scale(1.05);
  box-shadow:
    0 15px 30px rgba(0, 0, 0, 0.4),
    0 5px 15px rgba(var(--glow-color-1), 0.3),
    inset 0 0 5px rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.2);
  color: white;
}

.button-panel button:hover::before {
  opacity: 1;
  animation: borderGlow 3s infinite linear;
}

/* Button press effect */
.button-panel button:active {
  transform: translateY(-2px) scale(0.98);
  box-shadow:
    0 5px 15px rgba(0, 0, 0, 0.2),
    inset 0 0 10px rgba(0, 0, 0, 0.2);
}

/* Button highlights */
.button-panel button::after {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 200%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent,
    rgba(255, 255, 255, 0.2),
    transparent
  );
  transition: 0.5s;
  z-index: 1;
}

.button-panel button:hover::after {
  left: 100%;
  transition: 0.7s;
}

/* Button text gradient on hover */
.button-panel button:hover span {
  background: linear-gradient(
    90deg,
    var(--glow-color-1),
    var(--glow-color-2),
    var(--glow-color-3)
  );
  -webkit-background-clip: text;
  background-clip: text;
  color: transparent;
  animation: textGradient 3s infinite linear;
}

/* Colored buttons */
.button-panel button.primary {
  --button-color: var(--glow-color-1);
}

.button-panel button.secondary {
  --button-color: var(--glow-color-2);
}

.button-panel button.warning {
  --button-color: var(--accent-color-2);
}

.button-panel button.danger {
  --button-color: var(--accent-color-3);
}

.button-panel button.colored {
  border-color: var(--button-color);
  box-shadow:
    0 5px 15px rgba(0, 0, 0, 0.3),
    0 0 5px var(--button-color),
    inset 0 0 5px rgba(255, 255, 255, 0.05);
}

.button-panel button.colored::before {
  background: var(--button-color);
}

.button-panel button.colored:hover {
  box-shadow:
    0 15px 30px rgba(0, 0, 0, 0.4),
    0 0 20px var(--button-color),
    inset 0 0 5px rgba(255, 255, 255, 0.1);
}

/* Futuristic select dropdown */
.button-panel select {
  padding: 14px 40px 14px 20px;
  border: 1px solid var(--glass-border);
  border-radius: 14px;
  background: rgba(15, 23, 42, 0.7);
  color: white;
  font-size: 16px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.3s ease;
  appearance: none;
  -webkit-appearance: none;
  backdrop-filter: blur(5px);
  -webkit-backdrop-filter: blur(5px);
  position: relative;
  z-index: 5;
  box-shadow:
    0 5px 15px rgba(0, 0, 0, 0.3),
    inset 0 0 5px rgba(255, 255, 255, 0.05);
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Custom select arrow */
.select-wrapper {
  position: relative;
  z-index: 5;
}

.select-wrapper::after {
  content: '';
  position: absolute;
  top: 50%;
  right: 15px;
  transform: translateY(-50%);
  width: 10px;
  height: 10px;
  border-right: 2px solid rgba(255, 255, 255, 0.7);
  border-bottom: 2px solid rgba(255, 255, 255, 0.7);
  pointer-events: none;
  transform-origin: 50% 50%;
  transition: all 0.3s ease;
  transform: translateY(-50%) rotate(45deg);
}

.select-wrapper:hover::after {
  border-color: white;
}

/* Select hover and focus states */
.button-panel select:hover,
.button-panel select:focus {
  transform: translateY(-5px);
  box-shadow:
    0 15px 30px rgba(0, 0, 0, 0.4),
    0 0 15px rgba(var(--glow-color-2), 0.3),
    inset 0 0 5px rgba(255, 255, 255, 0.1);
  border-color: rgba(255, 255, 255, 0.2);
  outline: none;
}

.button-panel select:focus {
  box-shadow:
    0 15px 30px rgba(0, 0, 0, 0.4),
    0 0 0 3px rgba(var(--glow-color-2), 0.3),
    inset 0 0 5px rgba(255, 255, 255, 0.1);
}

/* Responsive design */
@media (max-width: 768px) {
  .button-panel {
    padding: 30px 20px;
    border-radius: 20px;
  }
  
  .button-panel button,
  .button-panel .select-wrapper {
    width: 100%;
  }
  
  .button-panel select {
    width: 100%;
    text-align: left;
  }
}

/* Fancy animations */
@keyframes backgroundPulse {
  0% {
    opacity: 0.1;
    filter: blur(30px) hue-rotate(0deg);
  }
  50% {
    opacity: 0.2;
    filter: blur(40px) hue-rotate(90deg);
  }
  100% {
    opacity: 0.15;
    filter: blur(30px) hue-rotate(180deg);
  }
}

@keyframes borderGlow {
  0% {
    filter: blur(8px) hue-rotate(0deg);
  }
  100% {
    filter: blur(8px) hue-rotate(360deg);
  }
}

@keyframes textGradient {
  0% {
    filter: hue-rotate(0deg);
  }
  100% {
    filter: hue-rotate(360deg);
  }
}

@keyframes float {
  0% {
    transform: translate(0, 0);
  }
  25% {
    transform: translate(100px, 100px);
  }
  50% {
    transform: translate(200px, 0);
  }
  75% {
    transform: translate(100px, -100px);
  }
  100% {
    transform: translate(0, 0);
  }
}

@keyframes lightMove {
  0% {
    transform: translateY(100%) rotate(35deg);
  }
  100% {
    transform: translateY(-100%) rotate(35deg);
  }
}

/* Create ripple effect */
@keyframes ripple {
  0% {
    transform: scale(0);
    opacity: 0.5;
  }
  100% {
    transform: scale(4);
    opacity: 0;
  }
}

.ripple {
  position: absolute;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.3);
  transform: scale(0);
  animation: ripple 0.6s linear;
  pointer-events: none;
}
/* Add this new CSS for the semi-transparent wrapper */
.panel-wrapper {
  display: flex;
  gap: 21px;
  width: 70%;
  min-width: 800px;
  max-width: 1200px;
  
  margin: 30px auto;
  padding: 20px;
  background: rgba(228, 231, 234, 0.6);
  backdrop-filter: blur(10px);
  border-radius: 25px;
  box-shadow: 
    0 20px 40px rgba(0, 0, 0, 0.3),
    inset 0 0 0 1px rgba(255, 255, 255, 0.1);
    transform-origin: 2;
}

/* Adjust the existing panel styles to match */
.input-panel, .button-panel {
  flex: 1;
  margin-bottom: 0;
  min-width: 300px;
  max-width: 500px;
  height: auto;
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .panel-wrapper {
    flex-direction: column;
    padding: 20px;
    margin: 15px;
  }
  
  .input-panel, .button-panel {
    width: 100%;
    max-width: 100%;
  }
}
    /* Connexion Mode Styles */
    #connexionCanvas {
      overflow: auto;
  position: fixed;     /* Changed from relative to fixed */
  top: 0;             /* Added */
  left: 0;            /* Added */
  width: 100vw;       /* Changed from 100% to 100vw */
  height: 100vh;      /* Changed from 100vh to ensure full viewport height */
  background: #828a5e;
  overflow: auto;
  display: none;
  z-index: 1000;      /* Added to ensure it stays on top */
}

.connexion-card {
  position: absolute;
  width: 200px;
  height: 250px;
  background: linear-gradient(135deg, #ffffff, #f5f5f5);
  border: 1px solid #666;
  border-radius: 8px;
  padding: 15px;
  cursor: move;
  box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
  transition: all 0.3s ease;
  touch-action: none;
  user-select: none;
  z-index: 1;
}
.connexion-card.can-connect {
  border: 2px solid #4CAF50;
  box-shadow: 0 0 20px rgba(76, 175, 80, 0.6);
  transform: scale(1.05);
}
.connexion-card.selected {
  border: 2px solid #4CAF50;
  box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
  transform: scale(1.05);
  z-index: 2;
}

/* Add active state for touch feedback */
.connexion-card:active {
  transform: scale(0.98);
  box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
}

/* Ensure text remains readable */
.connexion-card h4,
.connexion-card p {
  pointer-events: none;
}
    .connexion-card:hover {
      transform: scale(1.02);
    }
    .connexion-card.can-connect {
  border: 2px solid #4CAF50;
  box-shadow: 0 0 15px rgba(76, 175, 80, 0.5);
  transform: scale(1.05);
}

.connection-panel {
  position: absolute;
  width: 450px;
  min-height: 200px;
  height: auto;
  max-height: 80vh;
  background: linear-gradient(135deg, #1a0033, #6902ef);
  border: none;
  border-radius: 20px;
  padding: 20px;
  box-shadow: 0 10px 30px rgba(105, 2, 239, 0.6), 
              inset 0 0 100px rgba(255, 255, 255, 0.1);
  cursor: move;
  touch-action: none; /* Prevents default touch actions */
  -webkit-user-select: none; /* Prevents text selection */
  user-select: none;
  z-index: 1000;
}

/* Add touch-friendly button sizes */
.connection-buttons button {
  min-height: 44px; /* Minimum touch target size */
  min-width: 44px;
  padding: 12px 25px;
  margin: 8px;
  font-size: 16px;
}

/* Add active states for touch feedback */
.connection-buttons button:active {
  transform: scale(0.95);
  background: linear-gradient(45deg, #5701c3, #9340e0);
}
  
  .connection-panel:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 40px rgba(105, 2, 239, 0.8),
                inset 0 0 120px rgba(255, 255, 255, 0.15);
  }
  
  @keyframes glow {
    from {
      box-shadow: 0 10px 30px rgba(105, 2, 239, 0.6),
                  inset 0 0 100px rgba(255, 255, 255, 0.1);
    }
    to {
      box-shadow: 0 10px 30px rgba(105, 2, 239, 0.8),
                  inset 0 0 100px rgba(255, 255, 255, 0.2);
    }
  }
  
.connection-card {
      background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 15px;
    flex: 1 0 calc(50% - 15px);
    min-width: 180px;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.1);
    transform: perspective(1000px) rotateX(5deg);
  }

    
  .card:hover {
    transform: perspective(1000px) rotateX(0deg) translateY(-5px);
    background: rgba(255, 255, 255, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.3);
  }
  
  .connection-description {
    margin: 20px 0;
    background: rgba(218, 206, 206, 0.408);
    padding: 15px;
    border-radius: 10px;
    border-left: 4px solid #9c4dff;
    font-size: 16px;
    line-height: 1.6;
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
  }
  
  .connection-buttons {
    margin-top: 20px;
    display: flex;
    gap: 15px;
  }
  
  .button {
    background: linear-gradient(45deg, #6902ef, #af5fff);
    color: white;
    border: none;
    border-radius: 30px;
    padding: 12px 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(105, 2, 239, 0.4);
    position: relative;
    overflow: hidden;
  }
  
  .button:hover {
    background: linear-gradient(45deg, #5b01d3, #9340e0);
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(105, 2, 239, 0.6);
  }
  
  .button::after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: rgba(255, 255, 255, 0.1);
    transform: rotate(30deg);
    transition: all 0.3s ease;
    opacity: 0;
  }
  
  .button:hover::after {
    opacity: 1;
    transform: rotate(30deg) translate(10%, -10%);
  }
  
  /* Custom scrollbar */
  .connection-panel::-webkit-scrollbar {
    width: 8px;
  }
  
  .connection-panel::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
  }
  
  .connection-panel::-webkit-scrollbar-thumb {
    background: linear-gradient(180deg, #6902ef, #af5fff);
    border-radius: 10px;
  }
  
  .connection-panel::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(180deg, #5b01d3, #9340e0);
  }

    .connection-buttons button  {
    background: linear-gradient(45deg, #6902ef, #af5fff);
    color: white;
    border: none;
    border-radius: 30px;
    padding: 12px 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(105, 2, 239, 0.4);
    position: relative;
    overflow: hidden;
  }

    .connexion-card h4,
.connexion-card p {
  color: #033b4e;  /* Added to ensure headers and paragraphs are black */
}

.connection-panel {
  /* ... existing styles ... */
  color: #ffffff;  /* Added this line */
}

.connection-panel h4,
.connection-panel p {
  color: #ffffff;  /* Added to ensure headers and paragraphs are black */
}

.connection-description {
  margin-top: 10px;
  font-size: 14px;
  color: #333;  /* Already defined but ensuring it's visible */
}
    .connection-buttons .edit-connection after {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: rgba(255, 255, 255, 0.1);
    transform: rotate(30deg);
    transition: all 0.3s ease;
    opacity: 0;
  }


    .connection-buttons .edit-connection:hover {
      background: linear-gradient(135deg, #7f9cf5, #805ad5);
    }

    .connection-buttons .view-connection {
      background: linear-gradient(135deg, #2ecc71, #27ae60);
      color: #fff;
    }

    .connection-buttons .view-connection:hover {
      background: linear-gradient(135deg, #55e7a0, #4cd786);
    }

    .connection-buttons .remove-connection {
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      color: #fff;
    }

    .connection-buttons .remove-connection:hover {
      background: linear-gradient(135deg, #ff8787, #ff6565);
    }

    /* Flip functionality for connexion cards */
    .connexion-card-inner {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.6s;
      transform-style: preserve-3d;
    }

    .connexion-card.flipped .connexion-card-inner {
      transform: rotateY(180deg);
    }

    .connexion-card-front, .connexion-card-back {
      position: absolute;
      width: 100%;
      height: 100%;
      backface-visibility: hidden;
      padding: 15px;
      box-sizing: border-box;
      border-radius: 8px;
    }

    .connexion-card-front {
      background: linear-gradient(135deg, #ffffff, #f5f5f5);
    }

    .connexion-card-back {
      background: linear-gradient(135deg, #ff9a9e, #fad0c4);
      transform: rotateY(180deg);
      color: #333;
    }
.connection-cards {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}
.connection-card {
  flex: 1 1 200px;
}
 
/* Define reusable variables */
/* Define reusable variables */
/* Define reusable variables */
:root {
  --bg-start: #a0e948;
  --bg-end: #ecf2dd;
  --node-fill: rgba(221, 254, 88, 0.738);
  --node-stroke: #4a90e2;
  --node-hover-fill: #c3d1dd;
  --node-hover-stroke: #2779bd;
  --text-color: #2d3748;
  --text-category-color: #805ad5;
  --line-stroke-width: 2px;
  --line-dasharray: 6;
  --drop-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
  --drop-shadow-hover: 0 6px 12px rgba(0, 0, 0, 0.4);
  --transition-duration: 0.3s;
  --transition-timing: ease;
  --node-border-radius: 5px;
}

/* Mind Map Container with animated gradient and overlay texture */
#mindMapView {
  width: 100%;
  height: 100vh;
  position: relative;
  overflow: hidden;
  background: linear-gradient(135deg, var(--bg-start), var(--bg-end));
  background-size: 300% 300%;
  animation: gradientShift 20s ease infinite;
}

/* Additional background texture for depth */
#mindMapView::before {
  content: "";
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: radial-gradient(circle at center, rgba(255,255,255,0.05), transparent);
  animation: pulseBg 12s ease-in-out infinite;
  pointer-events: none;
  z-index: 0;
}

/* Animated background gradient shift */
@keyframes gradientShift {
  0% { background-position: 0% 50%; }
  50% { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

/* Pulse animation for the background overlay */


/* SVG Container stays above the background overlay */
#mindMapView svg {
  width: 100%;
  height: 100%;
  position: relative;
  z-index: 1;
}

/* Connection Lines with glowing effect and animated dash offset */
#mindMapView line {
  stroke: var(--node-stroke);
  stroke-width: var(--line-stroke-width);
  stroke-linecap: round;
  stroke-dasharray: var(--line-dasharray);
  filter: drop-shadow(0 0 8px rgba(17, 1, 1, 0.6));
  animation: flowLine 30s linear infinite;
}

/* Nodes reimagined with enhanced shadow, slight rotation on hover, and increased scale */
#mindMapView rect {
  fill: var(--node-fill);
  stroke: var(--node-stroke);
  stroke-width: var(--line-stroke-width);
  rx: calc(var(--node-border-radius)* 1);
  ry: calc(var(--node-border-radius) * 1.5);
  filter: drop-shadow(var(--drop-shadow)) drop-shadow(0 0 8px rgba(255, 255, 255, 0.2));
  transition: transform var(--transition-duration) var(--transition-timing),
              fill var(--transition-duration) var(--transition-timing),
              filter var(--transition-duration) var(--transition-timing);
}

/* Enhanced Node Hover Effects */
#mindMapView rect:hover {
  fill: var(--node-hover-fill);
  stroke: var(--node-hover-stroke);
  transform: scale(1.1) rotate(1deg);
  filter: drop-shadow(var(--drop-shadow-hover)) drop-shadow(0 0 12px rgba(255, 255, 255, 0.3));
}

/* Text Styling with pronounced shadows for clarity */
#mindMapView text {
  font-family: 'Segoe UI', system-ui, sans-serif;
  fill: var(--text-color);
  font-size: 16px;
  font-weight: 500;
  pointer-events: none;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
}
#mindMapView text {
  white-space: normal; /* Allow wrapping */
  overflow-wrap: break-word;
  padding: 5px; /* Some padding inside the node, if applicable */
}

/* Category Text Styling with letter spacing and shadow */
#mindMapView text.category {
  fill: var(--text-category-color);
  font-size: 14px;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.2);
}

/* Connection Labels with increased font size and shadow */
#mindMapView text.connection-label {
  fill: #ffffff;
  font-size: 14px;
  font-weight: 500;
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.5);
}

/* Animation for connection lines */
@keyframes flowLine {
  from {
    stroke-dashoffset: 1000;
  }
  to {
    stroke-dashoffset: 0;
  }
}

/* Responsive Adjustments for smaller screens */
@media (max-width: 768px) {
  #mindMapView text {
    font-size: 14px;
  }
  
  #mindMapView text.category {
    font-size: 12px;
  }
  
  #mindMapView text.connection-label {
    font-size: 12px;
  }
}
.mind-map-button  {
    background: linear-gradient(45deg, #6902ef, #af5fff);
    color: white;
    border: none;
    border-radius: 30px;
    padding: 12px 25px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 5px 15px rgba(105, 2, 239, 0.4);
    position: relative;
    overflow: hidden;
  }

  .fullscreen-mode {
  position: fixed !important;
  top: 0;
  left: 0;
  width: 100vw !important;
  height: 100vh !important;
  background: linear-gradient(125deg, #0a0c1f, #1a1f35, #0f2242);
  background-size: 400% 400%;
  animation: gradientShift 15s ease infinite;
  z-index: 10000;
  padding: 3rem;
  display: flex !important;
  flex-wrap: wrap;
  justify-content: center;
  align-content: flex-start;
  gap: 2.5rem;
  overflow-y: auto;
  margin: 0 !important;
  box-sizing: border-box;
  box-shadow: inset 0 0 150px rgba(0, 0, 0, 0.4);
}

.fullscreen-mode .flashcard {
  position: relative !important;
  width: calc(25% - 2rem) !important; /* 4 cards per row with gap */
  min-width: 250px !important;
  height: 300px !important;
  margin: 0 !important;
  transform: none !important;
  transition: all 0.3s ease;
  flex: 1 1 250px;
  max-width: 350px;
}

.fullscreen-mode .flashcard-inner {
  height: 100%;
  width: 100%;
}

.exit-fullscreen-btn {
  position: fixed;
  top: 25px;
  right: 25px;
  background: rgba(20, 30, 60, 0.6);
  border: 1px solid rgba(255, 255, 255, 0.15);
  color: rgba(255, 255, 255, 0.95);
  padding: 14px 32px;
  border-radius: 40px;
  cursor: pointer;
  z-index: 10001;
  backdrop-filter: blur(15px);
  font-size: 16px;
  font-weight: 500;
  letter-spacing: 0.8px;
  transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2), 0 3px 10px rgba(0, 0, 0, 0.1);
  text-transform: uppercase;
}


.fullscreen-wrapper {
  display: flex;
  justify-content: center;
  margin-top: 20px;
  margin-bottom: 20px;
}

.fullscreen-button {
  background: linear-gradient(45deg, #6902ef, #af5fff);
  color: white;
  border: none;
  border-radius: 30px;
  padding: 14px 32px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
  box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
  text-transform: uppercase;
  letter-spacing: 0.8px;
}

.fullscreen-button:hover {
  transform: translateY(-2px);
  box-shadow: 0 12px 30px rgba(105, 2, 239, 0.3);
  background: linear-gradient(45deg, #5b01d3, #9340e0);
}

.fullscreen-button:active {
  transform: translateY(1px);
  box-shadow: 0 5px 15px rgba(105, 2, 239, 0.2);
}
/* Add these styles to your existing CSS */
.fullscreen-controls {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: 80%;
  background: rgba(20, 30, 60, 0.8);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 15px;
  display: flex;
  flex-direction: column;
  gap: 15px;
  z-index: 10001;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  transition: all 0.3s ease;
}

.fs-control-group {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
}

.fs-btn {
  background: rgba(255, 255, 255, 0.15);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 8px 16px;
  cursor: pointer;
  transition: all 0.2s ease;
  font-weight: 500;
}

/* Fullscreen dropdown menu */
.fs-dropdown {
  position: fixed;
  top: 20px;
  left: 20px;
  z-index: 10002;
}

.fs-dropdown-btn {
  background: linear-gradient(135deg, #6902ef, #af5fff);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 12px 20px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  gap: 8px;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
}

.fs-dropdown-btn:hover {
  background: linear-gradient(135deg, #5b01d3, #9340e0);
}

.fs-dropdown-content {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  margin-top: 10px;
  background: rgba(20, 30, 60, 0.95);
  backdrop-filter: blur(10px);
  min-width: 250px;
  border-radius: 12px;
  box-shadow: 0 8px 30px rgba(0, 0, 0, 0.4);
  z-index: 10003;
  overflow: hidden;
  animation: fadeInScale 0.3s ease-out;
}

.fs-dropdown-content.show {
  display: block;
}

.fs-dropdown-item {
  padding: 12px 20px;
  color: white;
  display: flex;
  align-items: center;
  gap: 10px;
  cursor: pointer;
  transition: all 0.2s ease;
  border-bottom: 1px solid rgba(255, 255, 255, 0.1);
}

.fs-dropdown-item:last-child {
  border-bottom: none;
}

.fs-dropdown-item:hover {
  background: rgba(255, 255, 255, 0.1);
}

.fs-dropdown-item i {
  font-size: 18px;
  width: 24px;
  text-align: center;
}

/* Category panels for animation */
.category-panels-container {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: none;
  z-index: 10000;
}

.category-panel {
  position: absolute;
  background: rgba(20, 30, 60, 0.7);
  backdrop-filter: blur(10px);
  border-radius: 15px;
  padding: 20px;
  box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
  transition: all 0.8s cubic-bezier(0.2, 0.8, 0.2, 1);
  overflow: auto;
}

.category-panel-header {
  color: white;
  font-size: 24px;
  font-weight: 600;
  margin-bottom: 20px;
  text-align: center;
  text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
  border-bottom: 2px solid rgba(255, 255, 255, 0.2);
  padding-bottom: 10px;
}

.category-panel .flashcard {
  transform: scale(0);
  opacity: 0;
  transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
  transition-delay: calc(var(--card-index) * 0.1s);
}

.category-panel.active .flashcard {
  transform: scale(1);
  opacity: 1;
}

/* Back button for category view */
.category-view-back {
  position: fixed;
  top: 20px;
  left: 20px;
  background: linear-gradient(135deg, #ff6b6b, #ff4757);
  color: white;
  border: none;
  border-radius: 8px;
  padding: 12px 20px;
  font-size: 16px;
  font-weight: 600;
  cursor: pointer;
  z-index: 10004;
  box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
  display: none;
}

.category-view-back:hover {
  background: linear-gradient(135deg, #ff8787, #ff6565);
}
  </style>
</head>
<body>
  <header>
    <h1>ABS Flashcards</h1>
  </header>
  
  <div class="panel-wrapper">
    <div class="input-panel">
      <input type="text" id="category" placeholder="Enter category" list="categoryList">
      <datalist id="categoryList"></datalist>
      <input type="text" id="question" placeholder="Enter question / title">
      <input type="text" id="answer" placeholder="Enter answer or note content (LaTeX supported)">
      <button onclick="addNewCard()">Add Card</button>
      <option value="all">Made for desktop only</option>
    </div>
    
    <div class="button-panel">
     
      <button onclick="addNewNote()">Add Note</button>
      <button onclick="shuffleCards()">Shuffle Cards</button>
      <button onclick="startPracticeMode()">Let's Practice</button>
      <button onclick="enterConnexionMode()">Make Connexions</button>
      <button id="exportBtn" onclick="exportCards()">Export Cards</button>
      <input type="file" id="importFile" accept=".json" onchange="importCards(event)" style="display: none;">
      <button id="importBtn" onclick="document.getElementById('importFile').click()">Import Cards</button>
      <select id="filterCategory" onchange="renderCards()">
        <option value="all">Show All Categories</option>
      </select>
    </div>
  </div>
<div class="fullscreen-wrapper">
  <button id="fullscreenBtn" class="fullscreen-button">Fullscreen View</button>
</div>

  <div class="flashcard-container" id="cardContainer"></div>
  <div id="connexionCanvas"></div>
  
  <!-- Modal for Subcards (initially hidden) -->
  <div id="subcardsModal"></div>
  <!-- Modal for Expanded Note (initially hidden) -->
  <div id="noteModal"></div>
  
  <!-- Side Panel Toggle Button & Panel -->
       
           <div class="practice-deck-wrapper" id="practiceDeck">
    <button class="practice-close-btn" onclick="exitPracticeMode()">Close</button>
    <div class="practice-deck" id="practiceDeckContainer"></div>
    <div class="practice-controls">
      <button class="control-btn" onclick="showPrevCard()">Previous</button>
      <button class="control-btn" onclick="showNextCard()">Next</button>
    </div>
  </div>
 <script> 
/***********************
 * Default Cards Data  *
 ***********************/
const cardsData = [
  {
    category: "Quantum Mechanics",
    question: "Time-independent Schrdinger Equation",
    answer: "$$ -\\frac{\\hbar^2}{2m}\\nabla^2\\psi(\\mathbf{r}) + V(\\mathbf{r})\\psi(\\mathbf{r}) = E\\psi(\\mathbf{r}) $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Time-dependent Schrdinger Equation",
    answer: "$$ i\\hbar\\,\\frac{\\partial}{\\partial t}\\psi(\\mathbf{r},t) = -\\frac{\\hbar^2}{2m}\\nabla^2\\psi(\\mathbf{r},t) + V(\\mathbf{r})\\psi(\\mathbf{r},t) $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Momentum Operator",
    answer: "$$ \\hat{p} = -i\\hbar\\,\\frac{\\partial}{\\partial x} $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Position Operator",
    answer: "$$ \\hat{x} = x $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Probability Density",
    answer: "$$ \\rho(\\mathbf{r},t) = |\\psi(\\mathbf{r},t)|^2 $$",
    type: "card"
  },
  {
    category: "Quantum Mechanics",
    question: "Current Density",
    answer: "$$ \\mathbf{j}(\\mathbf{r},t) = \\frac{\\hbar}{2mi}\\left(\\psi^*\\nabla\\psi - \\psi\\nabla\\psi^*\\right) $$",
    type: "card"
  }
];

let currentCards = [];
let connections = [];
let currentFilteredCards = [];
let isSelectMode = false; // Tracks if we're in selection mode
let selectedCards = new Set(); // Stores the IDs of selected cards

// Track segregation state
let isSegregated = false;
let originalPositions = {};
let globalEventHandlersInitialized = false;
let activeConnectionCreation = false;

// Store active drag state
let activeDrag = {
  element: null,
  isDragging: false,
  startX: 0,
  startY: 0
};

// Union-Find class for clustering
class UnionFind {
  constructor(elements) {
    this.parent = {};
    this.rank = {};
    elements.forEach(el => {
      this.parent[el] = el;
      this.rank[el] = 0;
    });
  }

  find(el) {
    if (this.parent[el] !== el) {
      this.parent[el] = this.find(this.parent[el]);
    }
    return this.parent[el];
  }

  union(el1, el2) {
    const root1 = this.find(el1);
    const root2 = this.find(el2);
    if (root1 === root2) return;
    if (this.rank[root1] < this.rank[root2]) {
      this.parent[root1] = root2;
    } else {
      this.parent[root2] = root1;
      if (this.rank[root1] === this.rank[root2]) {
        this.rank[root1]++;
      }
    }
  }
}

/******************************
 * Rendering & Storage Logic  *
 ******************************/
function renderCards() {
  const container = document.getElementById('cardContainer');
  container.innerHTML = '';
  const filterValue = document.getElementById('filterCategory').value;
  const filteredCards = filterValue === 'all'
    ? currentCards
    : currentCards.filter(card => card.category === filterValue);
  filteredCards.forEach(card => {
    container.appendChild(createCard(card));
  });
  updateCategoryLists();
}

function updateCategoryLists() {
  const categorySet = new Set();
  currentCards.forEach(card => {
    if (card.category) categorySet.add(card.category);
  });
  const dataList = document.getElementById('categoryList');
  dataList.innerHTML = '';
  categorySet.forEach(cat => {
    const option = document.createElement('option');
    option.value = cat;
    dataList.appendChild(option);
  });
  const filterSelect = document.getElementById('filterCategory');
  const currentSelection = filterSelect.value;
  filterSelect.innerHTML = '<option value="all">Show All Categories</option>';
  categorySet.forEach(cat => {
    const option = document.createElement('option');
    option.value = cat;
    option.textContent = cat;
    filterSelect.appendChild(option);
  });
  filterSelect.value = currentSelection;
}

function loadCards() {
  const saved = localStorage.getItem('flashcards');
  if (saved) {
    currentCards = JSON.parse(saved);
  } else {
    currentCards = cardsData.map(card => ({
      ...card,
      id: `card-${Date.now()}-${Math.random()}`
    }));
  }
  renderCards();
}

function saveCards() {
  localStorage.setItem('flashcards', JSON.stringify(currentCards));
}

function loadConnections() {
  const saved = localStorage.getItem('connections');
  if (saved) {
    connections = JSON.parse(saved);
    connections = connections.map(conn => {
      // If 'cards' exists, keep the connection as is
      if (conn.cards) {
        return conn;
      } 
      // Migrate legacy format with 'card1' and 'card2'
      else if (conn.card1 && conn.card2) {
        return {
          id: conn.id,
          cards: [conn.card1, conn.card2],
          description: conn.description,
          tag: conn.tag,
          color: conn.color
        };
      } 
      // Log and discard invalid connections
      else {
        console.warn('Invalid connection found and will be removed:', conn);
        return null;
      }
    }).filter(Boolean); // Remove null entries
  } else {
    connections = [];
  }
}

function saveConnections() {
  localStorage.setItem('connections', JSON.stringify(connections));
}

/******************************
 * Modal Functions for Subcards *
 ******************************/
function openSubcardsModal(parentCard) {
  // Check if we're in fullscreen mode
  const container = document.querySelector('.flashcard-container');
  const isFullscreen = container.classList.contains('fullscreen-mode');
  
  if (isFullscreen) {
    // In fullscreen mode, show subcards in a panel
    openSubcardsPanel(parentCard);
  } else {
    // In normal mode, show subcards in a modal
    const modal = document.getElementById('subcardsModal');
    modal.innerHTML = '';
    const modalContent = document.createElement('div');
    modalContent.className = 'modal-content';
    const closeBtn = document.createElement('button');
    closeBtn.className = 'close-modal';
    closeBtn.textContent = '';
    closeBtn.onclick = closeSubcardsModal;
    modalContent.appendChild(closeBtn);
    const modalTitle = document.createElement('h2');
    modalTitle.textContent = 'Subcards';
    modalTitle.style.textAlign = 'center';
    modalContent.appendChild(modalTitle);
    const modalSubcardsContainer = document.createElement('div');
    modalSubcardsContainer.className = 'modal-subcards-container';
    if (parentCard.subcards && parentCard.subcards.length > 0) {
      parentCard.subcards.forEach(subcard => {
        modalSubcardsContainer.appendChild(createSubcardForModal(subcard));
      });
    } else {
      const noSubcardsMsg = document.createElement('p');
      noSubcardsMsg.textContent = 'No subcards available.';
      modalSubcardsContainer.appendChild(noSubcardsMsg);
    }
    modalContent.appendChild(modalSubcardsContainer);
    modal.appendChild(modalContent);
    modal.style.display = 'flex';
  }
}

// Function to open subcards in a panel (for fullscreen mode)
function openSubcardsPanel(parentCard) {
  const container = document.querySelector('.flashcard-container');
  
  // Create or get subcards panel container
  let subcardsPanel = container.querySelector('.subcards-panel-container');
  if (!subcardsPanel) {
    subcardsPanel = document.createElement('div');
    subcardsPanel.className = 'subcards-panel-container';
    container.appendChild(subcardsPanel);
  }
  
  // Clear previous content
  subcardsPanel.innerHTML = '';
  
  // Create panel header with title and back button
  const panelHeader = document.createElement('div');
  panelHeader.className = 'subcards-panel-header';
  
  const backBtn = document.createElement('button');
   backBtn.className = 'subcards-panel-back';
  backBtn.textContent = 'Exit';
  backBtn.onclick = exitSubcardsPanel;
  
  const panelTitle = document.createElement('h2');
  panelTitle.textContent = `Subcards: ${parentCard.question}`;
  
  panelHeader.appendChild(backBtn);
  panelHeader.appendChild(panelTitle);
  subcardsPanel.appendChild(panelHeader);
  
  // Add a subtle glass effect overlay
  const glassOverlay = document.createElement('div');
  glassOverlay.className = 'glass-overlay';
  subcardsPanel.appendChild(glassOverlay);
  
  // Create subcards container
  const subcardsContainer = document.createElement('div');
  subcardsContainer.className = 'subcards-panel-cards';
  
  if (parentCard.subcards && parentCard.subcards.length > 0) {
    parentCard.subcards.forEach((subcard, idx) => {
      const subcardElement = createSubcardForPanel(subcard);
      subcardElement.style.opacity = '0';
      subcardElement.style.transform = 'scale(0.8)';
      subcardsContainer.appendChild(subcardElement);
      
      // Animate subcards with staggered delay
      setTimeout(() => {
        subcardElement.style.opacity = '1';
        subcardElement.style.transform = 'scale(1)';
      }, 50 + idx * 50);
    });
  } else {
    const noSubcardsMsg = document.createElement('p');
    noSubcardsMsg.textContent = 'No subcards available.';
    noSubcardsMsg.style.textAlign = 'center';
    noSubcardsMsg.style.padding = '20px';
    noSubcardsMsg.style.color = '#fff';
    subcardsContainer.appendChild(noSubcardsMsg);
  }
  
  subcardsPanel.appendChild(subcardsContainer);
  
  // Hide all cards
  const cards = container.querySelectorAll('.flashcard:not(.subcard)');
  cards.forEach(card => {
    card.style.display = 'none';
  });
  
  // Show the panel
  subcardsPanel.style.display = 'block';
  setTimeout(() => {
    subcardsPanel.classList.add('active');
  }, 50);
}

function closeSubcardsModal() {
  document.getElementById('subcardsModal').style.display = 'none';
}

// Function to exit subcards panel in fullscreen mode
function exitSubcardsPanel() {
  const container = document.querySelector('.flashcard-container');
  const subcardsPanel = container.querySelector('.subcards-panel-container');
  
  // Hide the panel with animation
  subcardsPanel.classList.remove('active');
  
  // Show all cards again
  const cards = container.querySelectorAll('.flashcard:not(.subcard)');
  cards.forEach(card => {
    card.style.display = 'block';
  });
  
  // Remove panel after animation completes
  setTimeout(() => {
    subcardsPanel.style.display = 'none';
  }, 300);
}

// Function to create a subcard element for the panel
function createSubcardForPanel(subcard) {
  const subcardElement = document.createElement('div');
  subcardElement.className = 'flashcard subcard panel-subcard';
  subcardElement.dataset.subcardId = subcard.id;
  
  const subcardInner = document.createElement('div');
  subcardInner.className = 'flashcard-inner';
  subcardInner.innerHTML = `
    <div class="flashcard-front">
      <div>${subcard.question}</div>
    </div>
    <div class="flashcard-back">${subcard.answer}</div>
  `;
  
  subcardElement.onclick = () => {
    subcardElement.classList.toggle('flipped');
    setTimeout(() => {
      if (window.MathJax) {
        MathJax.typesetPromise([subcardElement.querySelector('.flashcard-back')]).catch(err => console.log(err.message));
      }
    }, 500);
  };
  
  subcardElement.appendChild(subcardInner);
  return subcardElement;
}

/******************************
 * Modal Functions for Expanded Note *
 ******************************/
function openNoteModal(noteCard) {
  const noteModal = document.getElementById('noteModal');
  noteModal.innerHTML = '';
  const modalContent = document.createElement('div');
  modalContent.className = 'modal-content';
  const closeBtn = document.createElement('button');
  closeBtn.className = 'close-modal';
  closeBtn.textContent = '';
  closeBtn.onclick = closeNoteModal;
  modalContent.appendChild(closeBtn);
  const modalTitle = document.createElement('h2');
  modalTitle.textContent = noteCard.question;
  modalTitle.style.textAlign = 'center';
  modalContent.appendChild(modalTitle);
  const contentDiv = document.createElement('div');
  contentDiv.innerHTML = noteCard.answer;
  contentDiv.style.marginTop = '20px';
  modalContent.appendChild(contentDiv);
  noteModal.appendChild(modalContent);
  noteModal.style.display = 'flex';
  if (window.MathJax) {
    MathJax.typesetPromise([contentDiv]).catch(err => console.log(err.message));
  }
}

function closeNoteModal() {
  document.getElementById('noteModal').style.display = 'none';
}

function exportCards() {
      const data = {
        cards: currentCards,
        connections: connections
      };
      const json = JSON.stringify(data, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'flashcards_export.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function importCards(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = JSON.parse(e.target.result);
          if (!data.cards || !Array.isArray(data.cards)) {
            throw new Error('Invalid file format: Missing or invalid cards array');
          }
          currentCards = data.cards.map(card => ({
            ...card,
            id: card.id || Date.now().toString(),
            createdAt: card.createdAt || new Date().toISOString(),
            subcards: Array.isArray(card.subcards) ? card.subcards.map(subcard => ({
              ...subcard,
              id: subcard.id || Date.now().toString()
            })) : []
          }));
          connections = Array.isArray(data.connections) ? data.connections : [];
          saveCards();
          saveConnections();
          filterCards();
          alert('Cards imported successfully!');
        } catch (error) {
          alert('Error importing cards: ' + error.message);
        }
      };
      reader.readAsText(file);
      event.target.value = ''; // Reset file input
    }
/******************************
 * Edit Panel Modal Functions *
 ******************************/
function openEditPanel(card, onClose) {
  // Check if we're in fullscreen mode
  const container = document.querySelector('.flashcard-container');
  const isFullscreen = container.classList.contains('fullscreen-mode') || document.fullscreenElement;
  
  // Create or get the edit panel modal
  let editPanelModal = document.getElementById('editPanelModal');
  if (!editPanelModal) {
    editPanelModal = document.createElement('div');
    editPanelModal.id = 'editPanelModal';
    
    // Append to the fullscreen container if in fullscreen mode, otherwise to body
    if (isFullscreen) {
      container.appendChild(editPanelModal);
    } else {
      document.body.appendChild(editPanelModal);
    }
  } else {
    // If the modal already exists but we need to move it to the correct container
    if (isFullscreen && editPanelModal.parentElement !== container) {
      if (editPanelModal.parentElement) {
        editPanelModal.parentElement.removeChild(editPanelModal);
      }
      container.appendChild(editPanelModal);
    } else if (!isFullscreen && editPanelModal.parentElement !== document.body) {
      if (editPanelModal.parentElement) {
        editPanelModal.parentElement.removeChild(editPanelModal);
      }
      document.body.appendChild(editPanelModal);
    }
  }
  
  // Clear previous content
  editPanelModal.innerHTML = '';
  
  // Create modal content
  const modalContent = document.createElement('div');
  modalContent.className = 'edit-panel-content';
  
  // Create header
  const header = document.createElement('div');
  header.className = 'edit-panel-header';
  
  const title = document.createElement('h2');
  title.className = 'edit-panel-title';
  title.textContent = 'Edit Card';
  
  const closeBtn = document.createElement('button');
  closeBtn.className = 'close-edit-panel';
  closeBtn.innerHTML = '&times;';
  closeBtn.onclick = () => {
    closeEditPanel();
    if (onClose) onClose();
  };
  
  header.appendChild(title);
  header.appendChild(closeBtn);
  modalContent.appendChild(header);
  
  // Create form
  const form = document.createElement('div');
  form.className = 'edit-panel-form';
  
  // Category input
  const categoryGroup = document.createElement('div');
  categoryGroup.className = 'form-group';
  
  const categoryLabel = document.createElement('label');
  categoryLabel.textContent = 'Category';
  categoryLabel.setAttribute('for', 'edit-panel-category');
  
  const categoryInput = document.createElement('input');
  categoryInput.type = 'text';
  categoryInput.id = 'edit-panel-category';
  categoryInput.value = card.category || '';
  categoryInput.placeholder = 'Enter category';
  categoryInput.setAttribute('list', 'categoryList');
  
  categoryGroup.appendChild(categoryLabel);
  categoryGroup.appendChild(categoryInput);
  form.appendChild(categoryGroup);
  
  // Question/Title input
  const questionGroup = document.createElement('div');
  questionGroup.className = 'form-group';
  
  const questionLabel = document.createElement('label');
  questionLabel.textContent = card.type === 'note' ? 'Title' : 'Question';
  questionLabel.setAttribute('for', 'edit-panel-question');
  
  const questionInput = document.createElement('input');
  questionInput.type = 'text';
  questionInput.id = 'edit-panel-question';
  questionInput.value = card.question || '';
  questionInput.placeholder = card.type === 'note' ? 'Enter title' : 'Enter question';
  
  questionGroup.appendChild(questionLabel);
  questionGroup.appendChild(questionInput);
  form.appendChild(questionGroup);
  
  // Answer/Content input
  const answerGroup = document.createElement('div');
  answerGroup.className = 'form-group';
  
  const answerLabel = document.createElement('label');
  answerLabel.textContent = card.type === 'note' ? 'Content' : 'Answer';
  answerLabel.setAttribute('for', 'edit-panel-answer');
  
  const answerInput = document.createElement('textarea');
  answerInput.id = 'edit-panel-answer';
  answerInput.value = card.answer || '';
  answerInput.placeholder = card.type === 'note' ? 'Enter note content (LaTeX supported)' : 'Enter answer (LaTeX supported)';
  answerInput.rows = card.type === 'note' ? 8 : 5;
  
  answerGroup.appendChild(answerLabel);
  answerGroup.appendChild(answerInput);
  form.appendChild(answerGroup);
  
  // Button group
  const buttonGroup = document.createElement('div');
  buttonGroup.className = 'button-group';
  
  const saveBtn = document.createElement('button');
  saveBtn.className = 'save-btn';
  saveBtn.textContent = 'Save Changes';
  saveBtn.onclick = () => {
    // Save changes to card
    card.category = categoryInput.value.trim();
    card.question = questionInput.value.trim();
    card.answer = answerInput.value.trim();
    
    // Save cards and re-render
    saveCards();
    renderCards();
    
    // Close modal
    closeEditPanel();
    if (onClose) onClose();
  };
  
  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'cancel-btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = () => {
    closeEditPanel();
    if (onClose) onClose();
  };
  
  buttonGroup.appendChild(saveBtn);
  buttonGroup.appendChild(cancelBtn);
  form.appendChild(buttonGroup);
  
  // Subcards section (if applicable)
  if (card.type !== 'subcard') {
    const subcardsSection = document.createElement('div');
    subcardsSection.className = 'subcards-section';
    
    const subcardsHeader = document.createElement('div');
    subcardsHeader.className = 'subcards-header';
    
    const subcardsTitle = document.createElement('h3');
    subcardsTitle.textContent = 'Subcards';
    
    const addSubcardBtn = document.createElement('button');
    addSubcardBtn.className = 'add-subcard-btn';
    addSubcardBtn.textContent = '+ Add Subcard';
    addSubcardBtn.onclick = () => {
      const newSubcard = {
        id: `card-${Date.now()}-${Math.random()}`,
        question: 'New Subcard',
        answer: 'Subcard answer',
        type: 'subcard'
      };
      
      if (!card.subcards) card.subcards = [];
      card.subcards.push(newSubcard);
      
      // Re-render subcards in the modal
      renderSubcardsInEditPanel(card, subcardsContainer);
    };
    
    subcardsHeader.appendChild(subcardsTitle);
    subcardsHeader.appendChild(addSubcardBtn);
    subcardsSection.appendChild(subcardsHeader);
    
    const subcardsContainer = document.createElement('div');
    subcardsContainer.className = 'subcards-container';
    
    // Render existing subcards
    renderSubcardsInEditPanel(card, subcardsContainer);
    
    subcardsSection.appendChild(subcardsContainer);
    form.appendChild(subcardsSection);
  }
  
  modalContent.appendChild(form);
  editPanelModal.appendChild(modalContent);
  
  // Display the modal with animation
  editPanelModal.style.display = 'flex';
  setTimeout(() => {
    editPanelModal.classList.add('active');
  }, 10);
}

function renderSubcardsInEditPanel(card, container) {
  // Clear container
  container.innerHTML = '';
  
  // Check if card has subcards
  if (!card.subcards || card.subcards.length === 0) {
    const noSubcardsMsg = document.createElement('p');
    noSubcardsMsg.textContent = 'No subcards yet. Add one to get started.';
    noSubcardsMsg.style.color = '#888';
    noSubcardsMsg.style.fontStyle = 'italic';
    container.appendChild(noSubcardsMsg);
    return;
  }
  
  // Render each subcard
  card.subcards.forEach(subcard => {
    const subcardElement = document.createElement('div');
    subcardElement.className = 'flashcard subcard';
    subcardElement.style.position = 'relative';
    
    // Create delete button
    const deleteBtn = document.createElement('button');
    deleteBtn.className = 'delete-btn';
    deleteBtn.textContent = '';
    deleteBtn.style.opacity = '1';
    deleteBtn.onclick = (e) => {
      e.stopPropagation();
      card.subcards = card.subcards.filter(sc => sc.id !== subcard.id);
      renderSubcardsInEditPanel(card, container);
    };
    
    // Create edit button
    const editBtn = document.createElement('button');
    editBtn.className = 'edit-btn';
    editBtn.textContent = '';
    editBtn.style.opacity = '1';
    editBtn.onclick = (e) => {
      e.stopPropagation();
      enableSubcardEditInPanel(subcardElement, subcard, card, container);
    };
    
    // Create subcard content
    const subcardInner = document.createElement('div');
    subcardInner.className = 'flashcard-inner';
    subcardInner.innerHTML = `
      <div class="flashcard-front">
        <div>${subcard.question}</div>
      </div>
      <div class="flashcard-back">${subcard.answer}</div>
    `;
    
    // Add click handler to flip
    subcardElement.onclick = () => {
      subcardElement.classList.toggle('flipped');
    };
    
    subcardElement.appendChild(deleteBtn);
    subcardElement.appendChild(editBtn);
    subcardElement.appendChild(subcardInner);
    container.appendChild(subcardElement);
  });
}

function enableSubcardEditInPanel(subcardElement, subcard, parentCard, container) {
  subcardElement.classList.add('editing');
  const subcardInner = subcardElement.querySelector('.flashcard-inner');
  const originalContent = subcardInner.innerHTML;
  
  // Create edit form
  const editForm = document.createElement('div');
  editForm.className = 'edit-mode';
  
  // Question input
  const questionInput = document.createElement('input');
  questionInput.type = 'text';
  questionInput.value = subcard.question;
  questionInput.placeholder = 'Subcard Question';
  
  // Answer input
  const answerInput = document.createElement('textarea');
  answerInput.rows = 4;
  answerInput.value = subcard.answer;
  answerInput.placeholder = 'Subcard Answer (LaTeX supported)';
  
  // Button group
  const buttonGroup = document.createElement('div');
  buttonGroup.className = 'button-group';
  
  // Save button
  const saveBtn = document.createElement('button');
  saveBtn.className = 'save-btn';
  saveBtn.textContent = 'Save';
  saveBtn.onclick = (e) => {
    e.stopPropagation();
    subcard.question = questionInput.value.trim();
    subcard.answer = answerInput.value.trim();
    renderSubcardsInEditPanel(parentCard, container);
  };
  
  // Cancel button
  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'cancel-btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = (e) => {
    e.stopPropagation();
    subcardInner.innerHTML = originalContent;
    subcardElement.classList.remove('editing');
  };
  
  // Assemble form
  buttonGroup.appendChild(saveBtn);
  buttonGroup.appendChild(cancelBtn);
  editForm.appendChild(questionInput);
  editForm.appendChild(answerInput);
  editForm.appendChild(buttonGroup);
  
  // Replace content with form
  subcardInner.innerHTML = '';
  subcardInner.appendChild(editForm);
}

function closeEditPanel() {
  const editPanelModal = document.getElementById('editPanelModal');
  if (editPanelModal) {
    editPanelModal.classList.remove('active');
    setTimeout(() => {
      editPanelModal.style.display = 'none';
    }, 300);
  }
}

/******************************
 * Subcard Creation Functions *
 ******************************/
function createSubcard(subcard, parentCard) {
  const subcardElement = document.createElement('div');
  subcardElement.className = 'flashcard subcard';
  subcardElement.dataset.subcardId = subcard.id;
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-btn';
  deleteBtn.textContent = '';
  deleteBtn.onclick = (e) => {
    e.stopPropagation();
    parentCard.subcards = parentCard.subcards.filter(sc => sc.id !== subcard.id);
    saveCards();
    renderCards();
  };
  const editBtn = document.createElement('button');
  editBtn.className = 'edit-btn';
  editBtn.textContent = '';
  editBtn.onclick = (e) => {
    e.stopPropagation();
    enableSubcardEditMode(subcardElement, subcard, parentCard);
  };
  const subcardInner = document.createElement('div');
  subcardInner.className = 'flashcard-inner';
  subcardInner.innerHTML = `
    <div class="flashcard-front">
      <div>${subcard.question}</div>
    </div>
    <div class="flashcard-back">${subcard.answer}</div>
  `;
  subcardElement.onclick = (e) => {
    e.stopPropagation();
    if (subcardElement.classList.contains('editing')) return;
    openSubcardsModal(parentCard);
  };
  subcardElement.appendChild(deleteBtn);
  subcardElement.appendChild(editBtn);
  subcardElement.appendChild(subcardInner);
  return subcardElement;
}

function createSubcardForModal(subcard) {
  const subcardElement = document.createElement('div');
  subcardElement.className = 'flashcard subcard';
  subcardElement.dataset.subcardId = subcard.id;
  const subcardInner = document.createElement('div');
  subcardInner.className = 'flashcard-inner';
  subcardInner.innerHTML = `
    <div class="flashcard-front">
      <div>${subcard.question}</div>
    </div>
    <div class="flashcard-back">${subcard.answer}</div>
  `;
  subcardElement.onclick = () => {
    subcardElement.classList.toggle('flipped');
    setTimeout(() => {
      if (window.MathJax) {
        MathJax.typesetPromise([subcardElement.querySelector('.flashcard-back')]).catch(err => console.log(err.message));
      }
    }, 500);
  };
  subcardElement.appendChild(subcardInner);
  return subcardElement;
}

/******************************
 * Card Creation Functions    *
 ******************************/
function createCard(card) {
  const cardElement = document.createElement('div');
  cardElement.className = 'flashcard';
  if (card.type === "note") cardElement.classList.add("note");
  cardElement.dataset.cardId = card.id;
  const deleteBtn = document.createElement('button');
  deleteBtn.className = 'delete-btn';
  deleteBtn.textContent = '';
  deleteBtn.onclick = (e) => {
    e.stopPropagation();
    currentCards = currentCards.filter(c => c.id !== card.id);
    saveCards();
    renderCards();
  };
  const editBtn = document.createElement('button');
  editBtn.className = 'edit-btn';
  editBtn.textContent = '';
  editBtn.onclick = (e) => {
    e.stopPropagation();
    enableEditMode(cardElement, card);
  };
  const cardInner = document.createElement('div');
  cardInner.className = 'flashcard-inner';
  cardInner.innerHTML = `
    <div class="flashcard-front">
      ${card.category ? `<div style="font-weight:bold; margin-bottom:8px;">${card.category}</div>` : ''}
      <div>${card.question}</div>
    </div>
    <div class="flashcard-back">${card.answer}</div>
  `;
  cardElement.onclick = () => {
    if (!cardElement.classList.contains('editing')) {
      cardElement.classList.toggle('flipped');
      setTimeout(() => {
        if (window.MathJax) {
          MathJax.typesetPromise([cardInner.querySelector('.flashcard-back')]).catch(err => console.log(err.message));
        }
      }, 500);
    }
  };
  cardElement.appendChild(deleteBtn);
  cardElement.appendChild(editBtn);
  cardElement.appendChild(cardInner);
  if (card.subcards && card.subcards.length > 0) {
    const toggleSubcardsBtn = document.createElement('button');
    toggleSubcardsBtn.textContent = 'Show Subcards';
    toggleSubcardsBtn.style.marginTop = '10px';
    toggleSubcardsBtn.style.padding = '6px 12px';
    toggleSubcardsBtn.style.background = '#667eea';
    toggleSubcardsBtn.style.color = '#fff';
    toggleSubcardsBtn.style.border = 'none';
    toggleSubcardsBtn.style.borderRadius = '5px';
    toggleSubcardsBtn.style.cursor = 'pointer';
    toggleSubcardsBtn.onclick = (e) => {
      e.stopPropagation();
      openSubcardsModal(card);
    };
    cardElement.appendChild(toggleSubcardsBtn);
  }
  if (card.type === "note") {
    const expandBtn = document.createElement('button');
    expandBtn.textContent = 'Expand';
    expandBtn.style.marginTop = '10px';
    expandBtn.style.padding = '6px 12px';
    expandBtn.style.background = '#28a745';
    expandBtn.style.color = '#fff';
    expandBtn.style.border = 'none';
    expandBtn.style.borderRadius = '5px';
    expandBtn.style.cursor = 'pointer';
    expandBtn.onclick = (e) => {
      e.stopPropagation();
      openNoteModal(card);
    };
    cardElement.appendChild(expandBtn);
  }
  return cardElement;
}

/******************************
 * Edit Mode Functions        *
 ******************************/
function enableSubcardEditMode(subcardElement, subcard, parentCard) {
  subcardElement.classList.add('editing');
  const subcardInner = subcardElement.querySelector('.flashcard-inner');
  const originalContent = subcardInner.innerHTML;
  subcardInner.innerHTML = '';
  const editContainer = document.createElement('div');
  editContainer.className = 'edit-mode';
  const questionInput = document.createElement('input');
  questionInput.type = 'text';
  questionInput.value = subcard.question;
  questionInput.placeholder = 'Subcard Question';
  const answerInput = document.createElement('textarea');
  answerInput.rows = 4;
  answerInput.value = subcard.answer;
  answerInput.placeholder = 'Subcard Answer (LaTeX supported)';
  const saveBtn = document.createElement('button');
  saveBtn.className = 'save-btn';
  saveBtn.textContent = 'Save';
  saveBtn.onclick = (e) => {
    e.stopPropagation();
    subcard.question = questionInput.value.trim();
    subcard.answer = answerInput.value.trim();
    saveCards();
    renderCards();
  };
  const cancelBtn = document.createElement('button');
  cancelBtn.className = 'cancel-btn';
  cancelBtn.textContent = 'Cancel';
  cancelBtn.onclick = (e) => {
    e.stopPropagation();
    subcardInner.innerHTML = originalContent;
    subcardElement.classList.remove('editing');
  };
  editContainer.appendChild(questionInput);
  editContainer.appendChild(answerInput);
  editContainer.appendChild(saveBtn);
  editContainer.appendChild(cancelBtn);
  subcardInner.appendChild(editContainer);
}

function enableEditMode(cardElement, card) {
  cardElement.classList.add('editing');
  const cardInner = cardElement.querySelector('.flashcard-inner');
  const originalContent = cardInner.innerHTML;
  
  // Check if we're in fullscreen mode
  const isFullscreen = document.fullscreenElement;
  
  if (isFullscreen) {
    // Create edit panel for fullscreen mode
    openEditPanel(card, () => {
      cardElement.classList.remove('editing');
    });
  } else {
    // Regular edit mode (non-fullscreen)
    const editContainer = document.createElement('div');
    editContainer.className = 'edit-mode';
    const categoryInput = document.createElement('input');
    categoryInput.type = 'text';
    categoryInput.value = card.category || '';
    categoryInput.placeholder = 'Category';
    categoryInput.setAttribute('list', 'categoryList');
    const questionInput = document.createElement('input');
    questionInput.type = 'text';
    questionInput.value = card.question || '';
    questionInput.placeholder = 'Question / Title';
    const answerInput = document.createElement('textarea');
    answerInput.rows = card.type === "note" ? 6 : 4;
    answerInput.value = card.answer || '';
    answerInput.placeholder = 'Answer or note content (LaTeX supported)';
    const buttonGroup = document.createElement('div');
    buttonGroup.className = 'button-group';
    const saveBtn = document.createElement('button');
    saveBtn.className = 'save-btn';
    saveBtn.textContent = 'Save Changes';
    saveBtn.onclick = (e) => {
      e.stopPropagation();
      
      // Trigger close animation first
      editContainer.classList.remove('expanded');
      
      // Add delay to allow animation to complete before updating
      setTimeout(() => {
        card.category = categoryInput.value.trim();
        card.question = questionInput.value.trim();
        card.answer = answerInput.value.trim();
        saveCards();
        renderCards();
      }, 400); // Match this with transition time
    };
    const cancelBtn = document.createElement('button');
    cancelBtn.className = 'cancel-btn';
    cancelBtn.textContent = 'Cancel';
    cancelBtn.onclick = (e) => {
      e.stopPropagation();
      
      // Trigger close animation first
      editContainer.classList.remove('expanded');
      
      // Wait for animation to complete before restoring original content
      setTimeout(() => {
        cardInner.innerHTML = originalContent;
        cardElement.classList.remove('editing');
      }, 400); // Match this with transition time
    };
    buttonGroup.appendChild(saveBtn);
    buttonGroup.appendChild(cancelBtn);
    const subcardsSection = document.createElement('div');
    subcardsSection.className = 'subcards-section';
    const subcardsHeader = document.createElement('div');
    subcardsHeader.className = 'subcards-header';
    const subcardsLabel = document.createElement('h3');
    subcardsLabel.textContent = 'Subcards';
    const addSubcardBtn = document.createElement('button');
    addSubcardBtn.className = 'add-subcard-btn';
    addSubcardBtn.textContent = '+ Add Subcard';
    addSubcardBtn.onclick = (e) => {
      e.stopPropagation();
      const newSubcard = {
        id: `card-${Date.now()}-${Math.random()}`,
        question: 'New Subcard',
        answer: 'Subcard answer',
        type: 'subcard'
      };
      if (!card.subcards) card.subcards = [];
      card.subcards.push(newSubcard);
      saveCards();
      renderCards();
    };
    subcardsHeader.appendChild(subcardsLabel);
    subcardsHeader.appendChild(addSubcardBtn);
    const subcardsContainer = document.createElement('div');
    subcardsContainer.className = 'subcards-container';
    if (!card.subcards) card.subcards = [];
    card.subcards.forEach(subcard => {
      subcardsContainer.appendChild(createSubcard(subcard, card));
    });
    editContainer.appendChild(categoryInput);
    editContainer.appendChild(questionInput);
    editContainer.appendChild(answerInput);
    editContainer.appendChild(buttonGroup);
    editContainer.appendChild(subcardsSection);
    subcardsSection.appendChild(subcardsHeader);
    subcardsSection.appendChild(subcardsContainer);
    cardInner.innerHTML = '';
    cardInner.appendChild(editContainer);
    
    // Trigger animation after DOM update (using setTimeout with 0 delay)
    setTimeout(() => {
      editContainer.classList.add('expanded');
    }, 10);
  }
}

/******************************
 * Adding New Cards / Notes   *
 ******************************/
function addNewCard() {
  const categoryInput = document.getElementById('category');
  const questionInput = document.getElementById('question');
  const answerInput = document.getElementById('answer');
  const category = categoryInput.value.trim();
  const question = questionInput.value.trim();
  const answer = answerInput.value.trim();
  if (question && answer) {
    currentCards.push({
      id: `card-${Date.now()}-${Math.random()}`,
      category,
      question,
      answer,
      type: "card"
    });
    saveCards();
    renderCards();
    categoryInput.value = '';
    questionInput.value = '';
    answerInput.value = '';
  }
}

function addNewNote() {
  const categoryInput = document.getElementById('category');
  const questionInput = document.getElementById('question');
  const answerInput = document.getElementById('answer');
  const category = categoryInput.value.trim();
  const question = questionInput.value.trim();
  const answer = answerInput.value.trim();
  if (question && answer) {
    currentCards.push({
      id: `card-${Date.now()}-${Math.random()}`,
      category,
      question,
      answer,
      type: "note"
    });
    saveCards();
    renderCards();
    categoryInput.value = '';
    questionInput.value = '';
    answerInput.value = '';
  }
}

function shuffleCards() {
  for (let i = currentCards.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [currentCards[i], currentCards[j]] = [currentCards[j], currentCards[i]];
  }
  saveCards();
  renderCards();
}

/******************************
 * Connexion Mode Functions   *
 ******************************/
function enterConnexionMode() {
  loadConnections();
  const filterValue = document.getElementById('filterCategory').value;
  const filteredCards = filterValue === 'all'
    ? currentCards
    : currentCards.filter(card => card.category === filterValue);
  if (filteredCards.length === 0) {
    alert('No cards to connect in the selected category!');
    return;
  }
  isSegregated = false;
  originalPositions = {};
  assignInitialPositions(filteredCards);
  currentFilteredCards = filteredCards;
  renderConnexionCanvas(filteredCards);
  document.getElementById('cardContainer').style.display = 'none';
  document.getElementById('connexionCanvas').style.display = 'block';
  document.querySelector('.input-panel').style.display = 'none';
  document.querySelector('.button-panel').style.display = 'none';
  

  if (!globalEventHandlersInitialized) {
    initializeGlobalEventHandlers();
    globalEventHandlersInitialized = true;
  }
}

function exitConnexionMode() {
  activeConnectionCreation = false;
  document.getElementById('cardContainer').style.display = 'flex';
  document.getElementById('connexionCanvas').style.display = 'none';
  document.querySelector('.input-panel').style.display = 'flex';
  document.querySelector('.button-panel').style.display = 'flex';
  
  saveCards();
  saveConnections();
  renderCards();
}

function initializeGlobalEventHandlers() {
  document.addEventListener('mousemove', handleGlobalMouseMove);
  document.addEventListener('mouseup', handleGlobalMouseUp);
}

function handleGlobalMouseMove(e) {
  if (!activeDrag.isDragging) return;
  const newLeft = e.clientX - activeDrag.startX;
  const newTop = e.clientY - activeDrag.startY;
  activeDrag.element.style.left = `${newLeft}px`;
  activeDrag.element.style.top = `${newTop}px`;
  if (activeDrag.element.classList.contains('connexion-card')) {
    const cardId = activeDrag.element.dataset.id;
    const card = currentCards.find(c => c.id === cardId);
    if (card) {
      card.x = newLeft;
      card.y = newTop;
      if (!activeConnectionCreation) {
        highlightNearbyCards(card);
      }
    }
  }
}

function handleGlobalMouseUp(e) {
  if (!activeDrag.isDragging) return;
  const element = activeDrag.element;
  element.style.zIndex = '';
  if (element.classList.contains('connexion-card')) {
    const cardId = element.dataset.id;
    const card = currentCards.find(c => c.id === cardId);
    if (card && !activeConnectionCreation) {
      detectAndCreateConnections(card, currentFilteredCards);
    }
  }
  activeDrag.isDragging = false;
  activeDrag.element = null;
}

function assignInitialPositions(cards) {
  const gridSize = 220;
  const numCols = Math.floor(window.innerWidth / gridSize);
  cards.forEach((card, index) => {
    if (card.x === undefined || card.y === undefined) {
      const row = Math.floor(index / numCols);
      const col = index % numCols;
      card.x = col * gridSize + 50;
      card.y = row * gridSize + 50;
    }
  });
}

function renderConnexionCanvas(cards) {
  const canvas = document.getElementById('connexionCanvas');
  canvas.innerHTML = '';
  const backBtn = document.createElement('button');
  backBtn.textContent = 'Back to Flashcards';
  backBtn.style.position = 'absolute';
  backBtn.style.top = '10px';
  backBtn.style.left = '10px';
  backBtn.style.padding = '10px 20px';
  backBtn.style.background = '#ff4757';
  backBtn.style.color = '#fff';
  backBtn.style.border = 'none';
  backBtn.style.borderRadius = '5px';
  backBtn.style.cursor = 'pointer';
  backBtn.style.zIndex = '1000';
  backBtn.onclick = exitConnexionMode;
  canvas.appendChild(backBtn);
  const segregateBtn = document.createElement('button');
  segregateBtn.id = 'segregateBtn';
  segregateBtn.textContent = isSegregated ? 'Restore' : 'Segregate';
  segregateBtn.style.position = 'absolute';
  segregateBtn.style.top = '10px';
  segregateBtn.style.right = '10px';
  segregateBtn.style.padding = '10px 20px';
  segregateBtn.style.background = '#28a745';
  segregateBtn.style.color = '#fff';
  segregateBtn.style.border = 'none';
  segregateBtn.style.borderRadius = '5px';
  segregateBtn.style.cursor = 'pointer';
  segregateBtn.style.zIndex = '1000';
  segregateBtn.onclick = () => toggleSegregate(cards);
  canvas.appendChild(segregateBtn);
  const toggleViewBtn = document.createElement('button');
  toggleViewBtn.id = 'toggleViewBtn';
  toggleViewBtn.className = 'mind-map-button';
  toggleViewBtn.textContent = 'Mind Map View';
  toggleViewBtn.style.position = 'absolute';
  toggleViewBtn.style.top = '10px';
  toggleViewBtn.style.left = '170px';
  toggleViewBtn.style.padding = '10px 15px';

  toggleViewBtn.style.color = ' linear-gradient(45deg, #2c3e50, #3498db)';
  toggleViewBtn.style.border = 'none';
  toggleViewBtn.style.borderRadius = '5px';
  toggleViewBtn.style.cursor = 'pointer';
  toggleViewBtn.style.zIndex = '1000';
  toggleViewBtn.onclick = toggleMindMapView;
  canvas.appendChild(toggleViewBtn);
  const gridView = document.createElement('div');
  gridView.id = 'gridView';
  gridView.style.position = 'relative';
  gridView.style.width = '100%';
  gridView.style.height = '100%';
  canvas.appendChild(gridView);
  const mindMapView = document.createElement('div');
  mindMapView.id = 'mindMapView';
  mindMapView.style.position = 'absolute';
  mindMapView.style.top = '0';
  mindMapView.style.left = '0';
  mindMapView.style.width = '100%';
  mindMapView.style.height = '100%';
  mindMapView.style.display = 'none';
  canvas.appendChild(mindMapView);
  const connectedCardIds = new Set(connections.flatMap(conn => conn.cards));
  const unconnectedCards = cards.filter(card => !connectedCardIds.has(card.id));
  unconnectedCards.forEach(card => {
    const cardDiv = createConnexionCard(card, false);
    cardDiv.style.left = `${card.x}px`;
    cardDiv.style.top = `${card.y}px`;
    gridView.appendChild(cardDiv);
    makeDraggable(cardDiv, card, cards);
  });
  const panelWidth = 450;
  const panelHeight = 200;
  const margin = 20;
  let panelX = 20;
  let panelY = 60;
  const canvasWidth = gridView.clientWidth || canvas.clientWidth;
  connections.forEach(conn => {
  if (!conn.cards || !Array.isArray(conn.cards)) {
    console.warn('Connection missing cards array:', conn);
    return;
  }
    const connCards = conn.cards.map(id => cards.find(c => c.id === id)).filter(Boolean);
    if (connCards.length === conn.cards.length) {
      const panel = document.createElement('div');
      panel.className = 'connection-panel';
      panel.style.position = 'absolute';
      panel.style.left = `${panelX}px`;
      panel.style.top = `${panelY}px`;
      panel.style.border = `2px solid ${conn.color || '#000'}`;
      panel.innerHTML = `
        <div class="connection-cards">
          ${conn.cards.map(cardId => {
            const card = cards.find(c => c.id === cardId);
            return `
              <div class="connection-card">
                <h4>${card.category || 'General'}</h4>
                <p>${card.question}</p>
              </div>
            `;
          }).join('')}
        </div>
        <div class="connection-description">${conn.description}</div>
        <div class="connection-buttons">
          <button class="edit-connection">Edit</button>
          <button class="view-connection">View</button>
          <button class="remove-connection">Remove</button>
        </div>
      `;
      gridView.appendChild(panel);
      makePanelDraggable(panel);
      panel.querySelector('.edit-connection').addEventListener('click', () => editConnection(conn.id, cards));
      panel.querySelector('.view-connection').addEventListener('click', () => viewConnection(conn.id, cards));
      panel.querySelector('.remove-connection').addEventListener('click', () => removeConnection(conn.id, cards));
      panelX += panelWidth + margin;
      if (panelX + panelWidth > canvasWidth) {
        panelX = 20;
        panelY += panelHeight + margin;
      }
    }
  });
}

function createConnexionCard(card, inContainer) {
  const cardDiv = document.createElement('div');
  cardDiv.className = 'connexion-card';
  cardDiv.dataset.id = card.id;
  cardDiv.style.position = 'absolute';
  cardDiv.style.width = '200px';
  cardDiv.style.height = '150px';
  cardDiv.style.backgroundColor = card.color || '#f0f0f0';
  cardDiv.innerHTML = `
    <div class="connexion-card-inner">
      <div class="connexion-card-front">
        <h4>${card.category || 'General'}</h4>
        <p>${card.question}</p>
      </div>
      <div class="connexion-card-back">
        <p>${card.answer}</p>
      </div>
    </div>
  `;
  cardDiv.addEventListener('dblclick', (e) => {
    e.stopPropagation();
    cardDiv.classList.toggle('flipped');
    setTimeout(() => {
      if (window.MathJax) {
        MathJax.typesetPromise([cardDiv.querySelector('.connexion-card-back')]).catch(err => console.log(err.message));
      }
    }, 500);
  });
  if (!inContainer) {
    makeDraggable(cardDiv, card, currentFilteredCards);
  }
  return cardDiv;
}

function makeDraggable(element, card, allCards) {
  let isDragging = false;
  let startX, startY;
  element.addEventListener('mousedown', e => {
    isDragging = true;
    startX = e.clientX - element.offsetLeft;
    startY = e.clientY - element.offsetTop;
    element.style.zIndex = '1000';
    activeDrag = { element, isDragging: true, startX, startY };
  });
  document.addEventListener('mousemove', e => {
    if (isDragging) {
      const newLeft = e.clientX - startX;
      const newTop = e.clientY - startY;
      element.style.left = `${newLeft}px`;
      element.style.top = `${newTop}px`;
      card.x = newLeft;
      card.y = newTop;
      allCards.forEach(otherCard => {
        if (otherCard.id !== card.id) {
          const otherElem = document.querySelector(`.connexion-card[data-id="${otherCard.id}"]`);
          if (otherElem) {
            const cardRect = element.getBoundingClientRect();
            const otherRect = otherElem.getBoundingClientRect();
            if (Math.abs(cardRect.left - otherRect.left) < 100 && Math.abs(cardRect.top - otherRect.top) < 100) {
              otherElem.style.border = '2px solid red';
            } else {
              otherElem.style.border = '';
            }
          }
        }
      });
    }
  });
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      element.style.zIndex = '';
    }
  });
}

function makePanelDraggable(element) {
  let isDragging = false;
  let startX, startY;
  element.addEventListener('mousedown', e => {
    isDragging = true;
    startX = e.clientX - element.offsetLeft;
    startY = e.clientY - element.offsetTop;
    element.style.zIndex = '1000';
  });
  document.addEventListener('mousemove', e => {
    if (isDragging) {
      const newLeft = e.clientX - startX;
      const newTop = e.clientY - startY;
      element.style.left = `${newLeft}px`;
      element.style.top = `${newTop}px`;
    }
  });
  document.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      element.style.zIndex = '';
    }
  });
}

function detectAndCreateConnections(draggedCard, allCards) {
  const connectedCardIds = new Set(connections.flatMap(conn => conn.cards));
  const unconnectedCards = allCards.filter(card => !connectedCardIds.has(card.id));
  
  // If dragged card is already connected, return
  if (!unconnectedCards.some(card => card.id === draggedCard.id)) return;

  // Find nearby cards
  const nearbyCards = unconnectedCards.filter(card => {
    if (card.id === draggedCard.id) return false;
    
    // Calculate center points of cards
    const draggedElem = document.querySelector(`.connexion-card[data-id="${draggedCard.id}"]`);
    const cardElem = document.querySelector(`.connexion-card[data-id="${card.id}"]`);
    
    if (!draggedElem || !cardElem) return false;

    const draggedRect = draggedElem.getBoundingClientRect();
    const cardRect = cardElem.getBoundingClientRect();

    // Calculate centers
    const draggedCenter = {
      x: draggedRect.left + draggedRect.width / 2,
      y: draggedRect.top + draggedRect.height / 2
    };
    const cardCenter = {
      x: cardRect.left + cardRect.width / 2,
      y: cardRect.top + cardRect.height / 2
    };

    // Calculate distance between centers
    const distance = Math.sqrt(
      Math.pow(draggedCenter.x - cardCenter.x, 2) + 
      Math.pow(draggedCenter.y - cardCenter.y, 2)
    );

    // Return true if cards are close enough (150px threshold)
    return distance < 150;
  });

  // If we found nearby cards, create a connection
  if (nearbyCards.length > 0) {
    const cardsToConnect = [draggedCard, ...nearbyCards];
    const cardQuestions = cardsToConnect.map(c => c.question).join(', ');
    
    if (confirm(`Create a connection between these cards: ${cardQuestions}?`)) {
      const description = prompt('Enter a description for this connection:') || 'New connection';
      const connectionTag = prompt("Enter a tag for this connection (e.g., cause-effect, analogy):", "general");
      const connectionColor = prompt("Enter a color for this connection (hex code, e.g., #FF0000):", "#000000");
      
      const newConn = {
        id: `conn-${Date.now()}-${Math.random()}`,
        cards: cardsToConnect.map(c => c.id),
        description,
        tag: connectionTag,
        color: connectionColor
      };

      connections.push(newConn);
      saveConnections();
      renderConnexionCanvas(allCards);
    }
  }
}

// Original checkForNewConnection (kept for reference but not used)
function checkForNewConnection(card, allCards) {
  // This function is replaced by detectAndCreateConnections
}

function toggleSegregate(cards) {
  const canvas = document.getElementById('connexionCanvas');
  if (isSegregated) {
    Object.keys(originalPositions).forEach(id => {
      const elem = document.querySelector(`[data-id="${id}"]`) || document.querySelector(`.connection-panel[data-conn-id="${id}"]`);
      if (elem) {
        elem.style.left = originalPositions[id].x + 'px';
        elem.style.top = originalPositions[id].y + 'px';
      }
    });
    const separator = document.getElementById('separatorLine');
    if (separator) separator.remove();
    isSegregated = false;
    document.getElementById('segregateBtn').textContent = 'Segregate';
  } else {
    originalPositions = {};
    cards.forEach(card => {
      const elem = document.querySelector(`[data-id="${card.id}"]`);
      if (elem) {
        originalPositions[card.id] = { x: parseFloat(elem.style.left || card.x), y: parseFloat(elem.style.top || card.y) };
      }
    });
    connections.forEach(conn => {
      const panel = Array.from(document.querySelectorAll('.connection-panel')).find(p => p.dataset.connId === conn.id);
      if (panel) {
        originalPositions[conn.id] = { x: parseFloat(panel.style.left), y: parseFloat(panel.style.top) };
        panel.dataset.connId = conn.id;
      }
    });
    const panelWidth = 450;
    const cardWidth = 200;
    const margin = 20;
    let panelX = 20;
    let panelY = 40;
    connections.forEach(conn => {
      const panel = Array.from(document.querySelectorAll('.connection-panel')).find(p => p.dataset.connId === conn.id);
      if (panel) {
        panel.style.left = `${panelX}px`;
        panel.style.top = `${panelY}px`;
        panel.style.transition = 'all 0.5s ease';
        panelX += panelWidth + margin;
        if (panelX + panelWidth > canvas.clientWidth / 2) {
          panelX = 20;
          panelY += 220;
        }
      }
    });
    const connectedCardIds = new Set(connections.flatMap(conn => conn.cards));
    const unconnectedCards = cards.filter(card => !connectedCardIds.has(card.id));
    const cardHeight = 170;
    const rightSideStart = canvas.clientWidth / 2 + margin;
    const availableWidth = canvas.clientWidth / 2 - margin;
    const cardsPerRow = Math.floor(availableWidth / (cardWidth + margin));
    unconnectedCards.forEach((card, index) => {
      const row = Math.floor(index / cardsPerRow);
      const col = index % cardsPerRow;
      const x = rightSideStart + col * (cardWidth + margin);
      const y = 100 + row * (cardHeight + margin);
      const cardElem = document.querySelector(`.connexion-card[data-id="${card.id}"]`);
      if (cardElem) {
        cardElem.style.left = `${x}px`;
        cardElem.style.top = `${y}px`;
        cardElem.style.transition = 'all 0.5s ease';
        card.x = x;
        card.y = y;
      }
    });
    let separator = document.getElementById('separatorLine');
    if (!separator) {
      separator = document.createElement('div');
      separator.id = 'separatorLine';
      separator.style.position = 'absolute';
      separator.style.backgroundColor = 'black';
      separator.style.width = '2px';
      separator.style.top = '0';
      separator.style.height = canvas.clientHeight + 'px';
      canvas.appendChild(separator);
    }
    separator.style.left = canvas.clientWidth / 2 + 'px';
    isSegregated = true;
    document.getElementById('segregateBtn').textContent = 'Restore';
  }
}

function renderMindMap(cards, connections) {
  const container = d3.select("#mindMapView");
  if (container.empty()) {
    console.error("No container found with id 'mindMapView'");
    return;
  }
  container.selectAll("*").remove();
  const width = container.node().clientWidth || 800;
  const height = container.node().clientHeight || 600;
  const nodes = cards.map(card => ({
    id: card.id,
    question: card.question,
    category: card.category,
    color: card.color || "#ffffff",
    tag: card.tag || ""
  }));
  const links = [];
  connections.forEach(conn => {
    const cardIds = conn.cards;
    for (let i = 0; i < cardIds.length; i++) {
      for (let j = i + 1; j < cardIds.length; j++) {
        links.push({
          source: cardIds[i],
          target: cardIds[j],
          description: conn.description,
          color: conn.color || "#666666",
          tag: conn.tag || ""
        });
      }
    }
  });
  
  // Add zoom and pan functionality
  const svg = container.append("svg")
    .attr("width", width)
    .attr("height", height)
    .style("border", "1px solid white")
    .call(d3.zoom().on("zoom", (event) => {
      g.attr("transform", event.transform);
    }));
    
  // Create a group for all elements to enable zooming
  const g = svg.append("g");
  
  // Rest of your code with g instead of svg for appending elements
  const nodeIds = new Set(nodes.map(node => node.id));
  const validLinks = links.filter(link => nodeIds.has(link.source) && nodeIds.has(link.target));

  // Add links with improved styling
  const link = g.append("g")
    .attr("stroke-opacity", 0.6)
    .selectAll("line")
    .data(validLinks)
    .enter().append("line")
    .attr("stroke", d => d.color)
    .attr("stroke-width", 2)
    .style("cursor", "pointer")
    .on("mouseover", function(event, d) {
      d3.select(this)
        .attr("stroke-width", 4)
        .attr("stroke-opacity", 1);
    })
    .on("mouseout", function(event, d) {
      d3.select(this)
        .attr("stroke-width", 2)
        .attr("stroke-opacity", 0.6);
    })
    .on("click", function(event, d) {
      // Show connection tooltip
      d3.select("#connection-tooltip").remove();
      const tooltip = g.append("g")
        .attr("id", "connection-tooltip")
        .attr("transform", `translate(${(d.source.x + d.target.x) / 2},${(d.source.y + d.target.y) / 2})`);
      
      const tooltipText = tooltip.append("text")
        .attr("text-anchor", "middle")
        .attr("dy", "0.35em")
        .attr("fill", "white")
        .text(d.description);
      
      const textBBox = tooltipText.node().getBBox();
      tooltip.insert("rect", "text")
        .attr("x", textBBox.x - 10)
        .attr("y", textBBox.y - 5)
        .attr("width", textBBox.width + 20)
        .attr("height", textBBox.height + 10)
        .attr("fill", "rgba(0, 0, 0, 0.8)")
        .attr("rx", 5);
      
      setTimeout(() => tooltip.remove(), 3000);
    });

  // Add nodes with improved interaction
  const nodeGroup = g.append("g")
    .selectAll("g")
    .data(nodes)
    .enter().append("g")
    .attr("class", "node-group")
    .call(d3.drag()
      .on("start", dragstarted)
      .on("drag", dragged)
      .on("end", dragended));

  // Add node background rectangles
  nodeGroup.append("rect")
    .attr("rx", 5)
    .attr("ry", 5)
    .attr("fill", d => d.color)
    .attr("stroke", "#333333")
    .attr("stroke-width", 2)
    .on("mouseover", function(event, d) {
      d3.select(this)
        .attr("stroke", "#ff7700")
        .attr("stroke-width", 3);
    })
    .on("mouseout", function(event, d) {
      d3.select(this)
        .attr("stroke", "#333333")
        .attr("stroke-width", 2);
    });

  // Add node text with word wrapping
  nodeGroup.append("text")
    .text(d => d.question)
    .attr("text-anchor", "middle")
    .attr("alignment-baseline", "middle")
    .style("fill", "#333333")
    .style("font-size", "12px")
    .each(function(d) {
      const text = d3.select(this);
      const words = d.question.split(/\s+/);
      const lineHeight = 1.2;
      const maxWidth = 120;
      
      text.text('');
      let line = [];
      let lineNumber = 0;
      let tspan = text.append("tspan")
        .attr("x", 0)
        .attr("dy", 0);
      
      words.forEach(word => {
        line.push(word);
        tspan.text(line.join(" "));
        
        if (tspan.node().getComputedTextLength() > maxWidth) {
          line.pop();
          tspan.text(line.join(" "));
          line = [word];
          tspan = text.append("tspan")
            .attr("x", 0)
            .attr("dy", `${lineHeight}em`)
            .text(word);
          lineNumber++;
        }
      });
      
      const totalHeight = (lineNumber * lineHeight) / 2;
      text.selectAll("tspan")
        .attr("dy", (_, i) => `${i === 0 ? -totalHeight : lineHeight}em`);
    });





    
  // Add padding to rectangles based on text size
  const rectPadding = 20;
  const minWidth = 40;
  const minHeight = 40;
  
  nodeGroup.each(function() {
    const g = d3.select(this);
    const text = g.select("text");
    const bbox = text.node().getBBox();
    
    g.select("rect")
      .attr("x", bbox.x - rectPadding / 2)
      .attr("y", bbox.y - rectPadding / 2)
      .attr("width", Math.max(bbox.width + rectPadding, minWidth))
      .attr("height", Math.max(bbox.height + rectPadding, minHeight));
  });

  // Add category labels
  nodeGroup.append("text")
    .attr("class", "category")
    .text(d => d.category || "")
    .attr("text-anchor", "middle")
    .attr("y", function(d) {
      const rect = d3.select(this.parentNode).select("rect");
      return parseFloat(rect.attr("y")) - 10;
    })
    .attr("fill", "#805ad5")
    .style("font-size", "10px")
    .style("font-weight", "bold");

  // Force simulation setup
  const simulation = d3.forceSimulation(nodes)
    .force("link", d3.forceLink(validLinks).id(d => d.id).distance(150))
    .force("charge", d3.forceManyBody().strength(-300))
    .force("center", d3.forceCenter(width / 2, height / 2));

  // Run simulation for a fixed number of ticks
  for (let i = 0; i < 300; ++i) simulation.tick();
  simulation.stop();
  
  // Fix node positions after simulation
  nodes.forEach(n => { 
    n.fx = n.x; 
    n.fy = n.y; 
  });

  // Update positions of all elements
  function updatePositions() {
    link
      .attr("x1", d => d.source.x)
      .attr("y1", d => d.source.y)
      .attr("x2", d => d.target.x)
      .attr("y2", d => d.target.y);
    
    nodeGroup.attr("transform", d => `translate(${d.x},${d.y})`);
  }
  
  updatePositions();

  // Drag functions
  function dragstarted(event, d) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    d.fx = d.x;
    d.fy = d.y;
  }
  
  function dragged(event, d) {
    d.fx = event.x;
    d.fy = event.y;
    updatePositions();
  }
  
  function dragended(event, d) {
    if (!event.active) simulation.alphaTarget(0);
    d.fx = event.x;
    d.fy = event.y;
    updatePositions();
  }




  
  // Add mind map controls
  const controls = container.append("div")
    .attr("class", "mind-map-controls")
    .style("position", "absolute")
    .style("bottom", "20px")
    .style("left", "20px")
    .style("z-index", "100");
  
  controls.append("button")
    .attr("class", "mind-map-button")
    .text("Reset View")
    .on("click", function() {
      svg.transition().duration(750).call(
        d3.zoom().transform,
        d3.zoomIdentity
      );
    });
  
  controls.append("button")
    .attr("class", "mind-map-button")
    .text("Auto Layout")
    .on("click", function() {
      // Release fixed positions
      nodes.forEach(n => { 
        n.fx = null; 
        n.fy = null; 
      });
      
      // Restart simulation
      simulation.alpha(1).restart();
      
      // Update during simulation
      simulation.on("tick", updatePositions);
      
      // Stop and fix positions after simulation
      setTimeout(() => {
        simulation.stop();
        nodes.forEach(n => { 
          n.fx = n.x; 
          n.fy = n.y; 
        });
      }, 2000);
    });
}

function toggleMindMapView() {
  const gridView = document.getElementById('gridView');
  const mindMapView = document.getElementById('mindMapView');
  const toggleBtn = document.getElementById('toggleViewBtn');
  if (mindMapView.style.display === "none") {
    gridView.style.display = "none";
    mindMapView.style.display = "block";
    toggleBtn.textContent = "Grid View";
    renderMindMap(currentFilteredCards, connections);
    // Initialize context menu after rendering the mind map
    addMindMapContextMenu();
  } else {
    mindMapView.style.display = "none";
    gridView.style.display = "block";
    toggleBtn.textContent = "Mind Map View";
  }
}

function editConnection(connId, cards) {
  const conn = connections.find(c => c.id === connId);
  if (conn) {
    const newDesc = prompt('Edit connection description:', conn.description);
    if (newDesc !== null) {
      conn.description = newDesc;
      saveConnections();
      renderConnexionCanvas(cards);
    }
  }
}

function viewConnection(connId, cards) {
  const conn = connections.find(c => c.id === connId);
  if (conn) {
    const cardQuestions = conn.cards.map(id => {
      const card = cards.find(c => c.id === id);
      return card ? card.question : 'Unknown';
    }).join(', ');
    alert(`Connection Details:\n\nCards: ${cardQuestions}\nDescription: ${conn.description}`);
  }
}

function removeConnection(connId, cards) {
  if (confirm('Are you sure you want to remove this connection?')) {
    connections = connections.filter(c => c.id !== connId);
    saveConnections();
    renderConnexionCanvas(cards);
  }
}

/******************************

/******************************
 * Practice Mode Functions    *
 ******************************/
let practiceCards = [];
let currentCardIndex = 0;
let isMobileMode = false;

function toggleMobileMode() {
  isMobileMode = !isMobileMode;
  const switchBtn = document.getElementById('modeSwitchBtn');
  if (switchBtn) {
    switchBtn.textContent = isMobileMode ? 'Switch to Desktop Mode' : 'Switch to Mobile Mode';
  }
  updatePracticeDeck();
}

function startPracticeMode() {
  const flashcards = currentCards.filter(card => card.type === "card");
  if (flashcards.length === 0) return alert('No flashcards to practice!');
  document.getElementById('practiceDeck').style.display = 'flex';
  document.querySelector('.flashcard-container').style.display = 'none';
  document.querySelector('.input-panel').style.display = 'none';
  document.querySelector('.button-panel').style.display = 'none';
  

  if (!document.getElementById('modeSwitchBtn')) {
    const modeSwitchBtn = document.createElement('button');
    modeSwitchBtn.id = 'modeSwitchBtn';
    modeSwitchBtn.style.marginBottom = '20px';
    modeSwitchBtn.style.padding = '10px 15px';
    modeSwitchBtn.style.background = '#28a745';
    modeSwitchBtn.style.color = '#fff';
    modeSwitchBtn.style.border = 'none';
    modeSwitchBtn.style.borderRadius = '5px';
    modeSwitchBtn.style.cursor = 'pointer';
    modeSwitchBtn.textContent = 'Switch to Mobile Mode';
    modeSwitchBtn.onclick = toggleMobileMode;
    document.getElementById('practiceDeck').appendChild(modeSwitchBtn);
  }
  initializePracticeDeck(flashcards);
}

function exitPracticeMode() {
  document.getElementById('practiceDeck').style.display = 'none';
  document.querySelector('.flashcard-container').style.display = 'flex';
  document.querySelector('.input-panel').style.display = 'flex';
  document.querySelector('.button-panel').style.display = 'flex';
 
}

function initializePracticeDeck(flashcards) {
  const container = document.getElementById('practiceDeckContainer');
  container.innerHTML = '';
  practiceCards = [];
  flashcards.forEach((card, index) => {
    const cardElement = document.createElement('div');
    cardElement.className = 'practice-card';
    cardElement.innerHTML = `
      <div class="practice-card-face practice-card-front">
        <h2>${card.category || 'General'}</h2>
        <p>${card.question}</p>
      </div>
      <div class="practice-card-face practice-card-back">
        ${card.answer}
      </div>
    `;
    cardElement.addEventListener('click', (e) => {
      const rect = cardElement.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const halfWidth = rect.width / 2;
      cardElement.classList.remove('flip-left', 'flip-right');
      if (clickX < halfWidth) {
        cardElement.classList.add('flip-left');
      } else {
        cardElement.classList.add('flip-right');
      }
      cardElement.classList.toggle('flipped');
      updatePracticeDeck();
      setTimeout(() => {
        if (window.MathJax) MathJax.typesetPromise();
      }, 500);
    });
    practiceCards.push(cardElement);
    container.appendChild(cardElement);
  });
  currentCardIndex = 0;
  updatePracticeDeck();
  if (window.MathJax) MathJax.typesetPromise();
}

function updatePracticeDeck() {
  practiceCards.forEach((card, index) => {
    const diffIndex = index - currentCardIndex;
    const offset = isMobileMode ? diffIndex * 30 : diffIndex * 50;
    const scale = isMobileMode ? 1 - Math.abs(diffIndex) * 0.05 : 1 - Math.abs(diffIndex) * 0.08;
    let transformStr = `translateX(${offset}px) scale(${scale})`;
    if (card.classList.contains('flipped')) {
      if (card.classList.contains('flip-left')) {
        transformStr += ' rotateY(-180deg) rotateX(-3deg)';
      } else {
        transformStr += ' rotateY(180deg) rotateX(3deg)';
      }
    }
    card.style.transform = transformStr;
    card.style.zIndex = practiceCards.length - Math.abs(diffIndex);
    card.classList.toggle('active', index === currentCardIndex);
    if (isMobileMode) {
      card.style.width = '90%';
      card.style.margin = '10px auto';
      card.style.fontSize = '1.5em';
    } else {
      card.style.width = '50%';
      card.style.height = '90%';
      card.style.margin = '';
      card.style.fontSize = '';
    }
  });
}

function showNextCard() {
  currentCardIndex = (currentCardIndex + 1) % practiceCards.length;
  updatePracticeDeck();
}

function showPrevCard() {
  currentCardIndex = (currentCardIndex - 1 + practiceCards.length) % practiceCards.length;
  updatePracticeDeck();
}

let touchStartX = 0;
document.getElementById('practiceDeckContainer').addEventListener('touchstart', e => {
  touchStartX = e.touches[0].clientX;
});
document.getElementById('practiceDeckContainer').addEventListener('touchend', e => {
  const touchEndX = e.changedTouches[0].clientX;
  const diff = touchStartX - touchEndX;
  if (Math.abs(diff) > 50) {
    if (diff > 0) showNextCard();
    else showPrevCard();
  }
});
function initializePanelInteractions(element) {
  let isDragging = false;
  let currentX;
  let currentY;
  let initialX;
  let initialY;
  let xOffset = 0;
  let yOffset = 0;

  // Touch Events for all draggable elements
  element.addEventListener('touchstart', startDragging);
  element.addEventListener('touchmove', drag);
  element.addEventListener('touchend', stopDragging);
  element.addEventListener('touchcancel', stopDragging);

  // Mouse Events for desktop compatibility
  element.addEventListener('mousedown', startDragging);
  element.addEventListener('mousemove', drag);
  element.addEventListener('mouseup', stopDragging);
  element.addEventListener('mouseleave', stopDragging);

  function startDragging(e) {
    if (e.type === 'mousedown') {
      initialX = e.clientX - xOffset;
      initialY = e.clientY - yOffset;
    } else if (e.type === 'touchstart') {
      initialX = e.touches[0].clientX - xOffset;
      initialY = e.touches[0].clientY - yOffset;
    }

    if (e.target === element || e.target.parentElement === element) {
      isDragging = true;
    }
  }

  function drag(e) {
    if (isDragging) {
      e.preventDefault();

      if (e.type === 'mousemove') {
        currentX = e.clientX - initialX;
        currentY = e.clientY - initialY;
      } else if (e.type === 'touchmove') {
        currentX = e.touches[0].clientX - initialX;
        currentY = e.touches[0].clientY - initialY;
      }

      xOffset = currentX;
      yOffset = currentY;

      setTranslate(currentX, currentY, element);
    }
  }

  function stopDragging() {
    isDragging = false;
  }

  function setTranslate(xPos, yPos, el) {
    el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
  }
}

function createConnexionCard(card) {
  const cardElement = document.createElement('div');
  cardElement.className = 'connexion-card';
  cardElement.dataset.id = card.id; // Changed from cardId to id to match detection logic
  
  cardElement.innerHTML = `
    <h4>${card.question}</h4>
    <p>${card.category || ''}</p>
  `;

  // Make the card draggable
  let isDragging = false;
  let startX, startY;

  cardElement.addEventListener('mousedown', startDrag);
  cardElement.addEventListener('touchstart', startDrag);
  
  function startDrag(e) {
    isDragging = true;
    if (e.type === 'mousedown') {
      startX = e.clientX - cardElement.offsetLeft;
      startY = e.clientY - cardElement.offsetTop;
    } else if (e.type === 'touchstart') {
      startX = e.touches[0].clientX - cardElement.offsetLeft;
      startY = e.touches[0].clientY - cardElement.offsetTop;
    }
    cardElement.style.zIndex = '1000';
  }

  cardElement.addEventListener('mousemove', drag);
  cardElement.addEventListener('touchmove', drag);

  function drag(e) {
    if (!isDragging) return;
    e.preventDefault();
    
    let currentX, currentY;
    if (e.type === 'mousemove') {
      currentX = e.clientX - startX;
      currentY = e.clientY - startY;
    } else if (e.type === 'touchmove') {
      currentX = e.touches[0].clientX - startX;
      currentY = e.touches[0].clientY - startY;
    }

    cardElement.style.left = `${currentX}px`;
    cardElement.style.top = `${currentY}px`;
    
    // Check for nearby cards while dragging
    highlightNearbyCards(card, currentX, currentY);
  }

  cardElement.addEventListener('mouseup', endDrag);
  cardElement.addEventListener('touchend', endDrag);

  function endDrag() {
    if (isDragging) {
      isDragging = false;
      cardElement.style.zIndex = '1';
      detectAndCreateConnections(card, currentFilteredCards);
    }
  }

  return cardElement;
}

function highlightNearbyCards(draggedCard, x, y) {
  const draggedElem = document.querySelector(`.connexion-card[data-id="${draggedCard.id}"]`);
  if (!draggedElem) return;

  const draggedRect = draggedElem.getBoundingClientRect();
  
  document.querySelectorAll('.connexion-card').forEach(cardElem => {
    if (cardElem.dataset.id === draggedCard.id) return;
    
    const cardRect = cardElem.getBoundingClientRect();
    const distance = Math.sqrt(
      Math.pow((draggedRect.left + draggedRect.width/2) - (cardRect.left + cardRect.width/2), 2) +
      Math.pow((draggedRect.top + draggedRect.height/2) - (cardRect.top + cardRect.height/2), 2)
    );

    if (distance < 150) {
      cardElem.classList.add('can-connect');
    } else {
      cardElem.classList.remove('can-connect');
    }
  });
}
document.addEventListener('DOMContentLoaded', function() {
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    if (fullscreenBtn) {
        fullscreenBtn.addEventListener('click', toggleFullscreenView);
    }
});



function toggleFullscreenView() {
  const container = document.querySelector('.flashcard-container');
  const isFullscreen = document.fullscreenElement;
  
  if (!isFullscreen) {
    // Enter fullscreen
    if (container.requestFullscreen) {
      container.requestFullscreen();
    } else if (container.webkitRequestFullscreen) {
      container.webkitRequestFullscreen();
    } else if (container.msRequestFullscreen) {
      container.msRequestFullscreen();
    }
    
    container.classList.add('fullscreen-mode');
    
    // Create dropdown menu
    const dropdown = document.createElement('div');
    dropdown.className = 'fs-dropdown';
    dropdown.innerHTML = `
      <button class="fs-dropdown-btn">
        <span>Menu</span>
        <svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M2 5L8 11L14 5" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
      </button>
      <div class="fs-dropdown-content">
        <div class="fs-dropdown-item" id="fs-nav-prev">
          <i></i> Previous Card
        </div>
        <div class="fs-dropdown-item" id="fs-nav-next">
          <i></i> Next Card
        </div>
        <div class="fs-dropdown-item" id="fs-flip-all">
          <i></i> Flip All Cards
        </div>
        <div class="fs-dropdown-item" id="fs-category-sort">
          <i></i> Sort by Category
        </div>
        <div class="fs-dropdown-item" id="fs-presentation">
          <i></i> Presentation Mode
        </div>
        <div class="fs-dropdown-item" id="fs-theme-toggle">
          <i></i> Toggle Dark Mode
        </div>
        <div class="fs-dropdown-item" id="fs-search">
          <i></i> Search Cards
        </div>
        <div class="fs-dropdown-item" id="fs-exit">
          <i></i> Exit Fullscreen
        </div>
      </div>
    `;
    container.appendChild(dropdown);
    
    // Create category panels container (initially hidden)
    const categoryPanelsContainer = document.createElement('div');
    categoryPanelsContainer.className = 'category-panels-container';
    container.appendChild(categoryPanelsContainer);
    
    // Create back button for category view
    const backBtn = document.createElement('button');
    backBtn.className = 'category-view-back';
    backBtn.textContent = 'Back to All Cards';
    backBtn.onclick = exitCategoryView;
    container.appendChild(backBtn);
    
    // Create exit button
    const exitBtn = document.createElement('button');
    exitBtn.className = 'exit-fullscreen-btn';
    exitBtn.innerHTML = 'Exit Fullscreen';
    exitBtn.onclick = toggleFullscreenView;
    container.appendChild(exitBtn);

    // Initialize fullscreen controls
    initFullscreenControls();

    // Ensure all cards are visible and properly styled
    const cards = container.querySelectorAll('.flashcard');
    cards.forEach(card => {
      card.style.display = 'block';
      card.style.opacity = '1';
      card.style.position = 'relative';
      card.style.left = 'auto';
      card.style.top = 'auto';
      
      // Hide expand button in fullscreen mode
      const expandBtn = card.querySelector('.expand-btn');
      if (expandBtn) {
        expandBtn.style.display = 'none';
      }
    });
    
    // Add keyboard navigation
    document.addEventListener('keydown', handleFullscreenKeyboard);
  } else {
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.msExitFullscreen) {
      document.msExitFullscreen();
    }
    
    container.classList.remove('fullscreen-mode');
    
    // Remove fullscreen controls and exit button
    const dropdown = container.querySelector('.fs-dropdown');
    if (dropdown) dropdown.remove();
    
    const exitBtn = container.querySelector('.exit-fullscreen-btn');
    if (exitBtn) exitBtn.remove();
    
    const categoryPanelsContainer = container.querySelector('.category-panels-container');
    if (categoryPanelsContainer) categoryPanelsContainer.remove();
    
    const backBtn = container.querySelector('.category-view-back');
    if (backBtn) backBtn.remove();
    
    // Reset card styles
    const cards = container.querySelectorAll('.flashcard');
    cards.forEach(card => {
      card.style.transform = '';
      card.style.transition = '';
      card.style.position = '';
      card.style.left = '';
      card.style.top = '';
      
      // Show expand button again when exiting fullscreen
      const expandBtn = card.querySelector('.expand-btn');
      if (expandBtn) {
        expandBtn.style.display = '';
      }
    });
    
    // Remove keyboard event listener
    document.removeEventListener('keydown', handleFullscreenKeyboard);
  }
}


// Initialize fullscreen controls
function initFullscreenControls() {
  const container = document.querySelector('.flashcard-container');
  let currentIndex = 0;
  let presentationMode = false;
  let presentationTimer = null;
  
  // Toggle dropdown menu
  const dropdownBtn = document.querySelector('.fs-dropdown-btn');
  const dropdownContent = document.querySelector('.fs-dropdown-content');
  
  dropdownBtn.addEventListener('click', () => {
    dropdownContent.classList.toggle('show');
  });
  
  // Close dropdown when clicking outside
  window.addEventListener('click', (e) => {
    if (!e.target.matches('.fs-dropdown-btn') && !e.target.closest('.fs-dropdown-btn')) {
      dropdownContent.classList.remove('show');
    }
  });
  
  // Navigation buttons
  document.getElementById('fs-nav-prev').addEventListener('click', () => {
    navigateCards(-1);
    dropdownContent.classList.remove('show');
  });
  
  document.getElementById('fs-nav-next').addEventListener('click', () => {
    navigateCards(1);
    dropdownContent.classList.remove('show');
  });
  
  // Flip all cards
  document.getElementById('fs-flip-all').addEventListener('click', () => {
    const cards = container.querySelectorAll('.flashcard');
    cards.forEach(card => {
      card.classList.toggle('flipped');
    });
    
    // Render LaTeX if needed
    setTimeout(() => {
      if (window.MathJax) {
        MathJax.typesetPromise([container]).catch(err => console.log(err.message));
      }
    }, 500);
    
    dropdownContent.classList.remove('show');
  });
  
  // Sort by category
  document.getElementById('fs-category-sort').addEventListener('click', () => {
    sortByCategory();
    dropdownContent.classList.remove('show');
  });
  
  // Presentation mode
  document.getElementById('fs-presentation').addEventListener('click', (e) => {
    presentationMode = !presentationMode;
    e.target.innerHTML = presentationMode ? 
      '<i></i> Stop Presentation' : 
      '<i></i> Presentation Mode';
    
    if (presentationMode) {
      // Start auto-flipping cards every 5 seconds
      presentationTimer = setInterval(() => {
        const visibleCards = Array.from(container.querySelectorAll('.flashcard:not(.hidden)'));
        if (currentIndex >= visibleCards.length) currentIndex = 0;
        
        // Flip current card if not already flipped
        if (!visibleCards[currentIndex].classList.contains('flipped')) {
          visibleCards[currentIndex].classList.add('flipped');
          
          // Render LaTeX if needed
          setTimeout(() => {
            if (window.MathJax) {
              MathJax.typesetPromise([visibleCards[currentIndex]]).catch(err => console.log(err.message));
            }
          }, 500);
          
          // Wait 3 seconds before moving to next card
          setTimeout(() => {
            currentIndex++;
          }, 3000);
        } else {
          // If already flipped, move to next card
          visibleCards[currentIndex].classList.remove('flipped');
          currentIndex++;
        }
      }, 5000);
    } else {
      // Stop auto-flipping
      clearInterval(presentationTimer);
    }
    
    dropdownContent.classList.remove('show');
  });
  
  // Theme toggle
  document.getElementById('fs-theme-toggle').addEventListener('click', (e) => {
    container.classList.toggle('dark-theme');
    e.target.innerHTML = container.classList.contains('dark-theme') ? 
      '<i></i> Light Mode' : 
      '<i></i> Dark Mode';
    
    dropdownContent.classList.remove('show');
  });
  
  // Search cards
  document.getElementById('fs-search').addEventListener('click', () => {
    const searchTerm = prompt('Enter search term:');
    if (searchTerm) {
      searchCards(searchTerm);
    }
    
    dropdownContent.classList.remove('show');
  });
  
  // Exit fullscreen
  document.getElementById('fs-exit').addEventListener('click', () => {
    toggleFullscreenView();
    dropdownContent.classList.remove('show');
  });
  
  function navigateCards(direction) {
    const visibleCards = Array.from(container.querySelectorAll('.flashcard:not(.hidden)'));
    if (visibleCards.length === 0) return;
    
    // Highlight current card
    visibleCards.forEach(card => card.classList.remove('current-card'));
    
    currentIndex = (currentIndex + direction + visibleCards.length) % visibleCards.length;
    visibleCards[currentIndex].classList.add('current-card');
    
    // Scroll to the card
    visibleCards[currentIndex].scrollIntoView({
      behavior: 'smooth',
      block: 'center'
    });
  }
}

// Handle keyboard navigation in fullscreen mode
function handleFullscreenKeyboard(e) {
  if (!document.fullscreenElement) return;
  
  switch(e.key) {
    case 'ArrowRight':
    case 'ArrowDown':
      document.getElementById('fs-nav-next').click();
      break;
    case 'ArrowLeft':
    case 'ArrowUp':
      document.getElementById('fs-nav-prev').click();
      break;
    case ' ':
      // Space bar to flip current card
      const currentCard = document.querySelector('.flashcard.current-card');
      if (currentCard) {
        currentCard.classList.toggle('flipped');
        setTimeout(() => {
          if (window.MathJax) {
            MathJax.typesetPromise([currentCard]).catch(err => console.log(err.message));
          }
        }, 500);
      }
      break;
    case 'Escape':
      toggleFullscreenView();
      break;
  }
}



// Sort cards by category with animation
function sortByCategory() {
  const container = document.querySelector('.flashcard-container');
  const categoryPanelsContainer = container.querySelector('.category-panels-container');
  const backBtn = container.querySelector('.category-view-back');
  
  // Get all cards and their categories
  const cards = Array.from(container.querySelectorAll('.flashcard'));
  const categories = new Set();
  
  cards.forEach(card => {
    const categoryElement = card.querySelector('.flashcard-front div:first-child');
    const category = categoryElement ? categoryElement.textContent.trim() : 'Uncategorized';
    categories.add(category);
  });
  
  // Clear previous panels
  categoryPanelsContainer.innerHTML = '';
  
  // Create panels for each category with improved styling
  const categoryArray = Array.from(categories);
  
  // Calculate optimal panel layout based on number of categories
  const numCategories = categoryArray.length;
  let cols = 3; // Default to 3 columns
  
  if (numCategories <= 2) cols = 2;
  if (numCategories === 1) cols = 1;
  
  const rows = Math.ceil(numCategories / cols);
  const panelWidth = Math.floor(100 / cols);
  const panelHeight = Math.floor(100 / rows);
  
  categoryArray.forEach((category, index) => {
    const panel = document.createElement('div');
    panel.className = 'category-panel';
    panel.innerHTML = `<div class="category-panel-header">${category}</div><div class="category-cards-container"></div>`;
    
    // Position panel
    const row = Math.floor(index / cols);
    const col = index % cols;
    
    panel.style.width = `${panelWidth}%`;
    panel.style.height = `${panelHeight}%`;
    panel.style.left = `${col * panelWidth}%`;
    panel.style.top = `${row * panelHeight}%`;
    panel.style.background = `linear-gradient(135deg, rgba(25,25,35,0.8), rgba(35,35,60,0.9))`;
    panel.style.backdropFilter = 'blur(10px)';
    panel.style.boxShadow = '0 10px 30px rgba(0,0,0,0.3), inset 0 0 0 1px rgba(255,255,255,0.1)';
    
    categoryPanelsContainer.appendChild(panel);
  });
  
  // Show category panels container and back button
  categoryPanelsContainer.style.display = 'block';
  backBtn.style.display = 'block';
  
  // Group cards by category
  const cardsByCategory = {};
  cards.forEach(card => {
    const categoryElement = card.querySelector('.flashcard-front div:first-child');
    const category = categoryElement ? categoryElement.textContent.trim() : 'Uncategorized';
    
    if (!cardsByCategory[category]) {
      cardsByCategory[category] = [];
    }
    cardsByCategory[category].push(card);
  });
  
  // Add cards to their respective panels with improved layout
  Object.entries(cardsByCategory).forEach(([category, categoryCards]) => {
    const targetPanel = Array.from(categoryPanelsContainer.querySelectorAll('.category-panel'))
      .find(panel => panel.querySelector('.category-panel-header').textContent === category);
    
    if (targetPanel) {
      const cardsContainer = targetPanel.querySelector('.category-cards-container');
      cardsContainer.style.display = 'flex';
      cardsContainer.style.flexWrap = 'wrap';
      cardsContainer.style.justifyContent = 'center';
      cardsContainer.style.alignItems = 'flex-start';
      cardsContainer.style.gap = '15px';
      cardsContainer.style.padding = '15px';
      cardsContainer.style.overflowY = 'auto';
      cardsContainer.style.maxHeight = 'calc(100% - 60px)';
      
      // Calculate optimal card size based on number of cards
      const cardCount = categoryCards.length;
      let cardScale = 0.8; // Default scale
      
      if (cardCount > 8) cardScale = 0.6;
      if (cardCount > 16) cardScale = 0.5;
      if (cardCount > 24) cardScale = 0.4;
      
      categoryCards.forEach((card, idx) => {
        // Store original position
        const cardRect = card.getBoundingClientRect();
        card.dataset.originalLeft = card.style.left || '0px';
        card.dataset.originalTop = card.style.top || '0px';
        
        // Set card index for staggered animation
        card.style.setProperty('--card-index', idx);
        
        // Clone the card to avoid DOM manipulation issues
        const cardClone = card.cloneNode(true);
        cardClone.style.position = 'relative';
        cardClone.style.left = '0';
        cardClone.style.top = '0';
        cardClone.style.margin = '0';
        cardClone.style.transform = `scale(${cardScale})`;
        cardClone.style.transformOrigin = 'center top';
        cardClone.style.width = '200px';
        cardClone.style.height = '250px';
        cardClone.style.opacity = '0';
        cardClone.style.transition = 'all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1)';
        cardClone.dataset.originalCard = card.dataset.cardId;
        
        // Add click handler to flip card
        cardClone.addEventListener('click', () => {
          cardClone.classList.toggle('flipped');
          setTimeout(() => {
            if (window.MathJax) {
              MathJax.typesetPromise([cardClone]).catch(err => console.log(err.message));
            }
          }, 300);
        });
        
        // Add the clone to the panel
        cardsContainer.appendChild(cardClone);
        
        // Hide the original card
        card.style.display = 'none';
        
        // Animate the clone with staggered delay
        setTimeout(() => {
          cardClone.style.opacity = '1';
          cardClone.style.transform = `scale(${cardScale})`;
        }, 50 + idx * 50);
      });
      
      // Add active class to panel to trigger animations
      setTimeout(() => {
        targetPanel.classList.add('active');
      }, 100);
    }
  });
}

// Exit category view and return to normal fullscreen view
function exitCategoryView() {
  const container = document.querySelector('.flashcard-container');
  const categoryPanelsContainer = container.querySelector('.category-panels-container');
  const backBtn = container.querySelector('.category-view-back');
  
  // Hide panels and back button
  categoryPanelsContainer.style.display = 'none';
  backBtn.style.display = 'none';
  
  // Show all original cards
  const cards = Array.from(container.querySelectorAll('.flashcard'));
  cards.forEach((card) => {
    card.style.display = 'block';
    card.style.position = 'relative';
    card.style.left = 'auto';
    card.style.top = 'auto';
    card.style.margin = '';
    card.style.transform = '';
    card.style.transition = '';
    card.style.opacity = '1';
  });
  
  // Clear panels container
  setTimeout(() => {
    categoryPanelsContainer.innerHTML = '';
  }, 500);
}

// ... existing code ...

// Search cards in fullscreen mode
function searchCards(term) {
  if (!term) {
    // If no search term, show all cards
    const cards = document.querySelectorAll('.flashcard-container .flashcard');
    cards.forEach(card => {
      card.style.display = 'block';
      card.classList.remove('hidden');
    });
    return;
  }
  
  const container = document.querySelector('.flashcard-container');
  const cards = container.querySelectorAll('.flashcard');
  const termLower = term.toLowerCase();
  
  // Search through cards
  cards.forEach(card => {
    const frontContent = card.querySelector('.flashcard-front').textContent.toLowerCase();
    const backContent = card.querySelector('.flashcard-back').textContent.toLowerCase();
    
    if (frontContent.includes(termLower) || backContent.includes(termLower)) {
      card.style.display = 'block';
      card.classList.remove('hidden');
      
      // Highlight the card briefly
      card.style.boxShadow = '0 0 20px rgba(255, 255, 255, 0.8)';
      setTimeout(() => {
        card.style.boxShadow = '';
      }, 1500);
    } else {
      card.style.display = 'none';
      card.classList.add('hidden');
    }
  });
}

// Add fadeInScale animation for dropdown menu
document.head.insertAdjacentHTML('beforeend', `
  
    <style>
    @keyframes fadeInScale {
      0% {
        opacity: 0;
        transform: scale(0.9);
      }
      100% {
        opacity: 1;
        transform: scale(1);
      }
    }
    
    /* Dark theme for fullscreen mode */
    .fullscreen-mode.dark-theme {
      background: linear-gradient(125deg, #000000, #121212, #1e1e1e);
    }
    
    .fullscreen-mode.dark-theme .flashcard-front {
      background: linear-gradient(135deg, #2d3436, #636e72);
      color: #f5f5f5;
    }
    
    .fullscreen-mode.dark-theme .flashcard-back {
      background: linear-gradient(135deg, #2c3e50, #34495e);
      color: #f5f5f5;
    }
    
    /* Current card highlight */
    .flashcard.current-card {
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
      transform: scale(1.05) !important;
      z-index: 100;
    }
    
    /* Hidden cards */
    .flashcard.hidden {
      display: none !important;
    }
    
    /* Enhanced category panel styling */
    .category-panel {
      border-radius: 20px;
      transition: all 0.5s cubic-bezier(0.2, 0.8, 0.2, 1);
      overflow: hidden;
      transform: translateY(20px);
      opacity: 0.8;
      background-image: 
        radial-gradient(circle at 20% 30%, rgba(103, 126, 234, 0.15) 0%, transparent 25%),
        radial-gradient(circle at 80% 70%, rgba(118, 75, 162, 0.15) 0%, transparent 25%);
    }
    
    /* Subcards Panel Styling */
    .subcards-panel-container {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 90%;
      height: 90%;
      transform: translate(-50%, -50%) scale(0.95);
      background: rgba(13, 27, 42, 0.75);
      z-index: 3000;
      display: none;
      flex-direction: column;
      padding: 30px;
      box-sizing: border-box;
      opacity: 0;
      transition: all 0.4s cubic-bezier(0.2, 0.8, 0.2, 1);
      backdrop-filter: blur(15px);
      border-radius: 24px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3), 
                 0 1px 2px rgba(255, 255, 255, 0.1) inset,
                 0 -1px 2px rgba(0, 0, 0, 0.2) inset;
      border: 1px solid rgba(255, 255, 255, 0.1);
      overflow: hidden;
    }
    
    .subcards-panel-container.active {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
    
    .subcards-panel-header {
      display: flex;
      align-items: center;
      padding: 15px 0;
      margin-bottom: 25px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.15);
      position: relative;
    }
    
    .subcards-panel-header h2 {
      margin: 0;
      color: #fff;
      font-size: 26px;
      flex-grow: 1;
      text-align: center;
      font-weight: 500;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }
    
    .subcards-panel-back {
      padding: 12px 20px;
      background: linear-gradient(135deg, #ff6b6b, #ff4757);
      color: white;
      border: none;
      border-radius: 12px;
      cursor: pointer;
      font-size: 16px;
      font-weight: 500;
      transition: all 0.3s ease;
      box-shadow: 0 4px 12px rgba(255, 107, 107, 0.4);
      position: relative;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .subcards-panel-back:before {
      content: '';
      margin-right: 8px;
      font-size: 18px;
    }
    
    .subcards-panel-back:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(255, 107, 107, 0.6);
    }
    
    .subcards-panel-cards {
      display: flex;
      flex-wrap: wrap;
      gap: 25px;
      justify-content: center;
      align-content: flex-start;
      overflow-y: auto;
      padding: 30px;
      flex-grow: 1;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 18px;
      box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.08);
      backdrop-filter: blur(5px);
      margin: 0 10px;
    }
    
    .panel-subcard {
      transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
      margin: 10px;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
      border: 1px solid rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(5px);
    }
    
    .panel-subcard:hover {
      transform: translateY(-5px) scale(1.02);
      box-shadow: 0 12px 25px rgba(0, 0, 0, 0.2);
      border: 1px solid rgba(255, 255, 255, 0.2);
    }
    
    /* Glass overlay effect */
    .glass-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.1), rgba(255, 255, 255, 0.05));
      border-radius: 24px;
      z-index: -1;
    }
    
    .category-panel.active {
      transform: translateY(0);
      opacity: 1;
    }
    
    .category-panel-header {
      background: linear-gradient(90deg, rgba(103, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
      padding: 15px;
      font-size: 24px;
      font-weight: 600;
      text-align: center;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
      position: sticky;
      top: 0;
      z-index: 10;
      backdrop-filter: blur(5px);
    }
    
    .category-cards-container {
      animation: fadeIn 0.5s ease-out;
    }
    
    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    .category-view-back {
      background: linear-gradient(135deg, rgba(255, 107, 107, 0.8), rgba(255, 71, 87, 0.8));
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
      transition: all 0.3s ease;
    }
    
    .category-view-back:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.4);
      background: linear-gradient(135deg, rgba(255, 135, 135, 0.9), rgba(255, 101, 101, 0.9));
    }
    .fullscreen-mode .flashcard .expand-btn,
    .fullscreen-mode .flashcard-front .expand-btn,
    .fullscreen-mode .flashcard-back .expand-btn {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }
    
    /* Hide expand buttons in category panels */
    .category-panel .flashcard .expand-btn,
    .category-panel .flashcard-front .expand-btn,
    .category-panel .flashcard-back .expand-btn {
      display: none !important;
      visibility: hidden !important;
      opacity: 0 !important;
      pointer-events: none !important;
    }  
  </style>
`);

// Initialize fullscreen button
document.addEventListener('DOMContentLoaded', function() {
  const fullscreenBtn = document.getElementById('fullscreenBtn');
  if (fullscreenBtn) {
    fullscreenBtn.addEventListener('click', toggleFullscreenView);
  }
});
window.onload = function() {
  loadCards();
  loadConnections();
};
</script> 
</body>
</html>
